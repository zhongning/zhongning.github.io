<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker实战总结</title>
    <url>/posts/33867/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker是一个开源的应用容器引擎，开发者可以打包自己的应用到容器里面，然后迁移到其他机器的docker应用中，可以实现快速部署。</p>
<p>简单的理解，docker就是一个软件集装箱化平台，就像船只、火车、卡车运输集装箱而不论其内部的货物一样，软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。</p>
<p>按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境，如果出现的故障，也可以通过镜像，快速恢复服务。</p>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191109172555889-1603196756.png" alt></p>
<a id="more"></a>
<h2 id="Docker优势"><a href="#Docker优势" class="headerlink" title="Docker优势"></a>Docker优势</h2><h3 id="特性优势"><a href="#特性优势" class="headerlink" title="特性优势"></a>特性优势</h3><p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191109172604637-1990244867.png" alt></p>
<h3 id="资源优势"><a href="#资源优势" class="headerlink" title="资源优势"></a>资源优势</h3><p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112151326588-965047543.png" alt></p>
<h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p><strong>Client（客户端）</strong>：是Docker的用户端，可以接受用户命令和配置标识，并与Docker daemon通信。</p>
<p><strong>Images（镜像）</strong>：是一个只读模板，含创建Docker容器的说明，它与操作系统的安装光盘有点像。</p>
<p><strong>Containers（容器）</strong>：镜像的运行实例，镜像与容器的关系类比面向对象中的类和对象。</p>
<p><strong>Registry（仓库）</strong>：是一个集中存储与分发镜像的服务。最常用的Registry是官方的Docker Hub 。</p>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191109172624159-620464653.png" alt></p>
<h2 id="Docker安装使用"><a href="#Docker安装使用" class="headerlink" title="Docker安装使用"></a>Docker安装使用</h2><h3 id="操作系统：CentOS-7"><a href="#操作系统：CentOS-7" class="headerlink" title="操作系统：CentOS 7"></a>操作系统：CentOS 7</h3><p><strong>1、安装依赖</strong></p>
<blockquote>
<p>yum install -y yum-utils device-mapper-persistent-data lvm2</p>
</blockquote>
<p><strong>2、添加软件源</strong></p>
<blockquote>
<p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a>　　# 指定阿里云镜像源</p>
</blockquote>
<p><strong>3、安装docker-ce</strong>（对系统内核有一定要求，centos6不支持）</p>
<blockquote>
<p>yum clean all  yum makecache fast        # 重新生成缓存</p>
<p><strong>yum -y install docker-ce docker-ce-cli containerd.io</strong></p>
</blockquote>
<p><strong>4、设置自启并启动</strong></p>
<blockquote>
<p><strong>systemctl enable docker</strong></p>
<p><strong>systemctl start docker</strong></p>
</blockquote>
<p><strong>5、查看版本</strong></p>
<blockquote>
<p>docker version</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112154320701-108250532.png" alt></p>
<h3 id="运行示例：Nginx"><a href="#运行示例：Nginx" class="headerlink" title="运行示例：Nginx"></a>运行示例：Nginx</h3><h4 id="搜索并下载镜像"><a href="#搜索并下载镜像" class="headerlink" title="搜索并下载镜像"></a>搜索并下载镜像</h4><blockquote>
<p>docker search nginx</p>
<p>docker pull nginx</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112154517806-1605394976.png" alt></p>
<h4 id="启动一个容器并映射端口到本地"><a href="#启动一个容器并映射端口到本地" class="headerlink" title="启动一个容器并映射端口到本地"></a>启动一个容器并映射端口到本地</h4><blockquote>
<p>docker run -d -p 8080:80 –name Nginx nginx　　　　# 参数详解见下文</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112154526743-736147967.png" alt></p>
<h4 id="访问本地映射端口"><a href="#访问本地映射端口" class="headerlink" title="访问本地映射端口"></a>访问本地映射端口</h4><p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112154531659-814379855.png" alt></p>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="镜像控制"><a href="#镜像控制" class="headerlink" title="镜像控制"></a>镜像控制</h3><blockquote>
<p><strong>搜索镜像</strong>：docker  search  [OPTIONS]  TERM</p>
<p><strong>上传镜像</strong>：docker  push  [OPTIONS]  NAME[:TAG]</p>
<p><strong>下载镜像</strong>：docker  pull  [OPTIONS]  NAME[:TAG]</p>
<p><strong>提交镜像</strong>：docker  commit [OPTIONS]  CONTAINER  NAME[:TAG]</p>
<p><strong>构建镜像</strong>：docker  build  [OPTIONS]  PATH</p>
<p><strong>删除镜像</strong>：docker  rmi [OPTIONS]  IMAGE  [IMAGE…]</p>
<p><strong>增加镜像标签</strong>：docker  tag  SOURCE_IMAGE[:TAG]  TARGET_IMAGE[:TAG]</p>
<p><strong>查看所有镜像</strong>：docker  images  [OPTIONS]  [REPOSITORY[:TAG]]</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155412834-338762946.png" alt></p>
<h3 id="容器控制"><a href="#容器控制" class="headerlink" title="容器控制"></a>容器控制</h3><blockquote>
<p><strong>启动/重启容器</strong>：docker start/restart CONTAINER</p>
<p><strong>停止/强停容器</strong>：docker stop/kill CONTAINER</p>
<p><strong>删除容器</strong>：docker rm [OPTIONS] CONTAINER [CONTAINER…]</p>
<p><strong>重命名容器</strong>：docker rename CONTAINER CONTAINER_NEW</p>
<p><strong>进入容器</strong>：docker attach CONTAINER</p>
<p><strong>执行容器命令</strong>：docker exec CONTAINER COMMAND</p>
<p><strong>查看容器日志</strong>：docker logs [OPTIONS] CONTAINER</p>
<p><strong>查看容器列表</strong>：docker ps [OPTIONS]</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155423874-350386050.png" alt></p>
<h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><blockquote>
<p>docker  run  [OPTIONS]  IMAGE  [COMMAND]  [ARG…]</p>
</blockquote>
<p><strong>-d</strong>: 后台运行容器，并返回容器ID</p>
<p><strong>-i</strong>：以交互模式运行容器，通常与 -t 同时使用</p>
<p><strong>-t</strong>：为容器重新分配一个伪输入终端，通常与 -i 同时使用</p>
<p><strong>-v</strong>：绑定挂载目录</p>
<p><strong>–name=”mycontainer”</strong>: 为容器指定一个名称</p>
<p><strong>–net=”bridge”</strong>: 指定容器的网络连接类型，支持如下：</p>
<p>   　　bridge / host / none / container:&lt;name|id&gt;</p>
<p><strong>-p/-P</strong>:端口映射，格式如图：</p>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155237442-1935865842.png" alt></p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><blockquote>
<p>查看docker信息：docker info</p>
<p>docker命令帮助：docker run –help</p>
<p>复制文件到容器：docker cp custom.conf Nginx:/etc/nginx/conf.d/</p>
<p>更新容器启动项：docker container update –restart=always nginx</p>
<p>查看docker日志：tail -f /var/log/messages</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112161415759-1267729284.png" alt></p>
<p>>&gt;&gt; 更多可以参考官网：<a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/cli/</a></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1059616/201912/1059616-20191214150000098-1909876776.png" alt></p>
<h2 id="Docker镜像构建"><a href="#Docker镜像构建" class="headerlink" title="Docker镜像构建"></a>Docker镜像构建</h2><h3 id="Docker-commit（1运行2修改3保存）"><a href="#Docker-commit（1运行2修改3保存）" class="headerlink" title="Docker commit（1运行2修改3保存）"></a>Docker commit（1运行2修改3保存）</h3><p><strong>a）   运行容器</strong></p>
<blockquote>
<p>docker run -dit -p 8080:80 –name Nginx nginx</p>
</blockquote>
<p><strong>b）   修改容器</strong>（这里我只是做个演示，所以就复制一下文件，具体修改需要根据你实际情况）</p>
<blockquote>
<p>docker cp custom.conf Nginx:/etc/nginx/conf.d/</p>
</blockquote>
<p><strong>c）   将容器保存为新的镜像</strong></p>
<blockquote>
<p>docker commit Nginx zwx/nginx</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155640841-516876073.png" alt></p>
<h3 id="Dockerfile（1编写2构建）"><a href="#Dockerfile（1编写2构建）" class="headerlink" title="Dockerfile（1编写2构建）"></a>Dockerfile（1编写2构建）</h3><p><strong>a）   编写Dockerfile文件</strong></p>
<blockquote>
<p>vim Dockerfile</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155736158-842820092.png" alt></p>
<p><strong>b）   执行Dockerfile文件</strong></p>
<blockquote>
<p>docker build -t zwx/nginx <strong>.　　　　</strong># 后面有个点，代表当前目录下dockerfile文件</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155724434-463914884.png" alt></p>
<h3 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h3><p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112155749441-1705248710.png" alt></p>
<p>>&gt;&gt; 更多可以参考：<a href="https://www.cnblogs.com/leozhanggg/p/11820214.html" target="_blank" rel="noopener">【转载】Dockerfile文件详解</a></p>
<h2 id="Docker本地仓库"><a href="#Docker本地仓库" class="headerlink" title="Docker本地仓库"></a>Docker本地仓库</h2><p><strong>1、拉取镜像仓库</strong></p>
<blockquote>
<p>docker search registry</p>
<p>docker pull registry</p>
</blockquote>
<p><strong>2、启动镜像服务</strong></p>
<blockquote>
<p>docker run -dit \</p>
<p>–name=Registry \　　　　# 指定容器名称</p>
<p>-p 5000:5000 \　　　　　　# 仓库默认端口是5000，映射到宿主机，这样可以使用宿主机地址访问</p>
<p>–restart=always \                # 自动重启，这样每次docker重启后仓库容器也会自动启动</p>
<p>–privileged=true \              # 增加安全权限，一般可不加</p>
<p>-v /usr/local/my_registry:/var/lib/registry  \　　　　# 把仓库镜像数据保存到宿主机</p>
<p>registry</p>
</blockquote>
<p><strong>3、注册https协议</strong>（需要通过本地仓库下载镜像，均需要配置）</p>
<blockquote>
<p>vim /etc/docker/daemon.json　　　　　　　　# 默认无此文件，需自行添加，有则追加一下内容。</p>
<p>   { “insecure-registries”:[“ xx.xx.xx.xx:5000”] }　　# 指定ip地址或域名</p>
</blockquote>
<p><strong>4、新增tag指明仓库地址</strong></p>
<blockquote>
<p>docker <strong>tag</strong> zwx/nginx x.xx.xx.xx:5000/zwx/nginx　　# 如果构建时已经指定仓库地址，则可以省略</p>
</blockquote>
<p><strong>5、上传镜像到本地仓库</strong></p>
<blockquote>
<p>docker <strong>push</strong> x.xx.xx.xx:5000/zwx/nginx</p>
</blockquote>
<p><strong>6、查看本地仓库</strong></p>
<blockquote>
<p>curl -XGET <a href="http://x.xx.xx.xx:5000/v2/_catalog" target="_blank" rel="noopener">http://x.xx.xx.xx:5000/v2/_catalog</a></p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112160214624-1466104232.png" alt></p>
<p>>&gt;&gt; 更多可以参考：<a href="https://www.jianshu.com/p/8f38f198724e" target="_blank" rel="noopener">docker 搭建本地私有仓库</a></p>
<h2 id="Docker与图形管理工具Portainer"><a href="#Docker与图形管理工具Portainer" class="headerlink" title="Docker与图形管理工具Portainer"></a>Docker与图形管理工具Portainer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Portainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、</p>
<p>事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1059616/201911/1059616-20191112153539731-1511928488.png" alt></p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p><strong>a） 搜索并下载镜像</strong></p>
<blockquote>
<p>docker search portainer</p>
<p>docker pull portainer/portainer</p>
</blockquote>
<p><strong>b） 单机方式运行</strong></p>
<blockquote>
<p>docker run -d \</p>
<p>-p 9000:9000 \　　　# portainer默认端口是9000，映射到本地9000端口，通过本地地址访问</p>
<p>–restart=always \　　# 设置自动重启</p>
<p>-v /var/run/docker.sock:/var/run/docker.sock \　　# 单机必须指定docker.sock</p>
<p>–name Prtainer portainer/portainer</p>
</blockquote>
<p><strong>c） 访问<a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a></strong></p>
<p>首次登陆需要注册用户，给admin用户设置密码，然后单机版选择local连接即可。</p>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112153230740-1138499583.png" alt></p>
<p><strong>d） 控制管理</strong></p>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112153611631-1158270908.png" alt></p>
<p>>&gt;&gt; 更多可以参考：<a href="https://www.cnblogs.com/river2005/p/8283700.html" target="_blank" rel="noopener">Portainer介绍</a></p>
<h2 id="Docker与集群管理工具Swarm"><a href="#Docker与集群管理工具Swarm" class="headerlink" title="Docker与集群管理工具Swarm"></a>Docker与集群管理工具Swarm</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Swarm是Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。</p>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112152657240-1084437635.png" alt></p>
<h3 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h3><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。</p>
<p><strong>a)　　启动swarm集群只需要执行初始化命令即可：</strong></p>
<blockquote>
<p>docker swarm <strong>init</strong> \　　　　　　　# 默认初始化节点为管理节点<br>–advertise-addr xx.xx.xx.xx \　　　#指定使用的ip<br>–listen-addr xx.xx.xx.xx:2377　　　#指定监听ip和port，默认为2377</p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191128171456606-615353300.png" alt></p>
<p><strong>b) 　　设置manager节点</strong></p>
<blockquote>
<p>docker swarm join-token <strong>manager</strong>　　　　#获取管理节点token，放入下面命令</p>
<p>docker swarm join \<br>–advertise-addr xx.xx.xx.xx \<br>–listen-addr xx.xx.xx.xx:2377 \<br>–token SWMTKN-1-29ynh5uyfiiospy4fsm4pd4xucyji2rn0oj4b4ak4s7a37syf9-ajkrv2ctjr5cmxzuij75tbrmz \<br>xx.xx.xx.xx:2377</p>
</blockquote>
<p><strong>c) 　　设置worker节点</strong></p>
<blockquote>
<p>docker swarm join-token <strong>worker</strong>　　　　#获取工作节点token，放入下面命令</p>
<p>docker swarm join \<br>–advertise-addr xx.xx.xx.xx \<br>–listen-addr xx.xx.xx.xx:2377 \<br>–token SWMTKN-1-29ynh5uyfiiospy4fsm4pd4xucyji2rn0oj4b4ak4s7a37syf9-ajkrv2ctjr5cmxzuij75tbrmz \<br>xx.xx.xx.xx:2377</p>
</blockquote>
<p><strong>c) 　　查看节点</strong></p>
<blockquote>
<p> <strong><code>docker node ls</code></strong></p>
</blockquote>
<p><img src="https://img2018.cnblogs.com/i-beta/1059616/201911/1059616-20191128172311278-1473171098.png" alt></p>
<p><strong>d) 　　创建服务</strong></p>
<blockquote>
<p><strong><code>docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></strong></p>
<p><strong><code>--detach , -d</code>: </strong> 指定容器运行于前台还是后台，默认为false</p>
<p><strong><code>--name</code>: </strong> 服务名称</p>
<p><strong><code>--network</code>: </strong> 网络连接</p>
<p><strong><code>--publish , -p</code>: </strong> 端口映射</p>
<p><strong><code>--env , -e</code>:</strong>  设置环境变量</p>
<p><strong><code>--tty , -t</code>:</strong>  分配tty设备，该可以支持终端登录</p>
<p><strong><code>--mount</code>: </strong> 文件挂载</p>
<p><strong><code>--replicas</code>: </strong> 指定任务数量</p>
</blockquote>
<p>>&gt;&gt;更多参考：<a href="https://www.jianshu.com/p/028b40ca4f2a" target="_blank" rel="noopener">Docker Swarm集群部署实践</a>  　　<a href="https://www.cnblogs.com/xiangsikai/p/9935814.html" target="_blank" rel="noopener">Docker Swarm 常用命令</a></p>
<h3 id="对比K8s究竟有何异同"><a href="#对比K8s究竟有何异同" class="headerlink" title="对比K8s究竟有何异同?"></a>对比K8s究竟有何异同?</h3><p><strong>a）出生不同</strong></p>
<p>Google根据其在Linux上容器管理经验，改造到docker管理上，就是kubernetes。他的在许多方面表现良好,最重要的是构造于Google多年的宝贵经验只上。<br>kubernetes并不是为了docker写的,kubernetes把集群带到了一个全新的高度，代价是学习曲线比较陡。docker-swarm 使用了一个不同的方式,它是docker原生的集群工具。<br>最方便的部分是它暴露了docker标准的编程接口，意味着你之前一直在使用的任何与docker沟通的工具（docker CLI,  docker compose等），都可以无缝的在docker swarm上使用。</p>
<p><strong>b）安装配置不同</strong></p>
<p>安装设置swarm非常简单，简单明了并且很灵活。我们需要做的就是安装一个服务发现工具，然后在所有的节点上安装swarm容器。<br>相比较而言，kubernetes的安装就有点复杂晦涩了。不同的操作系统上安装都不同。每个操作系统都有自己的独立安装指令。</p>
<p><strong>c）运行方式不同</strong></p>
<p>使用Swarm和使用容器没有什么不同。比如，你习惯于使用Docker CLI（命令行接口），你可以继续使用几乎相同的命令。<br>如果你习惯于使用Docker Componse来运行容器，你可以继续在Swarm集群中使用。不管你之前习惯于怎么使用容器，你仍旧可以使用，只是在更大级别的集群中使用。<br>Kubernetes要求你去学习它自己的CLI（命令行接口）和配置。你不能使用你之前创建的docker-compose.yml配置，你必须要去新建与Kubernetes对应的配置。<br>你也不能使用之前学习的Docker CLI（命令行接口）。你必须要去学习 Kubernetes CLI（命令行接口）</p>
<p>最后，当需要在Docker Swarm 和 Kubernetes做出选择时，可以考虑如下几点：<br>你是否想依赖于Docker自己来解决集群的问题。如果是，选择Swarm。如果某些功能在Docker中不支持，那它也非常可能在Swarm中找不到，因为Swarm是依赖于Docker API的。<br>另外一方面，如果你想要一个工具可以解决Docker的限制，Kubernetes将是不错的选择。Kubernetes不是基于Docker，而是基于Google多年对于管理容器的经验。它是按照自己的方式来行事。</p>
<h2 id="Docker运维流程图"><a href="#Docker运维流程图" class="headerlink" title="Docker运维流程图"></a>Docker运维流程图</h2><p><img src="https://img2018.cnblogs.com/common/1059616/201911/1059616-20191112152457727-1393157662.png" alt></p>
<h2 id="Docker配置管理"><a href="#Docker配置管理" class="headerlink" title="Docker配置管理"></a>Docker配置管理</h2><p><strong>1.　　用了容器以后，还需要配置管理吗？</strong></p>
<p>起初我们跟Docker官方一样，属于理想主义派。天真的认为容器就应该是inmutable的，当需要配置变更的时候，重新构建镜像重新部署。</p>
<p>基于这一思路，我们在cSphere中添加了个镜像自动构建模块，用户可以配置代码仓库的地址。<br>服务的配置文件保存于Git或者SVN库中，需要配置变更时，向版本库中Push一下，自动通过hook触发镜像构建，并自动完成线上容器的重建。</p>
<p>通过这套系统，用户可以非常方便的批量更新线上的服务，并不局限于配置文件的变更，代码的变更也天生支持。<br>经过实际使用，这套系统能够很好的满足开发和测试环境的需求，提升工作效率。</p>
<p>但是，在生产环境中使用的时候，我们发现这种流程其实并不那么完美，主要表现在：<br>镜像构建和部署虽然自动化了，但构建是针对VCS中的某个仓库的，改一行配置就得整体重新构建一下，在更新容器时还需要把镜像重新分发到所有机器上，配置变更速度太慢。<br>这种方式的配置变更会涉及到服务的重启，这在生产环境某些场景下是不可接受的 ，有可能引起短暂的服务中断。</p>
<p><strong>2.　　应用配置文件应该需要做到什么？</strong></p>
<p>Docker应用配置文件能够保持能够支持针对不同环境作出更改。另外配置文件支持在线更改，重启就生效。一般分为以下两种方式。</p>
<p><strong>a） Docker环境变量</strong></p>
<p>需要在制作镜像的时候就需要提前想好，有哪些参数是部署容器的时候会经常更改，<br>然后把这些参数抽出来做成容器的环境变量，然后在部署的容器的时候填入不同的参数即可。<br>但是如果后续发现有一些参数不同场景下部署的时候也会修改，那就需要再重新制作镜像了。</p>
<p><strong>b）应用配置文件</strong></p>
<p>上述的管理方式不太灵活，灵活的管理方式是将配置文件和镜像剥离开，这样就不会被镜像给绑定了。</p>
<p>注：最新版本可以参考docker config命令管理</p>
<h2 id="Docker后续问题"><a href="#Docker后续问题" class="headerlink" title="Docker后续问题"></a>Docker后续问题</h2><ul>
<li>集群环境</li>
<li>网络安全</li>
<li>存储管理</li>
<li>日志收集</li>
<li>实时监控</li>
<li>性能调优</li>
<li>……</li>
</ul>
<h2 id="Docker报错解决"><a href="#Docker报错解决" class="headerlink" title="Docker报错解决"></a>Docker报错解决</h2><p><a href="https://www.cnblogs.com/leozhanggg/p/11730189.html" target="_blank" rel="noopener">【解决】Got permission denied while trying to connect to the Docker daemon socket at……dial unix /var/run/docker.sock: permission denied</a></p>
<p><a href="https://www.cnblogs.com/leozhanggg/p/12031433.html" target="_blank" rel="noopener">【解决】error pulling image configuration: Get https:// …… x509: certificate has expired or is not yet valid</a></p>
<p><a href="https://www.cnblogs.com/leozhanggg/p/12023531.html" target="_blank" rel="noopener">【解决】image … could not be accessed on a registry to record its digest.</a> </p>
<p><a href="https://www.cnblogs.com/leozhanggg/p/12023456.html" target="_blank" rel="noopener">【解决】http: server gave HTTP response to HTTPS client</a></p>
<p><a href="https://www.cnblogs.com/leozhanggg/p/12023429.html" target="_blank" rel="noopener">【解决】OCI runtime exec failed……executable file not found in $PATH”: unknown</a></p>
<p>更多报错解决方案持续更新中：<a href="https://www.cnblogs.com/leozhanggg/p/11796810.html" target="_blank" rel="noopener">【解决】Docker Errors</a></p>
<p>作者：LeoZhanggg</p>
<p>原文链接：<a href="https://www.cnblogs.com/leozhanggg/p/12039953.html" target="_blank" rel="noopener">https://www.cnblogs.com/leozhanggg/p/12039953.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 064 Minimum Path Sum</title>
    <url>/posts/27000/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定m x n的网格，填充的都是非负数，从左上角到右下角找出一条线路，使路径上数字之和最小，并返回这个最小和的值。</p>
<p>每次只能向下或者向右移动。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用动态规划dp[i][j]，表示在当前位置时所有路径数字之和最小的值，初始化起始位置dp[0][0]。</p>
<p>当i=0表示在第一行，那么dp[i][j] = dp[i][j-1]+grid[i][j]，即等于左侧位置最小和加上当前位置数字。</p>
<p>当j=0表示在第一列，dp[i][j] = dp[i-1][j]+grid[i][j]，即等于上方位置最小和加上当前位置数字。</p>
<p>其他情况下dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]，即上方或者左侧最小和取其中较小的，在加当前位置数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m*n)。</p>
<p><strong>空间复杂度:</strong> O(m*n)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述动态规划也可用一维数组实现，dp[j]表示在当前行第j列的最小路径和。</p>
<p>当j为0时表示第一列，dp[j]等于前一行第一列的路径和dp[j]加上当前位置的数字。</p>
<p>若i为0时表示第一行，则dp[j]等于左侧位置最小路径和加上当前位置的数字。</p>
<p>其他情况下，dp[j]等于左侧位置最小路径和上方位置最小路径中的较小值，再加上当前位置数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j]+=grid[i][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j]=dp[j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j-<span class="number">1</span>],dp[j])+grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m*n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 063 Unique Paths II</title>
    <url>/posts/61593/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt></p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p><strong>Note:</strong> m and n will be at most 100.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求机器人在长为m宽为n到格子中，从左上角走到右下角所有不重复路线的个数，每次只能向下或者向右移动。</p>
<p>考虑到在格子中添加一些障碍物，障碍物用1表示，空格子用0表示。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用动态规划，dp[i][j]代表到达位置行i列j的路线个数，一般来说等于当前位置的正上方和正左侧的所有线路之和。</p>
<p>遍历行m列n，若当前位置有障碍物，则dp[i][j]=0；对起始位置来说没有障碍物的话就是1。</p>
<p>当i或者j为0时，只能一直在第一行或者第一列移动，那么其取决于左侧或上方的值。</p>
<p>其他情况下dp[i][j]=dp[i-1][j]+dp[i][j-1];    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m*n)。</p>
<p><strong>空间复杂度:</strong> O(m*n)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述动态规划也可使用一维数组来保存，dp[j]表示当前行在列j的线路条数。</p>
<p>遍历数组，在同一行上，若当前位置有障碍则dp[j]为0；否则当j&gt;0时，dp[j]+=dp[j-1]。</p>
<p>因为对下一行来说，其在位置j上的线路包含上一行位置j的线路个数，再加上本行左侧j-1线路个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j]+=dp[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m*n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 062 Unique Paths</title>
    <url>/posts/38849/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt></p>
<p>Above is a 7 x 3 grid. How many possible unique paths are there?</p>
<p><strong>Note:</strong> m and n will be at most 100.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求机器人在长为m宽为n到格子中，从左上角走到右下角所有不重复路线的个数，每次只能向下或者向右移动。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用动态规划，dp[i][j]表示当前当前位置不同走法的个数。</p>
<p>当i或者j为0时表示在第一行或者第一列，因为每次只能向下或者向右移动，所有这种情况下线路只有一条。</p>
<p>否则dp[i][j]=dp[i-1][j]+dp[i][j-1]，即等于当前位置的正上方和正左侧的所有线路之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m*n)。</p>
<p><strong>空间复杂度:</strong> O(m*n)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述解法还有另外一种写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m*n)。</p>
<p><strong>空间复杂度:</strong> O(m*n)。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>对7*3的格子来说，一共要向下走2步向右走6步，可以用任意的顺序，这是一个全排列。</p>
<p>其中的一条线路如：D R R R D R R R，所有线路的条数为(m-1+n-1)!/((m-1)!(n-1)!)</p>
<p>若m比n大，则结果为排列组合C(n-1)(m+n-2)，即m…(m+n-2)/1…(n-1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Math.min(m-<span class="number">1</span>,n-<span class="number">1</span>);i++)&#123;</span><br><span class="line">            res=res*(m+n-<span class="number">1</span>-i)/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(m+n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 061 Rotate List</title>
    <url>/posts/50679/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对给定链表，将最后k个移动到最前面。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>利用快慢双指针，快指针先走k步，然后快慢指针一起后移直到快指针到达末尾，然后进行旋转。</p>
<p>对k比链表长对情况，先求出链表长度n，在用k对n求余作为新对k。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;  </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), left=dummy, right=dummy;</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k%n;</span><br><span class="line">        right = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            left=left.next;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        right.next=dummy.next;</span><br><span class="line">        dummy.next=left.next;</span><br><span class="line">        left.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>只使用一个指针，当遍历链表到末尾后记录其长度n，然后将链接头尾相连。</p>
<p>重新从尾部向着头部方向接着走n-k%n即可到达新链表到前置节点，然后从此节点后断开链表即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;  </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur=dummy;</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k%n;</span><br><span class="line">        cur.next=dummy.next;</span><br><span class="line">        <span class="keyword">int</span> m = n-k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的等待唤醒机制</title>
    <url>/posts/55050/</url>
    <content><![CDATA[<p>这是一篇走心的填坑笔记，自学Java的几年总是在不断学习新的技术，一路走来发现自己踩坑无数，而填上的坑却屈指可数。突然发现，有时候真的不是几年工作经验的问题，有些东西即使工作十年，没有用心去学习过也不过是一个10年大坑罢了（真实感受）。</p>
<p>刚开始接触多线程时，就知道有等待/唤醒这个东西，写过一个demo就再也没有看过了，至于它到底是个什么东西，或者说它能解决什么样的问题，估计大多数人和我一样都是模棱两可。这次笔者就尝试带你搞懂等待/唤醒机制，读完本文你将get到以下几点：</p>
<ol>
<li>循环等待带来什么样的问题</li>
<li>用等待唤醒机制优化循环等待</li>
<li>等待唤醒机制中的被忽略的细节</li>
</ol>
<a id="more"></a>
<h2 id="循环等待问题"><a href="#循环等待问题" class="headerlink" title="循环等待问题"></a>循环等待问题</h2><p>假设今天要发工资，强老板要去吃一顿好的，整个就餐流程可以分为以下几个步骤：</p>
<ol>
<li>点餐</li>
<li>窗口等待出餐</li>
<li>就餐</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 是否还有包子</span></span><br><span class="line">    AtomicBoolean hasBun = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包子铺老板</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 一直循环查看是否还有包子</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasBun.get()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"老板：检查一下是否还剩下包子..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"老板：没有包子了, 马上开始制作..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"老板：包子出锅咯...."</span>);</span><br><span class="line">                    hasBun.set(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"小强：我要买包子..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 每隔一段时间询问是否完成</span></span><br><span class="line">            <span class="keyword">while</span> (!hasBun.get()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"小强：包子咋还没做好呢~"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"小强：终于吃上包子了...."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://source.mycookies.cn/201912140042_561.png?ERROR" alt></p>
<p>在上文代码中存在一个很大的问题，就是老板需要不断的去检查是否还有包子，而客户则需要隔一段时间去看催一下老板，这显然是不合理的，这就是典型的循环等待问题。</p>
<p><img src="http://source.mycookies.cn/201912132338_507.jpg?ERROR" alt></p>
<p>这种问题的代码中通常是如下这种模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">       Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   doSomething();</span><br></pre></td></tr></table></figure>
<p>对应到计算机中，则暴露了一个问题：<strong>不断通过轮询机制来检测条件是否成立， 如果轮询时间过小则会浪费CPU资源，如果间隔过大，又导致不能及时获取想要的资源</strong>。</p>
<h2 id="等待-唤醒机制"><a href="#等待-唤醒机制" class="headerlink" title="等待/唤醒机制"></a>等待/唤醒机制</h2><p>为了<strong>解决循环等待消耗CPU以及信息及时性问题</strong>，Java中提供了等待唤醒机制。通俗来讲就是<strong>由主动变为被动</strong>， 当条件成立时，主动通知对应的线程，而不是让线程本身来询问。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>等待/唤醒机制，又叫等待通知（笔者更喜欢叫唤醒而非通知），是指线程A调用了对象O的wait()方法进入了等待状态，而另一个线程调用了O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。</p>
<p>上诉过程是通过对象O，使得线程A和线程B之间进行通信, 在线程中调用了对象O的wait()方法后线程久进入了阻塞状态，而在其他线程中对象O调用notify()或notifyAll方法时，则会唤醒对应的阻塞线程。</p>
<h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><p>等待/唤醒机制的相关方法是任意Java对象具备的，因为这些方法被定义在所有Java对象的超类Object中。</p>
<p><strong>notify</strong>： 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到对象的锁</p>
<p><strong>notifyAll</strong>: 通知所有等待在该对象上的线程</p>
<p><strong>wait</strong>: 调用此方法的线程进入阻塞等待状态，只有等待另外线程的<strong>通知或者被中断</strong>才会返回，调用<strong>wait方法会释放对象的锁</strong></p>
<p><strong>wait(long)</strong> : 等待超过一段时间没有被唤醒就超时自动返回，单位是毫秒。</p>
<h3 id="用等待唤醒机制优化循环等待"><a href="#用等待唤醒机制优化循环等待" class="headerlink" title="用等待唤醒机制优化循环等待"></a>用等待唤醒机制优化循环等待</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 是否还有包子</span></span><br><span class="line">        AtomicBoolean hasBun = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">        <span class="comment">// 锁对象</span></span><br><span class="line">        Object lockObject = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包子铺老板</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hasBun.get()) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"老板：包子够卖了，打一把王者荣耀"</span>);</span><br><span class="line">                            lockObject.wait(); </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"老板：没有包子了, 马上开始制作..."</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                            System.out.println(<span class="string">"老板：包子出锅咯...."</span>);</span><br><span class="line">                            hasBun.set(<span class="keyword">true</span>);</span><br><span class="line">                            <span class="comment">// 通知等待的食客</span></span><br><span class="line">                            lockObject.notifyAll();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"小强：我要买包子..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!hasBun.get()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"小强：看一下有没有做好， 看公众号cruder有没有新文章"</span>);</span><br><span class="line">                        lockObject.wait(); </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"小强：包子终于做好了，我要吃光它们...."</span>);</span><br><span class="line">                        hasBun.set(<span class="keyword">false</span>);</span><br><span class="line">                        lockObject.notifyAll();</span><br><span class="line">                        System.out.println(<span class="string">"小强：一口气把店里包子吃光了， 快快乐乐去板砖了~~"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://source.mycookies.cn/201912132357_184.png?ERROR" alt></p>
<p>上述流程，减少了轮询检查的操作，并且线程调用wait()方法后，会释放锁，不会消耗CPU资源，进而提高了程序的性能。</p>
<h2 id="等待唤醒机制的基本范式"><a href="#等待唤醒机制的基本范式" class="headerlink" title="等待唤醒机制的基本范式"></a>等待唤醒机制的基本范式</h2><p>等待、唤醒是线程间通信的手段之一，用来协调多个线程操作同一个数据源。实际应用中通常用来优化循环等待的问题，针对等待方和通知方，可以提炼出如下的经典范式。</p>
<p>需要注意的是，在等待方执行的逻辑中，一定要用while循环来判断等待条件，因为执行<strong>notify/notifyAll方法时只是让等待线程从wait方法返回，而非重新进入临界区</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待方执行的逻辑</span></span><br><span class="line"><span class="comment"> * 1. 获取对象的锁</span></span><br><span class="line"><span class="comment"> * 2. 检查条件，如果条件不满足，调用对象的wait方法，被通知后重新检查条件</span></span><br><span class="line"><span class="comment"> * 3. 条件满足则执行对应的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">        对象.wait()</span><br><span class="line">    &#125;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ！！ 通知方执行的逻辑</span></span><br><span class="line"><span class="comment"> * 1. 获取对象的锁</span></span><br><span class="line"><span class="comment"> * 2. 改变条件</span></span><br><span class="line"><span class="comment"> * 3. 通知(所有)等待在对象上的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    条件改变</span><br><span class="line">    对象.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个编程范式通常是针对典型的通知方和等待方，有时双方可能具有双重身份，即使等待方又是通知方，正如我们上文中的案例一样。</p>
<h2 id="notify-notifyAll不释放锁"><a href="#notify-notifyAll不释放锁" class="headerlink" title="notify/notifyAll不释放锁"></a>notify/notifyAll不释放锁</h2><p>相信这个问题有半数工程师都不知道，<strong>当执行wait()方法，锁自动被释放；但执行完notify()方法后，锁不会释放，而是要执行notify()方法所在的synchronized代码块后才会释放。</strong>这一点很重要，也是很多工程师容易忽略的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lockObject.notifyAll();</span><br><span class="line">System.out.println(<span class="string">"小强：一口气把店里包子吃光了， 快快乐乐去板砖了~~"</span>);</span><br></pre></td></tr></table></figure>
<p>案例代码中，故意设置成先notifyAll，然后在打印；上文图中的结果也印证了了我们的描述，感兴趣的小伙伴可以动手执行一下案例代码哦。</p>
<h2 id="等待、唤醒必须先获取锁"><a href="#等待、唤醒必须先获取锁" class="headerlink" title="等待、唤醒必须先获取锁"></a>等待、唤醒必须先获取锁</h2><p>在等待、唤醒编程范式中的<strong>wait，notify，notifyAll方法往往不能直接调用， 需要在获取锁之后的临界区执行</strong></p>
<p>并且只能唤醒等待在同一把锁上的线程。</p>
<p><strong>当线程调用wait方法时会被加入到一个等待队列，当执行notify时会唤醒队列中第一个等待线程(等待时间最长的线程)，而调用notifyAll时则会唤醒等待线程中所有的等待线程</strong>。</p>
<p><img src="http://source.mycookies.cn/201912140038_610.jpg?ERROR" alt></p>
<h2 id="sleep不释放锁-而wait-释放"><a href="#sleep不释放锁-而wait-释放" class="headerlink" title="sleep不释放锁 而wait 释放"></a>sleep不释放锁 而wait 释放</h2><p>在用等待唤醒机制优化循环等待的过程中，有一个重要的特征就是原本的sleep()方法用wait()方法取代，他们的最大的区别在于<strong>wait方法会释放锁，而sleep不会</strong>，除此之外，还有个重要的区别，<strong>sleep是Thread的方法，可以在任意地方执行；而wait是Object对象的方法，必须在synchronized代码块中执行</strong>。</p>
<p>作者：浪人~</p>
<p>原文链接：<a href="https://www.cnblogs.com/liqiangchn/p/12038007.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiangchn/p/12038007.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>图解AQS的设计与实现，手摸手带你实现一把互斥锁！</title>
    <url>/posts/39523/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>AQS是并发编程中非常重要的概念，它是juc包下的许多并发工具类，如CountdownLatch，CyclicBarrier，Semaphore和锁, 如ReentrantLock ReaderWriterLock的实现基础，提供了一个基于int状态码和队列来实现的并发框架。本文将对AQS框架的几个重要组成进行简要介绍，读完本文你将get到以下几个点：</p>
<ol>
<li>AQS进行并发控制的机制是什么</li>
<li>共享模式和独占模式获取和释放同步状态的详细过程</li>
<li>基于AQS框架实现一个简易的互斥锁</li>
</ol>
<a id="more"></a>
<h2 id="AQS基本概念"><a href="#AQS基本概念" class="headerlink" title="AQS基本概念"></a>AQS基本概念</h2><p>AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示状态，通过内置的FIFO（first in，first out）队列来完成资源获取线程的排队工作。</p>
<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS中维持一个全局的int状态码（state），线程通过修改（加/减指定的数量）码是否成功来决定当前线程是否成功获取到同步状态。</p>
<h3 id="独占or共享模式"><a href="#独占or共享模式" class="headerlink" title="独占or共享模式"></a>独占or共享模式</h3><p>AQS支持两种获取同步状态的模式既独占式和共享式。顾名思义，独占式模式同一时刻只允许一个线程获取同步状态，而共享模式则允许多个线程同时获取。</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233117600-2113769929.jpg" alt></p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列（一个FIFO双向队列）是AQS的核心，用来完成同步状态的管理，当线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造成一个节点并加入到同步队列，同时会阻塞当前线程。</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233118009-1456342769.png" alt></p>
<h2 id="独占模式获取与释放状态"><a href="#独占模式获取与释放状态" class="headerlink" title="独占模式获取与释放状态"></a>独占模式获取与释放状态</h2><p>独占模式既同一时间只能由一个线程持有同步状态。当多个线程竞争时(acquire)，获取到同步状态的线程会将当前线程赋值给<code>Thread exclusiveOwnerThread</code>属性（AQS父类中）来标记当前状态被线程独占。其他线程将被构造成Node加入到同步队列中。当线程l</p>
<h3 id="获取同步状态"><a href="#获取同步状态" class="headerlink" title="获取同步状态"></a>获取同步状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. tryAcquire    尝试获取同步状态; </span></span><br><span class="line"><span class="comment">     * 2.1 addWaiter     如果尝试获取到同步状态失败，则加入到同步队列中; </span></span><br><span class="line"><span class="comment">     * 2.2 acquireQueued 在队列中尝试获取同步状态.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>多线程并发获取（修改）同步状态, 修改同步状态成功的线程标记为拥有同步状态</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233118430-1256054001.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取同步状态【子类中实现】，因为aqs基于模板模式，仅提供基于状态和同步队列的实 </span></span><br><span class="line"><span class="comment"> * 现框架，具体的实现逻辑由子类决定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// a. 尝试修改状态值操作执行成功</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// b. 修改状态值成功，记录当前持有同步状态的线程信息</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前线程已经持有同步状态，继续修改同步状态【重入锁实现原理，不理解可以先忽略】</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>获取失败的线程，加入到同步队列的队尾；加入到队列中后，如果当前节点的前驱节点为头节点再次尝试获取同步状态（下文代码：p == head &amp;&amp; tryAcquire(arg)）。</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233118771-1689741253.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有获取到同步状态的线程加入到队尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尝试用最快的方式入队，如果入队失败，再走完整的入队方法</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 将当前线程设置到队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常的入队方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列中节点，尝试获取同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋(死循环)</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">// 只有当前节点的前驱节点是头节点时才会尝试执行获取同步状态操作</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">// 注意： 此处重点， 当前节点设置为头节点，相当于头节点出队</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取失败后是否进入wait</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果头节点的下一个节点尝试获取同步状态失败后，会进入等待状态；其他节点则继续自旋。</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233119143-1476789162.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// -------获取同步状态失败-------</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 获取失败后是否进入wait</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当获取同步状态失败后是否进入park状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点为唤醒状态，返回true【后面代码暂时可以忽略】</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>独占模式获取同步状态总结</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233119985-476209714.png" alt></p>
<h3 id="释放同步状态"><a href="#释放同步状态" class="headerlink" title="释放同步状态"></a>释放同步状态</h3><p>当线程执行完相应逻辑后，需要释放同步状态，使后继节点有机会同步状态（让出资源，让排队的线程使用）。这时就需要调用release(int arg)方法。调用该方法后，会唤醒后继节点。</p>
<ol>
<li>释放同步状态，唤醒后继节点</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233120861-935232279.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 尝试释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 释放成功后，执行unpark，既唤醒操作（暂时可忽略waitStatus，涉及到条件队列）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试释放同步状态，既将同步状态减去指定的值</span></span><br><span class="line"><span class="comment"> * 如果state = 0，表示当前线程  获取次数 = 释放次数，既释放成功，此时将持有同步状态线程标志为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 状态码=0，表示释放成功了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 独占标志设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 唤醒后继节点操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>后继节点获取同步状态成功，头节点出队。需要注意的事，出队操作是间接的，有节点获取到同步状态时，会将当前节点设置为head，而原本的head设置为null。</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233121530-1946057717.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列中节点，尝试获取同步状态（伪代码）</span></span><br><span class="line"><span class="comment"> * 获取成功后，当前节点设置为头节点，头节点设置为null，既头节点出队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋(死循环)</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// a. 操作：当前节点设置为头节点，当前节点的前驱节点设置为null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// b. 原始的head的next设置为null，此时原始的head已经被移出队列</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a.当前节点设置为头节点，当前节点的前驱节点设置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他竞争情况"><a href="#其他竞争情况" class="headerlink" title="其他竞争情况"></a>其他竞争情况</h3><ol>
<li>当同步队列中头节点唤醒后继节点时，此时可能有其他线程尝试获取同步状态。</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233122487-1148152296.png" alt></p>
<ol start="2">
<li>假设获取成功，将会被设置为头节点。</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233123222-2111205037.png" alt></p>
<ol start="3">
<li>头节点后续节点获取同步状态失败。</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233124139-1541007549.png" alt></p>
<h2 id="共享模式获取与释放状态"><a href="#共享模式获取与释放状态" class="headerlink" title="共享模式获取与释放状态"></a>共享模式获取与释放状态</h2><p>共享模式和独占模式最主要的区别是在<strong>支持同一时刻有多个线程同时获取同步状态</strong>。为了避免带来额外的负担，在上文中提到的同步队列中都是用独占模式进行讲述，其实同步队列中的节点应该是独占和共享节点并存的。</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233125056-1459011349.png" alt></p>
<p>接下来将针对共享模式状态下获取与释放状态的过程，图文并茂得进行分析。</p>
<h3 id="获取同步状态-1"><a href="#获取同步状态-1" class="headerlink" title="获取同步状态"></a>获取同步状态</h3><ol>
<li><p>首先至少要调用一次tryAcquireShared(arg)方法，如果返回值大于等于0表示获取成功。</p>
</li>
<li><p>当获取锁失败时，则创建一个共享类型的节点并进入一个同步队列，然后进入队列中进入自旋状态（阻塞，唤醒两种状态来回切换，直到获取到同步状态为止）</p>
</li>
<li><p>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，否则继续挂起等待。</p>
</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233126033-2079605281.png" alt></p>
<p>当一个同享节点获取到同步状态，并唤醒后面等待的共享状态的结果如下图所示：</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233127018-1280581551.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 共享模式获取同步状态；</span></span><br><span class="line"><span class="comment">  * 1. 首先至少要调用一次tryAcquireShared(arg)方法，如果返回值大于等于0表示获取成功，直接返回结果即可</span></span><br><span class="line"><span class="comment">  * 2. 否则，将会加入到同步队列中，反复阻塞与唤醒，直到获取同步状态成功为止； 获取成功后会唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 2. 自旋模式获取同步状态</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1 第一次获取失败后，会将此线程加入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// r &gt; 0表示获取同步状态成功，并且还有共享类型节点在同步队列中</span></span><br><span class="line">                <span class="comment">// r == 0 表示获取同步状态成功，同步队列中没有其他共享模式节点</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// ！！！！ 获取同步状态成功后，将当前node设置为头节点，并向后传播，唤醒共享模式等待的节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置新的头结点，并设置后面需要唤醒的节点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate &gt; 0 表明后面需要唤醒的共享模式节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">         <span class="comment">// 如果当前节点的后继节点是共享类型或者没有后继节点，则进行唤醒</span></span><br><span class="line">         <span class="comment">// 这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒所有共享模式节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 唤醒操作由头结点开始，注意这里的头节点已经是上面新设置的头结点了</span></span><br><span class="line">            <span class="comment">// 其实就是唤醒上面新获取到共享锁的节点的后继节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">// 表示后继节点需要被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="comment">//这里需要控制并发，因为入口有setHeadAndPropagate跟release两个，避免两次unpark</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;      </span><br><span class="line">                    <span class="comment">//执行唤醒操作 </span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果头结点没有发生变化，表示设置完成，退出循环</span></span><br><span class="line">            <span class="comment">// 如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试</span></span><br><span class="line">            <span class="keyword">if</span> (h == head)                   </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后，获取到同步状态的线程执行完毕，同步队列中只有一个独占节点：</p>
<p><img src="https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191129233127738-796396474.png" alt></p>
<h3 id="释放同步状态-1"><a href="#释放同步状态-1" class="headerlink" title="释放同步状态"></a>释放同步状态</h3><p>释放同步状态后，同步队列的变化过程和共享节点获取到同步状态后的变化过程一致，此处不再进行赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放同步状态，如果释放成功，唤醒后面等待的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 尝试释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">         <span class="comment">// 2. 释放成功后，唤醒后续等待共享节点</span></span><br><span class="line">         doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于AQS实现互斥锁"><a href="#基于AQS实现互斥锁" class="headerlink" title="基于AQS实现互斥锁"></a>基于AQS实现互斥锁</h2><p>读到此处，大部分人应该还比较懵逼，似懂非懂。接下来笔者将通过AQS实现一个互斥锁带你打开AQS的正确打开姿势。</p>
<p>多线程环境count += 1可能会存在问题，详情可以看在<a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTA1MjY4MQ==&amp;mid=2247483656&amp;idx=1&amp;sn=7eb663ac5881b2d850547d5f0da5d547&amp;chksm=cf0b13eef87c9af86b98f6de1e95d1cfa853936cd6202eb5b927b6c3af2a9f54936c8fdc7716&amp;token=57308900&amp;lang=zh_CN#rd" target="_blank" rel="noopener">并发编程bug的来源</a>中介绍的三大原因。正如大多数人都知道的，我们通常可以使用synchronized关键字进行同步，接下来我们就基于AQS自定义一个互斥锁来完成相同的功能。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义互斥锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cruder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/11/29 23:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sync STATE_HOLDER = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过Sync内部类来持有同步状态， 当状态为1表示锁被持有，0表示锁处于空闲状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否被独占， 有两种表示方式</span></span><br><span class="line"><span class="comment">         *  1. 可以根据状态，state=1表示锁被占用，0表示空闲</span></span><br><span class="line"><span class="comment">         *  2. 可以根据当前独占锁的线程来判断，即getExclusiveOwnerThread()!=null 表示被独占</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获取锁，将状态从0修改为1，操作成功则将当前线程设置为当前独占锁的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 释放锁，将状态修改为0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面的实现Lock接口需要重写的方法，基本是就是调用内部内Sync的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        STATE_HOLDER.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        STATE_HOLDER.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁的测试"><a href="#锁的测试" class="headerlink" title="锁的测试"></a>锁的测试</h3><p>我们定义一个计数器类，里面定义了2个不同的计数方法，其中一个使用互斥锁进行同步。开启10个线程并发执行，每个线程计数10000次，然后对比统计结果与预期的100，000是否相符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义锁测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/11/29 12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> countPerThread = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// 线程池创建的正确姿势</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(threadNum, threadNum, <span class="number">1000</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line">        Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">        Counter counterUnsafe = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countPerThread; j++) &#123;</span><br><span class="line">                    counter.getAndIncrement();</span><br><span class="line">                    counterUnsafe.getAndIncrementUnSfae();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.printf(<span class="string">"%s 个线程，每个线程累加了 %s 次，执行结果：safeCounter = %s, unsafeCounter = %s "</span>, threadNum, countPerThread, counter.get(), counterUnsafe.get());</span><br><span class="line">        threadPool.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutexLock mutexLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    Counter() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mutexLock = <span class="keyword">new</span> MutexLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mutexLock.lock();</span><br><span class="line">        count++;</span><br><span class="line">        mutexLock.unlock();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAndIncrementUnSfae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://source.mycookies.cn/201911300744_953.png?ERROR" alt>  </p>
<p>结果和预期一样，用自定义锁实现的计数器统计没有误差。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>AQS通过一个int同步状态码，和一个（先进先出）队列来控制多个线程访问资源</li>
<li>支持独占和共享两种模式获取同步状态码</li>
<li>当线程获取同步状态失败会被加入到同步队列中</li>
<li>当线程释放同步状态，会唤醒后继节点来获取同步状态</li>
<li>共享模式下的节点获取到同步状态或者释放同步状态时，不仅会唤醒后继节点，还会向后传播，唤醒所有同步节点</li>
<li>使用volatile关键字保证状态码在线程间的可见性，CAS操作保证修改状态码过程的原子性。</li>
</ol>
<p>AQS的设计与实现比本文中描述的要稍微复杂一些，为了达到快速入门的效果所以本文进行了简化。对于没有讲到的内容，比如，<strong>对于独占模式下超时获取同步状态， 队列中节点状态的流转， 条件队列</strong>等没有讲到的内容，将会放到下一篇文章中进行介绍。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Question1： 在java中通常使用synchronized来实现方法同步，AQS中通过CAS保证了修改同步状态的一致性问题，那么对比synchronized，cas有什么优势不同与优势呢？你还知道其他无锁并发的策略吗？</p>
<p>我的相关文章：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTA1MjY4MQ==&amp;mid=2247483656&amp;idx=1&amp;sn=7eb663ac5881b2d850547d5f0da5d547&amp;chksm=cf0b13eef87c9af86b98f6de1e95d1cfa853936cd6202eb5b927b6c3af2a9f54936c8fdc7716&amp;token=57308900&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一文搞懂并发编程bug的来源</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTA1MjY4MQ==&amp;mid=2247483662&amp;idx=1&amp;sn=0fd7532988619f458287a9667a1fe134&amp;chksm=cf0b13e8f87c9afe3590ae318a08d530e7832ec31f8fdd041924f1c200c592eaf1e470d51fb0&amp;token=57308900&amp;lang=zh_CN#rd" target="_blank" rel="noopener">无锁并发的CAS为何如此优秀</a></p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/1161d33fc1d0" target="_blank" rel="noopener">https://www.jianshu.com/p/1161d33fc1d0</a></p>
<p>《Java并发编程的艺术》</p>
<p>《Java并发编程实战》</p>
<p>作者： 浪人~</p>
<p>原文链接：<a href="https://www.cnblogs.com/liqiangchn/p/11960944.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiangchn/p/11960944.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>最强Java并发编程详解：知识点梳理，BAT面试题等</title>
    <url>/posts/12002/</url>
    <content><![CDATA[<h2 id="知识体系系统性梳理"><a href="#知识体系系统性梳理" class="headerlink" title="知识体系系统性梳理"></a>知识体系系统性梳理</h2><p><img src="http://www.pdai.tech/_images/java/java-concurrent-overview-1.png" alt></p>
<a id="more"></a>
<h2 id="Java-并发之基础"><a href="#Java-并发之基础" class="headerlink" title="Java 并发之基础"></a>Java 并发之基础</h2><blockquote>
<p><strong>A. Java进阶 - Java 并发之基础</strong>：首先全局的了解并发的知识体系，同时了解并发理论基础和线程基础，并发关键字等，这些是你理解Java并发框架的基础。@pdai</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-overview.html" target="_blank" rel="noopener">Java 并发 - 知识体系</a></li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-theorty.html" target="_blank" rel="noopener">Java 并发 - 理论基础</a><ul>
<li>多线程的出现是要解决什么问题的？</li>
<li>线程不安全是指什么？举例说明</li>
<li>并发出现线程不安全的本质什么？可见性，原子性和有序性。</li>
<li>Java是怎么解决并发问题的？3个关键字，JMM和8个Happens-Before</li>
<li>线程安全是不是非真即假？不是</li>
<li>线程安全有哪些实现思路？</li>
<li>如何理解并发和并行的区别？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html" target="_blank" rel="noopener">Java 并发 - 线程基础</a><ul>
<li>线程有哪几种状态？分别说明从一种状态到另一种状态转变有哪些方式？</li>
<li>通常线程有哪几种使用方式？</li>
<li>基础线程机制有哪些？</li>
<li>线程的中断方式有哪些？</li>
<li>线程的互斥同步方式有哪些？如何比较和选择？</li>
<li>线程之间有哪些协作方式？</li>
</ul>
</li>
</ul>
<h2 id="并发关键字：volatile，final，synchronized"><a href="#并发关键字：volatile，final，synchronized" class="headerlink" title="并发关键字：volatile，final，synchronized"></a>并发关键字：volatile，final，synchronized</h2><ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html" target="_blank" rel="noopener">关键字: synchronized详解</a><ul>
<li>Synchronized可以作用在哪里？分别通过对象锁和类锁进行举例。</li>
<li>Synchronized本质上是通过什么保证线程安全的？分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。</li>
<li>Synchronized由什么样的缺陷？ Java Lock是怎么弥补这些缺陷的。</li>
<li>Synchronized和Lock的对比，和选择？</li>
<li>Synchronized在使用时有何注意事项？</li>
<li>Synchronized修饰的方法在抛出异常时,会释放锁吗？</li>
<li>多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程？</li>
<li>Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法？</li>
<li>我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办？</li>
<li>什么是锁的升级和降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？</li>
<li>不同的JDK中对Synchronized有何优化？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html" target="_blank" rel="noopener">关键字: volatile详解</a><ul>
<li>volatile关键字的作用是什么？</li>
<li>volatile能保证原子性吗？</li>
<li>之前32位机器上共享的long和double变量的为什么要用volatile？现在64位机器上是否也要设置呢？</li>
<li>i++为什么不能保证原子性？</li>
<li>volatile是如何实现可见性的？ 内存屏障。</li>
<li>volatile是如何实现有序性的？ happens-before等</li>
<li>说下volatile的应用场景？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-key-final.html" target="_blank" rel="noopener">关键字: final详解</a><ul>
<li>所有的final修饰的字段都是编译期常量吗？</li>
<li>如何理解private所修饰的方法是隐式的final？</li>
<li>说说final类型的类如何拓展？比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做？</li>
<li>final方法可以被重载吗？可以</li>
<li>父类的final方法能不能够被子类重写？不可以</li>
<li>说说final域重排序规则？</li>
<li>说说final的原理？</li>
<li>使用 final 的限制条件和局限性？</li>
<li>看本文最后的一个思考题</li>
</ul>
</li>
</ul>
<h2 id="J-U-C框架"><a href="#J-U-C框架" class="headerlink" title="J.U.C框架"></a>J.U.C框架</h2><h3 id="Lock框架和Tools类"><a href="#Lock框架和Tools类" class="headerlink" title="Lock框架和Tools类"></a>Lock框架和Tools类</h3><h4 id="类结构总览"><a href="#类结构总览" class="headerlink" title="类结构总览"></a>类结构总览</h4><p><img src="http://www.pdai.tech/_images/thread/java-thread-x-juc-overview-lock.png" alt="image"></p>
<h4 id="接口-Condition"><a href="#接口-Condition" class="headerlink" title="接口: Condition"></a>接口: Condition</h4><blockquote>
<p>Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。</p>
</blockquote>
<p>在<a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">JUC锁: AbstractQueuedSynchonizer详解</a>中类的<strong>内部类-conditionobject类</strong>有具体分析。</p>
<h4 id="接口-Lock"><a href="#接口-Lock" class="headerlink" title="接口: Lock"></a>接口: Lock</h4><blockquote>
<p>Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</p>
</blockquote>
<h4 id="接口-ReadWriteLock"><a href="#接口-ReadWriteLock" class="headerlink" title="接口: ReadWriteLock"></a>接口: ReadWriteLock</h4><blockquote>
<p>ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p>
</blockquote>
<h4 id="抽象类-AbstractOwnableSynchonizer"><a href="#抽象类-AbstractOwnableSynchonizer" class="headerlink" title="抽象类: AbstractOwnableSynchonizer"></a>抽象类: AbstractOwnableSynchonizer</h4><blockquote>
<p>AbstractOwnableSynchonizer为抽象类，可以由线程以独占方式拥有的同步器。此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。AbstractOwnableSynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。</p>
</blockquote>
<h4 id="抽象类-long-AbstractQueuedLongSynchronizer"><a href="#抽象类-long-AbstractQueuedLongSynchronizer" class="headerlink" title="抽象类(long): AbstractQueuedLongSynchronizer"></a>抽象类(long): AbstractQueuedLongSynchronizer</h4><blockquote>
<p>AbstractQueuedLongSynchronizer为抽象类，以 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本。此类具有的结构、属性和方法与 AbstractQueuedSynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。</p>
</blockquote>
<h4 id="核心抽象类-int-AbstractQueuedSynchonizer"><a href="#核心抽象类-int-AbstractQueuedSynchonizer" class="headerlink" title="核心抽象类(int): AbstractQueuedSynchonizer"></a>核心抽象类(int): AbstractQueuedSynchonizer</h4><blockquote>
<p>AbstractQueuedSynchonizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">JUC锁: AbstractQueuedSynchonizer详解</a></p>
<h4 id="锁常用类-LockSupport"><a href="#锁常用类-LockSupport" class="headerlink" title="锁常用类: LockSupport"></a>锁常用类: LockSupport</h4><blockquote>
<p>LockSupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。LockSupport的功能和”Thread中的 Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html" target="_blank" rel="noopener">JUC锁: LockSupport详解</a></p>
<h4 id="锁常用类-ReentrantLock"><a href="#锁常用类-ReentrantLock" class="headerlink" title="锁常用类: ReentrantLock"></a>锁常用类: ReentrantLock</h4><blockquote>
<p>ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html" target="_blank" rel="noopener">JUC锁: ReentrantLock详解</a></p>
<h4 id="锁常用类-ReentrantReadWriteLock"><a href="#锁常用类-ReentrantReadWriteLock" class="headerlink" title="锁常用类: ReentrantReadWriteLock"></a>锁常用类: ReentrantReadWriteLock</h4><blockquote>
<p>ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html" target="_blank" rel="noopener">JUC工具类: ReentrantReadWriteLock详解</a></p>
<h4 id="锁常用类-StampedLock"><a href="#锁常用类-StampedLock" class="headerlink" title="锁常用类: StampedLock"></a>锁常用类: StampedLock</h4><blockquote>
<p>它是java8在java.util.concurrent.locks新增的一个API。StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/java8/java8-stampedlock.html" target="_blank" rel="noopener">Java 8 - StampedLock详解</a></p>
<h4 id="工具常用类-CountDownLatch"><a href="#工具常用类-CountDownLatch" class="headerlink" title="工具常用类: CountDownLatch"></a>工具常用类: CountDownLatch</h4><blockquote>
<p>CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-countdownlatch.html" target="_blank" rel="noopener">JUC工具类: CountDownLatch详解</a></p>
<h4 id="工具常用类-CyclicBarrier"><a href="#工具常用类-CyclicBarrier" class="headerlink" title="工具常用类: CyclicBarrier"></a>工具常用类: CyclicBarrier</h4><blockquote>
<p>CyclicBarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-cyclicbarrier.html" target="_blank" rel="noopener">JUC工具类: CyclicBarrier详解</a></p>
<h4 id="工具常用类-Phaser"><a href="#工具常用类-Phaser" class="headerlink" title="工具常用类: Phaser"></a>工具常用类: Phaser</h4><blockquote>
<p>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-phaser.html" target="_blank" rel="noopener">JUC工具类: Phaser详解</a></p>
<h4 id="工具常用类-Semaphore"><a href="#工具常用类-Semaphore" class="headerlink" title="工具常用类: Semaphore"></a>工具常用类: Semaphore</h4><blockquote>
<p>Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-semaphore.html" target="_blank" rel="noopener">JUC工具类: Semaphore详解</a></p>
<h4 id="工具常用类-Exchanger"><a href="#工具常用类-Exchanger" class="headerlink" title="工具常用类: Exchanger"></a>工具常用类: Exchanger</h4><blockquote>
<p>Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html" target="_blank" rel="noopener">JUC工具类: Exchanger详解</a></p>
<h3 id="Collections-并发集合"><a href="#Collections-并发集合" class="headerlink" title="Collections: 并发集合"></a>Collections: 并发集合</h3><h4 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h4><p><img src="http://www.pdai.tech/_images/thread/java-thread-x-juc-overview-2.png" alt="image"></p>
<h4 id="Queue-ArrayBlockingQueue"><a href="#Queue-ArrayBlockingQueue" class="headerlink" title="Queue: ArrayBlockingQueue"></a>Queue: ArrayBlockingQueue</h4><blockquote>
<p>一个由数组支持的有界阻塞队列。此队列按 FIFO(先进先出)原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html" target="_blank" rel="noopener">JUC并发集合: BlockingQueue详解</a></p>
<h4 id="Queue-LinkedBlockingQueue"><a href="#Queue-LinkedBlockingQueue" class="headerlink" title="Queue: LinkedBlockingQueue"></a>Queue: LinkedBlockingQueue</h4><blockquote>
<p>一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO(先进先出)排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html" target="_blank" rel="noopener">JUC并发集合: BlockingQueue详解</a></p>
<h4 id="Queue-LinkedBlockingDeque"><a href="#Queue-LinkedBlockingDeque" class="headerlink" title="Queue: LinkedBlockingDeque"></a>Queue: LinkedBlockingDeque</h4><blockquote>
<p>一个基于已链接节点的、任选范围的阻塞双端队列。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html" target="_blank" rel="noopener">JUC并发集合: BlockingQueue详解</a></p>
<h4 id="Queue-ConcurrentLinkedQueue"><a href="#Queue-ConcurrentLinkedQueue" class="headerlink" title="Queue: ConcurrentLinkedQueue"></a>Queue: ConcurrentLinkedQueue</h4><blockquote>
<p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html" target="_blank" rel="noopener">JUC并发集合: ConcurrentLinkedQueue详解</a></p>
<h4 id="Queue-ConcurrentLinkedDeque"><a href="#Queue-ConcurrentLinkedDeque" class="headerlink" title="Queue: ConcurrentLinkedDeque"></a>Queue: ConcurrentLinkedDeque</h4><blockquote>
<p>是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。</p>
</blockquote>
<h4 id="Queue-DelayQueue"><a href="#Queue-DelayQueue" class="headerlink" title="Queue: DelayQueue"></a>Queue: DelayQueue</h4><blockquote>
<p>延时无界阻塞队列，使用Lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。</p>
</blockquote>
<h4 id="Queue-PriorityBlockingQueue"><a href="#Queue-PriorityBlockingQueue" class="headerlink" title="Queue: PriorityBlockingQueue"></a>Queue: PriorityBlockingQueue</h4><blockquote>
<p>无界优先级阻塞队列，使用Lock机制实现并发访问。priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。</p>
</blockquote>
<h4 id="Queue-SynchronousQueue"><a href="#Queue-SynchronousQueue" class="headerlink" title="Queue: SynchronousQueue"></a>Queue: SynchronousQueue</h4><blockquote>
<p>没有容量的同步队列，通过CAS实现并发访问，支持FIFO和FILO。</p>
</blockquote>
<h4 id="Queue-LinkedTransferQueue"><a href="#Queue-LinkedTransferQueue" class="headerlink" title="Queue: LinkedTransferQueue"></a>Queue: LinkedTransferQueue</h4><blockquote>
<p>JDK 7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO(先进先出)方式。LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue(公平模式)和LinkedBlockingQueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。</p>
</blockquote>
<h4 id="List-CopyOnWriteArrayList"><a href="#List-CopyOnWriteArrayList" class="headerlink" title="List: CopyOnWriteArrayList"></a>List: CopyOnWriteArrayList</h4><blockquote>
<p>ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html" target="_blank" rel="noopener">JUC并发集合: CopyOnWriteArrayList详解</a></p>
<h4 id="Set-CopyOnWriteArraySet"><a href="#Set-CopyOnWriteArraySet" class="headerlink" title="Set: CopyOnWriteArraySet"></a>Set: CopyOnWriteArraySet</h4><blockquote>
<p>对其所有操作使用内部CopyOnWriteArrayList的Set。即将所有操作转发至CopyOnWriteArayList来进行操作，能够保证线程安全。在add时，会调用addIfAbsent，由于每次add时都要进行数组遍历，因此性能会略低于CopyOnWriteArrayList。</p>
</blockquote>
<h4 id="Set-ConcurrentSkipListSet"><a href="#Set-ConcurrentSkipListSet" class="headerlink" title="Set: ConcurrentSkipListSet"></a>Set: ConcurrentSkipListSet</h4><blockquote>
<p>一个基于ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
</blockquote>
<h4 id="Map-ConcurrentHashMap"><a href="#Map-ConcurrentHashMap" class="headerlink" title="Map: ConcurrentHashMap"></a>Map: ConcurrentHashMap</h4><blockquote>
<p>是线程安全HashMap的。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html" target="_blank" rel="noopener">JUC并发集合: ConcurrentHashMap详解</a>, 包含了对JDK 7和JDK 8版本的源码分析。</p>
<h4 id="Map-ConcurrentSkipListMap"><a href="#Map-ConcurrentSkipListMap" class="headerlink" title="Map: ConcurrentSkipListMap"></a>Map: ConcurrentSkipListMap</h4><blockquote>
<p>线程安全的有序的哈希表(相当于线程安全的TreeMap);映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
</blockquote>
<h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic: 原子类"></a>Atomic: 原子类</h3><p>其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p>
<p>对CAS，Unsafe类，以及13个原子类详解请参考：详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html" target="_blank" rel="noopener">JUC原子类: CAS, Unsafe和原子类详解</a></p>
<h4 id="基础类型：AtomicBoolean，AtomicInteger，AtomicLong"><a href="#基础类型：AtomicBoolean，AtomicInteger，AtomicLong" class="headerlink" title="基础类型：AtomicBoolean，AtomicInteger，AtomicLong"></a>基础类型：AtomicBoolean，AtomicInteger，AtomicLong</h4><blockquote>
<p>AtomicBoolean，AtomicInteger，AtomicLong是类似的，分别针对bool，interger，long的原子类。</p>
</blockquote>
<h4 id="数组：AtomicIntegerArray，AtomicLongArray，BooleanArray"><a href="#数组：AtomicIntegerArray，AtomicLongArray，BooleanArray" class="headerlink" title="数组：AtomicIntegerArray，AtomicLongArray，BooleanArray"></a>数组：AtomicIntegerArray，AtomicLongArray，BooleanArray</h4><blockquote>
<p>AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray是数组原子类。</p>
</blockquote>
<h4 id="引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference"><a href="#引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference" class="headerlink" title="引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference"></a>引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference</h4><blockquote>
<p>AtomicReference，AtomicMarkedReference，AtomicStampedReference是引用相关的原子类。</p>
</blockquote>
<h4 id="FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater"><a href="#FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater" class="headerlink" title="FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater"></a>FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</h4><blockquote>
<p>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater是FieldUpdater原子类。</p>
</blockquote>
<h3 id="Executors-线程池"><a href="#Executors-线程池" class="headerlink" title="Executors: 线程池"></a>Executors: 线程池</h3><h4 id="类结构关系-1"><a href="#类结构关系-1" class="headerlink" title="类结构关系"></a>类结构关系</h4><p><img src="http://www.pdai.tech/_images/thread/java-thread-x-juc-executors-1.png" alt></p>
<h4 id="接口-Executor"><a href="#接口-Executor" class="headerlink" title="接口: Executor"></a>接口: Executor</h4><blockquote>
<p>Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。</p>
</blockquote>
<h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><blockquote>
<p>ExecutorService继承自Executor接口，ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以关闭 ExecutorService，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。</p>
</blockquote>
<h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><blockquote>
<p>ScheduledExecutorService继承自ExecutorService接口，可安排在给定的延迟后运行或定期执行的命令。</p>
</blockquote>
<h4 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h4><blockquote>
<p>AbstractExecutorService继承自ExecutorService接口，其提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。</p>
</blockquote>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><blockquote>
<p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-FutureTask.html" target="_blank" rel="noopener">JUC线程池: FutureTask详解</a></p>
<h4 id="核心-ThreadPoolExecutor"><a href="#核心-ThreadPoolExecutor" class="headerlink" title="核心: ThreadPoolExecutor"></a>核心: ThreadPoolExecutor</h4><blockquote>
<p>ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html" target="_blank" rel="noopener">JUC线程池: ThreadPoolExecutor详解</a></p>
<h4 id="核心-ScheduledThreadExecutor"><a href="#核心-ScheduledThreadExecutor" class="headerlink" title="核心: ScheduledThreadExecutor"></a>核心: ScheduledThreadExecutor</h4><blockquote>
<p>ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html" target="_blank" rel="noopener">JUC线程池: ScheduledThreadExecutor详解</a></p>
<h4 id="核心-Fork-Join框架"><a href="#核心-Fork-Join框架" class="headerlink" title="核心: Fork/Join框架"></a>核心: Fork/Join框架</h4><blockquote>
<p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</p>
</blockquote>
<p>详细分析请看: <a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html" target="_blank" rel="noopener">JUC线程池: Fork/Join框架详解</a></p>
<h4 id="工具类-Executors"><a href="#工具类-Executors" class="headerlink" title="工具类: Executors"></a>工具类: Executors</h4><blockquote>
<p>Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。它的使用融入到了ThreadPoolExecutor, ScheduledThreadExecutor和ForkJoinPool中。</p>
</blockquote>
<h3 id="J-U-C框架重点面试题详解"><a href="#J-U-C框架重点面试题详解" class="headerlink" title="J.U.C框架重点面试题详解"></a>J.U.C框架重点面试题详解</h3><blockquote>
<p><strong>B. Java进阶 - Java 并发之J.U.C框架</strong>：然后需要对J.U.C框架五大类详细解读，包括：Lock框架，并发集合, 原子类, 线程池和工具类。@pdai</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html" target="_blank" rel="noopener">JUC - 类汇总和学习指南</a><ul>
<li>JUC框架包含几个部分？</li>
<li>每个部分有哪些核心的类？</li>
<li>最最核心的类有哪些？</li>
</ul>
</li>
</ul>
<h4 id="J-U-C框架【1-5】：CAS及原子类"><a href="#J-U-C框架【1-5】：CAS及原子类" class="headerlink" title="J.U.C框架【1/5】：CAS及原子类"></a>J.U.C框架【1/5】：CAS及原子类</h4><blockquote>
<p><strong>B.1 Java进阶 - Java 并发之J.U.C框架【1/5】：CAS及原子类</strong>：从最核心的CAS, Unsafe和原子类开始分析。</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html" target="_blank" rel="noopener">JUC原子类: CAS, Unsafe和原子类详解</a><ul>
<li>线程安全的实现方法有哪些？</li>
<li>什么是CAS？</li>
<li>CAS使用示例，结合AtomicInteger给出示例？</li>
<li>CAS会有哪些问题？</li>
<li>针对这这些问题，Java提供了哪几个解决的？</li>
<li>AtomicInteger底层实现？CAS+volatile</li>
<li>请阐述你对Unsafe类的理解？</li>
<li>说说你对Java原子类的理解？包含13个，4组分类，说说作用和使用场景。</li>
<li>AtomicStampedReference是什么？</li>
<li>AtomicStampedReference是怎么解决ABA的？内部使用Pair来存储元素值及其版本号</li>
<li>java中还有哪些类可以解决ABA的问题？AtomicMarkableReference</li>
</ul>
</li>
</ul>
<h4 id="J-U-C框架【2-5】：锁"><a href="#J-U-C框架【2-5】：锁" class="headerlink" title="J.U.C框架【2/5】：锁"></a>J.U.C框架【2/5】：锁</h4><blockquote>
<p><strong>B.2 Java进阶 - Java 并发之J.U.C框架【2/5】：锁</strong>：然后分析JUC中锁。</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html" target="_blank" rel="noopener">JUC锁: LockSupport详解</a><ul>
<li>为什么LockSupport也是核心基础类？AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)</li>
<li>写出分别通过wait/notify和LockSupport的park/unpark实现同步？</li>
<li>LockSupport.park()会释放锁资源吗？那么Condition.await()呢？</li>
<li>Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别？重点</li>
<li>如果在wait()之前执行了notify()会怎样？</li>
<li>如果在park()之前执行了unpark()会怎样？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">JUC锁: 锁核心类AQS详解</a><ul>
<li>什么是AQS？为什么它是核心?</li>
<li>AQS的核心思想是什么？它是怎么实现的？底层数据结构等</li>
<li>AQS有哪些核心的方法？</li>
<li>AQS定义什么样的资源获取方式？AQS定义了两种资源获取方式：<code>独占</code>(只有一个线程能访问执行，又根据是否按队列的顺序分为<code>公平锁</code>和<code>非公平锁</code>，如<code>ReentrantLock</code>) 和<code>共享</code>(多个线程可同时访问执行，如<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code> )。<code>ReentrantReadWriteLock</code>可以看成是组合式，允许多个线程同时对某一资源进行读。</li>
<li>AQS底层使用了什么样的设计模式？模板</li>
<li>AQS的应用示例？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html" target="_blank" rel="noopener">JUC锁: ReentrantLock详解</a><ul>
<li>什么是可重入，什么是可重入锁？它用来解决什么问题？</li>
<li>ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗？说说其类内部结构关系。</li>
<li>ReentrantLock是如何实现公平锁的？</li>
<li>ReentrantLock是如何实现非公平锁的？</li>
<li>ReentrantLock默认实现的是公平还是非公平锁？</li>
<li>使用ReentrantLock实现公平和非公平锁的示例？</li>
<li>ReentrantLock和Synchronized的对比？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html" target="_blank" rel="noopener">JUC锁: ReentrantReadWriteLock详解</a><ul>
<li>为了有了ReentrantLock还需要ReentrantReadWriteLock？</li>
<li>ReentrantReadWriteLock底层实现原理？</li>
<li>ReentrantReadWriteLock底层读写状态如何设计的？高16位为读锁，低16位为写锁</li>
<li>读锁和写锁的最大数量是多少？</li>
<li>本地线程计数器ThreadLocalHoldCounter是用来做什么的？</li>
<li>缓存计数器HoldCounter是用来做什么的？</li>
<li>写锁的获取与释放是怎么实现的？</li>
<li>读锁的获取与释放是怎么实现的？</li>
<li>RentrantReadWriteLock为什么不支持锁升级？</li>
<li>什么是锁的升降级？RentrantReadWriteLock为什么不支持锁升级？</li>
</ul>
</li>
</ul>
<h4 id="J-U-C框架【3-5】：集合"><a href="#J-U-C框架【3-5】：集合" class="headerlink" title="J.U.C框架【3/5】：集合"></a>J.U.C框架【3/5】：集合</h4><blockquote>
<p><strong>B.3 Java进阶 - Java 并发之J.U.C框架【3/5】：集合</strong>：再理解JUC中重要的支持并发的集合。</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html" target="_blank" rel="noopener">JUC集合: ConcurrentHashMap详解</a><ul>
<li>为什么HashTable慢? 它的并发度是什么？那么ConcurrentHashMap并发度是什么？</li>
<li>ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别？JDK1.8解決了JDK1.7中什么问题</li>
<li>ConcurrentHashMap JDK1.7实现的原理是什么？分段锁机制</li>
<li>ConcurrentHashMap JDK1.8实现的原理是什么？数组+链表+红黑树，CAS</li>
<li>ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少？为何一旦初始化就不可再扩容？</li>
<li>ConcurrentHashMap JDK1.7说说其put的机制？</li>
<li>ConcurrentHashMap JDK1.7是如何扩容的？rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容)</li>
<li>ConcurrentHashMap JDK1.8是如何扩容的？tryPresize</li>
<li>ConcurrentHashMap JDK1.8链表转红黑树的时机是什么？临界值为什么是8？</li>
<li>ConcurrentHashMap JDK1.8是如何进行数据迁移的？transfer</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html" target="_blank" rel="noopener">JUC集合: CopyOnWriteArrayList详解</a><ul>
<li>请先说说非并发集合中Fail-fast机制？</li>
<li>再为什么说ArrayList查询快而增删慢？</li>
<li>对比ArrayList说说CopyOnWriteArrayList的增删改查实现原理? COW基于拷贝</li>
<li>再说下弱一致性的迭代器原理是怎么样的？<code>COWIterator&lt;E&gt;</code></li>
<li>CopyOnWriteArrayList为什么并发安全且性能比Vector好？</li>
<li>CopyOnWriteArrayList有何缺陷，说说其应用场景？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html" target="_blank" rel="noopener">JUC集合: ConcurrentLinkedQueue详解</a><ul>
<li>要想用线程安全的队列有哪些选择？Vector，<code>Collections.synchronizedList( List&lt;T&gt; list)</code>, ConcurrentLinkedQueue等</li>
<li>ConcurrentLinkedQueue实现的数据结构？</li>
<li>ConcurrentLinkedQueue底层原理？ 全程无锁(CAS)</li>
<li>ConcurrentLinkedQueue的核心方法有哪些？offer()，poll()，peek()，isEmpty()等队列常用方法</li>
<li>说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计？</li>
<li>ConcurrentLinkedQueue适合什么样的使用场景？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html" target="_blank" rel="noopener">JUC集合: BlockingQueue详解</a><ul>
<li>什么是BlockingDeque？</li>
<li>BlockingQueue大家族有哪些？ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, SynchronousQueue…</li>
<li>BlockingQueue适合用在什么样的场景？</li>
<li>BlockingQueue常用的方法？</li>
<li>BlockingQueue插入方法有哪些？这些方法(<code>add(o)</code>,<code>offer(o)</code>,<code>put(o)</code>,<code>offer(o, timeout, timeunit)</code>)的区别是什么？</li>
<li>BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法？</li>
<li>BlockingDeque适合用在什么样的场景？</li>
<li>BlockingDeque大家族有哪些？</li>
<li>BlockingDeque 与BlockingQueue实现例子？</li>
</ul>
</li>
</ul>
<h4 id="J-U-C框架【4-5】：线程池"><a href="#J-U-C框架【4-5】：线程池" class="headerlink" title="J.U.C框架【4/5】：线程池"></a>J.U.C框架【4/5】：线程池</h4><blockquote>
<p><strong>B.4 Java进阶 - Java 并发之J.U.C框架【4/5】：线程池</strong>：再者分析JUC中非常常用的线程池等。</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-FutureTask.html" target="_blank" rel="noopener">JUC线程池: FutureTask详解</a><ul>
<li>FutureTask用来解决什么问题的？为什么会出现？</li>
<li>FutureTask类结构关系怎么样的？</li>
<li>FutureTask的线程安全是由什么保证的？</li>
<li>FutureTask结果返回机制？</li>
<li>FutureTask内部运行状态的转变？</li>
<li>FutureTask通常会怎么用？举例说明。</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html" target="_blank" rel="noopener">JUC线程池: ThreadPoolExecutor详解</a><ul>
<li>为什么要有线程池？</li>
<li>Java是实现和管理线程池有哪些方式？ 请简单举例如何使用。</li>
<li>为什么很多公司不允许使用Executors去创建线程池？那么推荐怎么使用呢？</li>
<li>ThreadPoolExecutor有哪些核心的配置参数？请简要说明</li>
<li>ThreadPoolExecutor可以创建哪是哪三种线程池呢？</li>
<li>当队列满了并且worker的数量达到maxSize的时候，会怎么样？</li>
<li>说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略？默认是什么策略？</li>
<li>简要说下线程池的任务执行机制？execute –&gt; addWorker –&gt;runworker (getTask)</li>
<li>线程池中任务是如何提交的？</li>
<li>线程池中任务是如何关闭的？</li>
<li>在配置线程池的时候需要考虑哪些配置因素？</li>
<li>如何监控线程池的状态？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html" target="_blank" rel="noopener">JUC线程池: ScheduledThreadPool详解</a><ul>
<li>ScheduledThreadPoolExecutor要解决什么样的问题？</li>
<li>ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性？</li>
<li>ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类？</li>
<li>ScheduledThreadPoolExecutor有哪两个关闭策略？区别是什么？</li>
<li>ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么？</li>
<li>为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？</li>
<li>Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html" target="_blank" rel="noopener">JUC线程池: Fork/Join框架详解</a><ul>
<li>Fork/Join主要用来解决什么样的问题？</li>
<li>Fork/Join框架是在哪个JDK版本中引入的？</li>
<li>Fork/Join框架主要包含哪三个模块？模块之间的关系是怎么样的？</li>
<li>ForkJoinPool类继承关系？</li>
<li>ForkJoinTask抽象类继承关系？在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</li>
<li>整个Fork/Join 框架的执行流程/运行机制是怎么样的？</li>
<li>具体阐述Fork/Join的分治思想和work-stealing 实现方式？</li>
<li>有哪些JDK源码中使用了Fork/Join思想？</li>
<li>如何使用Executors工具类创建ForkJoinPool?</li>
<li>写一个例子: 用ForkJoin方式实现1+2+3+…+100000?</li>
<li>Fork/Join在使用时有哪些注意事项？结合JDK中的斐波那契数列实例具体说明。</li>
</ul>
</li>
</ul>
<h4 id="J-U-C框架【5-5】：工具类"><a href="#J-U-C框架【5-5】：工具类" class="headerlink" title="J.U.C框架【5/5】：工具类"></a>J.U.C框架【5/5】：工具类</h4><blockquote>
<p><strong>B.5 Java进阶 - Java 并发之J.U.C框架【5/5】：工具类</strong>：最后来看下JUC中有哪些工具类，以及线程隔离术ThreadLocal。</p>
</blockquote>
<ul>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-countdownlatch.html" target="_blank" rel="noopener">JUC工具类: CountDownLatch详解</a><ul>
<li>什么是CountDownLatch？</li>
<li>CountDownLatch底层实现原理？</li>
<li>CountDownLatch一次可以唤醒几个任务？多个</li>
<li>CountDownLatch有哪些主要方法？await(),countDown()</li>
<li>CountDownLatch适用于什么场景？</li>
<li>写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用CountDownLatch 代替wait notify 好处。</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-cyclicbarrier.html" target="_blank" rel="noopener">JUC工具类: CyclicBarrier详解</a><ul>
<li>什么是CyclicBarrier？</li>
<li>CyclicBarrier底层实现原理？</li>
<li>CountDownLatch和CyclicBarrier对比？</li>
<li>CyclicBarrier的核心函数有哪些？</li>
<li>CyclicBarrier适用于什么场景？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-semaphore.html" target="_blank" rel="noopener">JUC工具类: Semaphore详解</a><ul>
<li>什么是Semaphore？</li>
<li>Semaphore内部原理？</li>
<li>Semaphore常用方法有哪些？如何实现线程同步和互斥的？</li>
<li>Semaphore适合用在什么场景？</li>
<li>单独使用Semaphore是不会使用到AQS的条件队列？</li>
<li>Semaphore中申请令牌(acquire)、释放令牌(release)的实现？</li>
<li>Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么？</li>
<li>Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么？</li>
<li>Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗？</li>
<li>Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-phaser.html" target="_blank" rel="noopener">JUC工具类: Phaser详解</a><ul>
<li>Phaser主要用来解决什么问题？</li>
<li>Phaser与CyclicBarrier和CountDownLatch的区别是什么？</li>
<li>如果用CountDownLatch来实现Phaser的功能应该怎么实现？</li>
<li>Phaser运行机制是什么样的？</li>
<li>给一个Phaser使用的示例？</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html" target="_blank" rel="noopener">JUC工具类: Exchanger详解</a><ul>
<li>Exchanger主要解决什么问题？</li>
<li>对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式？</li>
<li>Exchanger在不同的JDK版本中实现有什么差别？</li>
<li>Exchanger实现机制？</li>
<li>Exchanger已经有了slot单节点，为什么会加入arena node数组？什么时候会用到数组？</li>
<li>arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？</li>
<li>什么是伪共享，Exchanger中如何体现的？</li>
<li>Exchanger实现举例</li>
</ul>
</li>
<li><a href="http://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html" target="_blank" rel="noopener">Java 并发 - ThreadLocal详解</a><ul>
<li>什么是ThreadLocal？用来解决什么问题的？</li>
<li>说说你对ThreadLocal的理解</li>
<li>ThreadLocal是如何实现线程隔离的？</li>
<li>为什么ThreadLocal会造成内存泄露？如何解决</li>
<li>还有哪些使用ThreadLocal的应用场景？</li>
</ul>
</li>
</ul>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><blockquote>
<p>最全的Java后端知识体系 <a href="https://www.pdai.tech" target="_blank" rel="noopener">https://www.pdai.tech</a>, 每天更新中…。</p>
</blockquote>
<p>更多文章请参考 <a href="http://www.cnblogs.com/pengdai/" target="_blank" rel="noopener">http://www.cnblogs.com/pengdai/</a></p>
<p>作者：@pdai</p>
<p>原文链接：<a href="https://www.cnblogs.com/pengdai/p/12026959.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengdai/p/12026959.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>告别编码5分钟，命名2小时！史上最全的Java命名规范参考！</title>
    <url>/posts/18270/</url>
    <content><![CDATA[<p>简洁清爽的代码风格应该是大多数工程师所期待的。在工作中笔者常常因为起名字而纠结，夸张点可以说是编程5分钟，命名两小时！究竟为什么命名成为了工作中的拦路虎。</p>
<p>每个公司都有不同的标准，目的是为了保持统一，减少沟通成本，提升团队研发效能。所以本文中是笔者结合阿里巴巴开发规范，以及工作中的见闻针对Java领域相关命名进行整理和总结，仅供参考。</p>
<a id="more"></a>
<h2 id="Java中的命名规范"><a href="#Java中的命名规范" class="headerlink" title="Java中的命名规范"></a>Java中的命名规范</h2><p>好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，<strong>类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>约束</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>项目名</td>
<td>全部小写，多个单词用中划线分隔‘-’</td>
<td>spring-cloud</td>
</tr>
<tr>
<td>包名</td>
<td>全部小写</td>
<td>com.alibaba.fastjson</td>
</tr>
<tr>
<td>类名</td>
<td>单词首字母大写</td>
<td>Feature, ParserConfig,DefaultFieldDeserializer</td>
</tr>
<tr>
<td>变量名</td>
<td>首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td>
<td>password, userName</td>
</tr>
<tr>
<td>常量名</td>
<td>全部大写，多个单词，用’_’分隔</td>
<td>CACHE_EXPIRED_TIME</td>
</tr>
<tr>
<td>方法</td>
<td>同变量</td>
<td>read(), readObject(), getById()</td>
</tr>
</tbody>
</table>
<h2 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h2><p><strong>包名</strong>统一使用<strong>小写</strong>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。</p>
<p>包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：</p>
<table>
<thead>
<tr>
<th>前缀名</th>
<th>例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>indi（或onem ）</td>
<td>indi.发起者名.项目名.模块名.……</td>
<td>个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。</td>
</tr>
<tr>
<td>pers</td>
<td>pers.个人名.项目名.模块名.……</td>
<td>个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人</td>
</tr>
<tr>
<td>priv</td>
<td>priv.个人名.项目名.模块名.……</td>
<td>私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。</td>
</tr>
<tr>
<td>team</td>
<td>team.团队名.项目名.模块名.……</td>
<td>团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有</td>
</tr>
<tr>
<td>顶级域名</td>
<td>com.公司名.项目名.模块名.……</td>
<td>公司项目，copyright由项目发起的公司所有</td>
</tr>
</tbody>
</table>
<h2 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h2><p><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。</p>
<p>对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是统一就好。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>约束</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象类</td>
<td>Abstract 或者 Base 开头</td>
<td>BaseUserService</td>
</tr>
<tr>
<td>枚举类</td>
<td>Enum 作为后缀</td>
<td>GenderEnum</td>
</tr>
<tr>
<td>工具类</td>
<td>Utils作为后缀</td>
<td>StringUtils</td>
</tr>
<tr>
<td>异常类</td>
<td>Exception结尾</td>
<td>RuntimeException</td>
</tr>
<tr>
<td>接口实现类</td>
<td>接口名+ Impl</td>
<td>UserServiceImpl</td>
</tr>
<tr>
<td>领域模型相关</td>
<td>/DO/DTO/VO/DAO</td>
<td>正例：UserDAO 反例： UserDo， UserDao</td>
</tr>
<tr>
<td>设计模式相关类</td>
<td>Builder，Factory等</td>
<td>当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory</td>
</tr>
<tr>
<td>处理特定功能的</td>
<td>Handler，Predicate, Validator</td>
<td>表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate</td>
</tr>
<tr>
<td>测试类</td>
<td>Test结尾</td>
<td>UserServiceTest， 表示用来测试UserService类的</td>
</tr>
<tr>
<td>MVC分层</td>
<td>Controller，Service，ServiceImpl，DAO后缀</td>
<td>UserManageController，UserManageDAO</td>
</tr>
</tbody>
</table>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。 和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>
<h3 id="返回真伪值的方法"><a href="#返回真伪值的方法" class="headerlink" title="返回真伪值的方法"></a>返回真伪值的方法</h3><p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix</td>
<td>is</td>
<td>对象是否符合期待的状态</td>
<td>isValid</td>
</tr>
<tr>
<td>Prefix</td>
<td>can</td>
<td>对象<strong>能否执行</strong>所期待的动作</td>
<td>canRemove</td>
</tr>
<tr>
<td>Prefix</td>
<td>should</td>
<td>调用方执行某个命令或方法是<strong>好还是不好</strong>,<strong>应不应该</strong>，或者说<strong>推荐还是不推荐</strong></td>
<td>shouldMigrate</td>
</tr>
<tr>
<td>Prefix</td>
<td>has</td>
<td>对象<strong>是否持有</strong>所期待的数据和属性</td>
<td>hasObservers</td>
</tr>
<tr>
<td>Prefix</td>
<td>needs</td>
<td>调用方<strong>是否需要</strong>执行某个命令或方法</td>
<td>needsMigrate</td>
</tr>
</tbody>
</table>
<h3 id="用来检查的方法"><a href="#用来检查的方法" class="headerlink" title="用来检查的方法"></a>用来检查的方法</h3><table>
<thead>
<tr>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>ensure</td>
<td>检查是否为期待的状态，不是则抛出异常或返回error code</td>
<td>ensureCapacity</td>
</tr>
<tr>
<td>validate</td>
<td>检查是否为正确的状态，不是则抛出异常或返回error code</td>
<td>validateInputs</td>
</tr>
</tbody>
</table>
<h3 id="按需求才执行的方法"><a href="#按需求才执行的方法" class="headerlink" title="按需求才执行的方法"></a>按需求才执行的方法</h3><table>
<thead>
<tr>
<th>位置</th>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Suffix</td>
<td>IfNeeded</td>
<td>需要的时候执行，不需要的时候什么都不做</td>
<td>drawIfNeeded</td>
</tr>
<tr>
<td>Prefix</td>
<td>might</td>
<td>同上</td>
<td>mightCreate</td>
</tr>
<tr>
<td>Prefix</td>
<td>try</td>
<td>尝试执行，失败时抛出异常或是返回errorcode</td>
<td>tryCreate</td>
</tr>
<tr>
<td>Suffix</td>
<td>OrDefault</td>
<td>尝试执行，失败时返回默认值</td>
<td>getOrDefault</td>
</tr>
<tr>
<td>Suffix</td>
<td>OrElse</td>
<td>尝试执行、失败时返回实际参数中指定的值</td>
<td>getOrElse</td>
</tr>
<tr>
<td>Prefix</td>
<td>force</td>
<td>强制尝试执行。error抛出异常或是返回值</td>
<td>forceCreate, forceStop</td>
</tr>
</tbody>
</table>
<h3 id="异步相关方法"><a href="#异步相关方法" class="headerlink" title="异步相关方法"></a>异步相关方法</h3><table>
<thead>
<tr>
<th>位置</th>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix</td>
<td>blocking</td>
<td>线程阻塞方法</td>
<td>blockingGetUser</td>
</tr>
<tr>
<td>Suffix</td>
<td>InBackground</td>
<td>执行在后台的线程</td>
<td>doInBackground</td>
</tr>
<tr>
<td>Suffix</td>
<td>Async</td>
<td>异步方法</td>
<td>sendAsync</td>
</tr>
<tr>
<td>Suffix</td>
<td>Sync</td>
<td>对应已有异步方法的同步方法</td>
<td>sendSync</td>
</tr>
<tr>
<td>Prefix or Alone</td>
<td>schedule</td>
<td>Job和Task放入队列</td>
<td>schedule, scheduleJob</td>
</tr>
<tr>
<td>Prefix or Alone</td>
<td>post</td>
<td>同上</td>
<td>postJob</td>
</tr>
<tr>
<td>Prefix or Alone</td>
<td>execute</td>
<td>执行异步方法（注：我一般拿这个做同步方法名）</td>
<td>execute, executeTask</td>
</tr>
<tr>
<td>Prefix or Alone</td>
<td>start</td>
<td>同上</td>
<td>start, startJob</td>
</tr>
<tr>
<td>Prefix or Alone</td>
<td>cancel</td>
<td>停止异步方法</td>
<td>cancel, cancelJob</td>
</tr>
<tr>
<td>Prefix or Alone</td>
<td>stop</td>
<td>同上</td>
<td>stop, stopJob</td>
</tr>
</tbody>
</table>
<h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><table>
<thead>
<tr>
<th>位置</th>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix</td>
<td>on</td>
<td>事件发生时执行</td>
<td>onCompleted</td>
</tr>
<tr>
<td>Prefix</td>
<td>before</td>
<td>事件发生前执行</td>
<td>beforeUpdate</td>
</tr>
<tr>
<td>Prefix</td>
<td>pre</td>
<td>同上</td>
<td>preUpdate</td>
</tr>
<tr>
<td>Prefix</td>
<td>will</td>
<td>同上</td>
<td>willUpdate</td>
</tr>
<tr>
<td>Prefix</td>
<td>after</td>
<td>事件发生后执行</td>
<td>afterUpdate</td>
</tr>
<tr>
<td>Prefix</td>
<td>post</td>
<td>同上</td>
<td>postUpdate</td>
</tr>
<tr>
<td>Prefix</td>
<td>did</td>
<td>同上</td>
<td>didUpdate</td>
</tr>
<tr>
<td>Prefix</td>
<td>should</td>
<td>确认事件是否可以发生时执行</td>
<td>shouldUpdate</td>
</tr>
</tbody>
</table>
<h3 id="操作对象生命周期的方法"><a href="#操作对象生命周期的方法" class="headerlink" title="操作对象生命周期的方法"></a>操作对象生命周期的方法</h3><table>
<thead>
<tr>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialize</td>
<td>初始化。也可作为延迟初始化使用</td>
<td>initialize</td>
</tr>
<tr>
<td>pause</td>
<td>暂停</td>
<td>onPause ，pause</td>
</tr>
<tr>
<td>stop</td>
<td>停止</td>
<td>onStop，stop</td>
</tr>
<tr>
<td>abandon</td>
<td>销毁的替代</td>
<td>abandon</td>
</tr>
<tr>
<td>destroy</td>
<td>同上</td>
<td>destroy</td>
</tr>
<tr>
<td>dispose</td>
<td>同上</td>
<td>dispose</td>
</tr>
</tbody>
</table>
<h3 id="与集合操作相关的方法"><a href="#与集合操作相关的方法" class="headerlink" title="与集合操作相关的方法"></a>与集合操作相关的方法</h3><table>
<thead>
<tr>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>contains</td>
<td>是否持有与指定对象相同的对象</td>
<td>contains</td>
</tr>
<tr>
<td>add</td>
<td>添加</td>
<td>addJob</td>
</tr>
<tr>
<td>append</td>
<td>添加</td>
<td>appendJob</td>
</tr>
<tr>
<td>insert</td>
<td>插入到下标n</td>
<td>insertJob</td>
</tr>
<tr>
<td>put</td>
<td>添加与key对应的元素</td>
<td>putJob</td>
</tr>
<tr>
<td>remove</td>
<td>移除元素</td>
<td>removeJob</td>
</tr>
<tr>
<td>enqueue</td>
<td>添加到队列的最末位</td>
<td>enqueueJob</td>
</tr>
<tr>
<td>dequeue</td>
<td>从队列中头部取出并移除</td>
<td>dequeueJob</td>
</tr>
<tr>
<td>push</td>
<td>添加到栈头</td>
<td>pushJob</td>
</tr>
<tr>
<td>pop</td>
<td>从栈头取出并移除</td>
<td>popJob</td>
</tr>
<tr>
<td>peek</td>
<td>从栈头取出但不移除</td>
<td>peekJob</td>
</tr>
<tr>
<td>find</td>
<td>寻找符合条件的某物</td>
<td>findById</td>
</tr>
</tbody>
</table>
<h3 id="与数据相关的方法"><a href="#与数据相关的方法" class="headerlink" title="与数据相关的方法"></a>与数据相关的方法</h3><table>
<thead>
<tr>
<th>单词</th>
<th>意义</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>新创建</td>
<td>createAccount</td>
</tr>
<tr>
<td>new</td>
<td>新创建</td>
<td>newAccount</td>
</tr>
<tr>
<td>from</td>
<td>从既有的某物新建，或是从其他的数据新建</td>
<td>fromConfig</td>
</tr>
<tr>
<td>to</td>
<td>转换</td>
<td>toString</td>
</tr>
<tr>
<td>update</td>
<td>更新既有某物</td>
<td>updateAccount</td>
</tr>
<tr>
<td>load</td>
<td>读取</td>
<td>loadAccount</td>
</tr>
<tr>
<td>fetch</td>
<td>远程读取</td>
<td>fetchAccount</td>
</tr>
<tr>
<td>delete</td>
<td>删除</td>
<td>deleteAccount</td>
</tr>
<tr>
<td>remove</td>
<td>删除</td>
<td>removeAccount</td>
</tr>
<tr>
<td>save</td>
<td>保存</td>
<td>saveAccount</td>
</tr>
<tr>
<td>store</td>
<td>保存</td>
<td>storeAccount</td>
</tr>
<tr>
<td>commit</td>
<td>保存</td>
<td>commitChange</td>
</tr>
<tr>
<td>apply</td>
<td>保存或应用</td>
<td>applyChange</td>
</tr>
<tr>
<td>clear</td>
<td>清除数据或是恢复到初始状态</td>
<td>clearAll</td>
</tr>
<tr>
<td>reset</td>
<td>清除数据或是恢复到初始状态</td>
<td>resetAll</td>
</tr>
</tbody>
</table>
<h3 id="成对出现的动词"><a href="#成对出现的动词" class="headerlink" title="成对出现的动词"></a>成对出现的动词</h3><table>
<thead>
<tr>
<th>单词</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>get获取</td>
<td>set 设置</td>
</tr>
<tr>
<td>add 增加</td>
<td>remove 删除</td>
</tr>
<tr>
<td>create 创建</td>
<td>destory 移除</td>
</tr>
<tr>
<td>start 启动</td>
<td>stop 停止</td>
</tr>
<tr>
<td>open 打开</td>
<td>close 关闭</td>
</tr>
<tr>
<td>read 读取</td>
<td>write 写入</td>
</tr>
<tr>
<td>load 载入</td>
<td>save 保存</td>
</tr>
<tr>
<td>create 创建</td>
<td>destroy 销毁</td>
</tr>
<tr>
<td>begin 开始</td>
<td>end 结束</td>
</tr>
<tr>
<td>backup 备份</td>
<td>restore 恢复</td>
</tr>
<tr>
<td>import 导入</td>
<td>export 导出</td>
</tr>
<tr>
<td>split 分割</td>
<td>merge 合并</td>
</tr>
<tr>
<td>inject 注入</td>
<td>extract 提取</td>
</tr>
<tr>
<td>attach 附着</td>
<td>detach 脱离</td>
</tr>
<tr>
<td>bind 绑定</td>
<td>separate 分离</td>
</tr>
<tr>
<td>view 查看</td>
<td>browse 浏览</td>
</tr>
<tr>
<td>edit 编辑</td>
<td>modify 修改</td>
</tr>
<tr>
<td>select 选取</td>
<td>mark 标记</td>
</tr>
<tr>
<td>copy 复制</td>
<td>paste 粘贴</td>
</tr>
<tr>
<td>undo 撤销</td>
<td>redo 重做</td>
</tr>
<tr>
<td>insert 插入</td>
<td>delete 移除</td>
</tr>
<tr>
<td>add 加入</td>
<td>append 添加</td>
</tr>
<tr>
<td>clean 清理</td>
<td>clear 清除</td>
</tr>
<tr>
<td>index 索引</td>
<td>sort 排序</td>
</tr>
<tr>
<td>find 查找</td>
<td>search 搜索</td>
</tr>
<tr>
<td>increase 增加</td>
<td>decrease 减少</td>
</tr>
<tr>
<td>play 播放</td>
<td>pause 暂停</td>
</tr>
<tr>
<td>launch 启动</td>
<td>run 运行</td>
</tr>
<tr>
<td>compile 编译</td>
<td>execute 执行</td>
</tr>
<tr>
<td>debug 调试</td>
<td>trace 跟踪</td>
</tr>
<tr>
<td>observe 观察</td>
<td>listen 监听</td>
</tr>
<tr>
<td>build 构建</td>
<td>publish 发布</td>
</tr>
<tr>
<td>input 输入</td>
<td>output 输出</td>
</tr>
<tr>
<td>encode 编码</td>
<td>decode 解码</td>
</tr>
<tr>
<td>encrypt 加密</td>
<td>decrypt 解密</td>
</tr>
<tr>
<td>compress 压缩</td>
<td>decompress 解压缩</td>
</tr>
<tr>
<td>pack 打包</td>
<td>unpack 解包</td>
</tr>
<tr>
<td>parse 解析</td>
<td>emit 生成</td>
</tr>
<tr>
<td>connect 连接</td>
<td>disconnect 断开</td>
</tr>
<tr>
<td>send 发送</td>
<td>receive 接收</td>
</tr>
<tr>
<td>download 下载</td>
<td>upload 上传</td>
</tr>
<tr>
<td>refresh 刷新</td>
<td>synchronize 同步</td>
</tr>
<tr>
<td>update 更新</td>
<td>revert 复原</td>
</tr>
<tr>
<td>lock 锁定</td>
<td>unlock 解锁</td>
</tr>
<tr>
<td>check out 签出</td>
<td>check in 签入</td>
</tr>
<tr>
<td>submit 提交</td>
<td>commit 交付</td>
</tr>
<tr>
<td>push 推</td>
<td>pull 拉</td>
</tr>
<tr>
<td>expand 展开</td>
<td>collapse 折叠</td>
</tr>
<tr>
<td>begin 起始</td>
<td>end 结束</td>
</tr>
<tr>
<td>start 开始</td>
<td>finish 完成</td>
</tr>
<tr>
<td>enter 进入</td>
<td>exit 退出</td>
</tr>
<tr>
<td>abort 放弃</td>
<td>quit 离开</td>
</tr>
<tr>
<td>obsolete 废弃</td>
<td>depreciate 废旧</td>
</tr>
<tr>
<td>collect 收集</td>
<td>aggregate 聚集</td>
</tr>
</tbody>
</table>
<h2 id="变量-amp-常量命名"><a href="#变量-amp-常量命名" class="headerlink" title="变量&amp;常量命名"></a>变量&amp;常量命名</h2><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。</p>
<p>变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？</p>
<p>常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jann Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-07 00:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(正例)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_MESSAGE_CACHE_EXPIRE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(反例，命名不清晰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MESSAGE_CACHE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_MESSAGE = <span class="string">" error message"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印 &#123;<span class="doctag">@code</span> message&#125; 信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息体，局部常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">final</span> String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量一般都有自己的业务含义,<strong>不要害怕长度过长而进行省略或者缩写</strong>。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。</p>
<h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><ol>
<li>尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。<br>正例： BeiJing， HangZhou<br>反例： validateCanShu</li>
<li>命名过程中尽量不要出现特殊的字符，常量除外。</li>
<li>尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。</li>
<li>妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。<br>如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。</li>
</ol>
<h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><h3 id="注解的原则"><a href="#注解的原则" class="headerlink" title="注解的原则"></a>注解的原则</h3><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p>
<ol>
<li>Nothing is strange<br>没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。</li>
<li>Less is more<br>从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据id获取信息【废话注解】</span></span><br><span class="line">getMessageById(id)</span><br></pre></td></tr></table></figure>
<ol>
<li>Advance with the time<br>注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</li>
</ol>
<h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><p>注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。</p>
<h4 id="包注解"><a href="#包注解" class="headerlink" title="包注解"></a>包注解</h4><p>包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 落地也质量检测</span></span><br><span class="line"><span class="comment"> * 1. 用来解决什么问题</span></span><br><span class="line"><span class="comment"> * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 如何实现</span></span><br><span class="line"><span class="comment"> * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意： 网络环境配置信息&#123;<span class="doctag">@link</span> cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum&#125;目前使用是常规速度，可以根据实际情况进行调整</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cruder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/12/7 20:3 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.mycookies.landingpagecheck;</span><br></pre></td></tr></table></figure>
<h4 id="类注接"><a href="#类注接" class="headerlink" title="类注接"></a>类注接</h4><p>javadoc注解中，每个类都必须有注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright (C), 2019-2020, Jann  balabala...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>   类创建者姓名 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>     创建日期 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>  版本号 保持对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h4><p>在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 提示信息 */</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>
<h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 方法的详细说明，能干嘛，怎么实现的，注意事项...</span><br><span class="line">  *</span><br><span class="line">  * @param xxx   参数1的使用说明， 能否为null</span><br><span class="line">  * @return 返回结果的说明， 不同情况下会返回怎样的结果</span><br><span class="line">  * @throws 异常类型   注明从此类方法中抛出异常的说明</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>
<h4 id="构造方法注释"><a href="#构造方法注释" class="headerlink" title="构造方法注释"></a>构造方法注释</h4><p>在每个构造方法前面必须加上注释，注释模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 构造方法的详细说明</span><br><span class="line">  *</span><br><span class="line">  * @param xxx   参数1的使用说明， 能否为null</span><br><span class="line">  * @throws 异常类型   注明从此类方法中抛出异常的说明</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>
<p>而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：</p>
<ol>
<li>枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。</li>
<li>保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">1</span>;<span class="comment">// 反例：不要使用行尾注释</span></span><br><span class="line"><span class="comment">//反例：换行符与注释之间没有缩进</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 正例：姓名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 多行注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 对于不同的逻辑说明，可以用空行分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是命名和注解，他们的目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意，注解往往是对命名的补充和完善。命名太南了！<br>参考文献：</p>
<p>《码出高效》</p>
<p><a href="https://www.cnblogs.com/wangcp-2014/p/10215620.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangcp-2014/p/10215620.html</a></p>
<p><a href="https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6" target="_blank" rel="noopener">https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6</a></p>
<p><a href="https://google.github.io/styleguide/javaguide.html#s2.1-file-name" target="_blank" rel="noopener">https://google.github.io/styleguide/javaguide.html#s2.1-file-name</a></p>
<p>作者： 浪人~</p>
<p>原文链接：<a href="https://www.cnblogs.com/liqiangchn/p/12000361.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiangchn/p/12000361.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴为什么不用ZooKeeper做服务发现？</title>
    <url>/posts/42539/</url>
    <content><![CDATA[<h2 id="历史的迷思"><a href="#历史的迷思" class="headerlink" title="历史的迷思"></a>历史的迷思</h2><p>站在未来的路口，回望历史的迷途，常常会很有意思，因为我们会不经意地兴起疯狂的念头，例如如果当年某事提前发生了，而另外一件事又没有发生会怎样？一如当年的奥匈帝国皇位继承人斐迪南大公夫妇如果没有被塞尔维亚族热血青年普林西普枪杀会怎样，又如若当年的丘老道没有经过牛家村会怎样？</p>
<p>2007年底，淘宝开启一个叫做“五彩石”的内部重构项目，这个项目后来成为了淘宝服务化、面向分布式走自研之路，走出了互联网中间件体系之始，而淘宝服务注册中心ConfigServer于同年诞生。</p>
<p>2008年前后，Yahoo 这个曾经的互联网巨头开始逐渐在公开场合宣讲自己的大数据分布式协调产品 ZooKeeper，这个产品参考了Google 发表的关于Chubby以及 Paxos 的论文。</p>
<p>2010年11月，ZooKeeper从 Apache Hadoop的子项目发展为 Apache的顶级项目，正式宣告 ZooKeeper成为一个工业级的成熟稳定的产品。</p>
<p>2011年，阿里巴巴开源Dubbo，为了更好开源，需要剥离与阿里内部系统的关系，Dubbo 支持了开源的 ZooKeeper 作为其注册中心，后来在国内，在业界诸君的努力实践下，Dubbo + ZooKeeper 的典型的服务化方案成就了 ZooKeeper 作为注册中心的声名。</p>
<p>2015年双11，ConfigServer 服务内部近8个年头过去了，阿里巴巴内部“服务规模”超几百万 ，以及推进“千里之外”的IDC容灾技术战略等，共同促使阿里巴巴内部开启了 ConfigServer 2.0 到 ConfigServer 3.0 的架构升级之路。</p>
<p>时间走向2018年，站在10年的时间路口上，有多少人愿意在追逐日新月异的新潮技术概念的时候，稍微慢一下脚步，仔细凝视一下服务发现这个领域，有多少人想到过或者思考过一个问题：</p>
<p><strong>服务发现，ZooKeeper 真的是最佳选择么？</strong></p>
<p><strong>而回望历史，我们也偶有迷思，在服务发现这个场景下，如果当年 ZooKeeper 的诞生之日比我们 HSF 的注册中心 ConfigServer 早一点会怎样？</strong></p>
<p>我们会不会走向先使用ZooKeeper然后疯狂改造与修补ZooKeeper以适应阿里巴巴的服务化场景与需求的弯路？</p>
<p>但是，站在今天和前人的肩膀上，我们从未如今天这样坚定的认知到，在服务发现领域，ZooKeeper 根本就不能算是最佳的选择，一如这些年一直与我们同行的Eureka以及这篇文章 <a href="https://medium.com/knerd/eureka-why-you-shouldnt-use-zookeeper-for-service-discovery-4932c5c7e764" target="_blank" rel="noopener">Eureka! Why You Shouldn’t Use ZooKeeper for Service Discovery</a> 那坚定的阐述一样，为什么你不应该用 ZooKeeper 做服务发现！</p>
<p>吾道不孤矣。</p>
<a id="more"></a>
<h2 id="注册中心需求分析及关键设计考量"><a href="#注册中心需求分析及关键设计考量" class="headerlink" title="注册中心需求分析及关键设计考量"></a>注册中心需求分析及关键设计考量</h2><p>接下来，让我们回归对服务发现的需求分析，结合阿里巴巴在关键场景上的实践，来一一分析，一起探讨为何说 ZooKeeper 并不是最合适的注册中心解决方案。</p>
<h3 id="注册中心是-CP-还是-AP-系统"><a href="#注册中心是-CP-还是-AP-系统" class="headerlink" title="注册中心是 CP 还是 AP 系统?"></a>注册中心是 CP 还是 AP 系统?</h3><p>CAP 和 BASE 理论相信读者都已经耳熟能详，其业已成了指导分布式系统及互联网应用构建的关键原则之一，在此不再赘述其理论，我们直接进入对注册中心的数据一致性和可用性需求的分析:</p>
<ul>
<li><strong>数据一致性需求分析</strong></li>
</ul>
<p>注册中心最本质的功能可以看成是一个Query函数 <code>Si = F(service-name)</code>，以 <code>service-name</code> 为查询参数，<code>service-name</code> 对应的服务的可用的 <code>endpoints (ip:port)</code> 列表为返回值.</p>
<blockquote>
<p>注: 后文将 service 简写为 svc。</p>
</blockquote>
<p>先来看看关键数据 <code>endpoints (ip:port)</code> 不一致性带来的影响，即 CAP 中的 C 不满足带来的后果 :</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1a8dGqb1YBuNjSszeXXablFXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1a8dGqb1YBuNjSszeXXablFXa" alt></a></p>
<p>如上图所示，如果一个 svcB 部署了10个节点 (副本/Replica），如果对于同一个服务名 svcB, 调用者 svcA 的2个节点的2次查询返回了不一致的数据，例如: S1 = { ip1,ip2,ip3…,ip9 }, S2 = { ip2,ip3,….ip10 }, 那么这次不一致带来的影响是什么？</p>
<p>相信你一定已经看出来了，svcB 的各个节点流量会有一点不均衡。</p>
<p>ip1和ip10相对其它8个节点{ip2…ip9}，请求流量小了一点，但很明显，在分布式系统中，即使是对等部署的服务，因为请求到达的时间，硬件的状态，操作系统的调度，虚拟机的 GC 等，任何一个时间点，这些对等部署的节点状态也不可能完全一致，而流量不一致的情况下，只要注册中心在SLA承诺的时间内（例如1s内）将数据收敛到一致状态（即满足最终一致），流量将很快趋于统计学意义上的一致，所以注册中心以最终一致的模型设计在生产实践中完全可以接受。</p>
<ul>
<li><strong>分区容忍及可用性需求分析</strong></li>
</ul>
<p>接下来我们看一下网络分区（Network Partition）情况下注册中心不可用对服务调用产生的影响，即 CAP 中的A不满足时带来的影响。</p>
<p>考虑一个典型的ZooKeeper三机房容灾5节点部署结构 (即2-2-1结构)，如下图:</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1QyQRqb1YBuNjSszeXXablFXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1QyQRqb1YBuNjSszeXXablFXa" alt></a></p>
<p>当机房3出现网络分区(Network Partitioned)的时候，即机房3在网络上成了孤岛，我们知道虽然整体 ZooKeeper 服务是可用的，但是节点ZK5是不可写的，因为联系不上 Leader。</p>
<p>也就是说，这时候机房3的应用服务 svcB 是不可以新部署，重新启动，扩容或者缩容的，但是站在网络和服务调用的角度看，机房3的 svcA 虽然无法调用机房1和机房2的 svcB,但是与机房3的svcB之间的网络明明是 OK 的啊，为什么不让我调用本机房的服务？</p>
<p>现在因为注册中心自身为了保脑裂(P)下的数据一致性（C）而放弃了可用性，导致了同机房的服务之间出现了无法调用，这是绝对不允许的！<strong>可以说在实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性，这是注册中心设计应该遵循的铁律！</strong> 后面在注册中心客户端灾容上我们还会继续讨论。</p>
<p>同时我们再考虑一下这种情况下的数据不一致性，如果机房1，2，3之间都成了孤岛，那么如果每个机房的svcA都只拿到本机房的 svcB 的ip列表，也即在各机房svcB 的ip列表数据完全不一致，影响是什么？</p>
<p>其实没啥大影响，只是这种情况下，全都变成了同机房调用，我们在设计注册中心的时候，有时候甚至会主动利用这种注册中心的数据可以不一致性，来帮助应用主动做到同机房调用，从而优化服务调用链路 RT 的效果！</p>
<p>通过以上我们的阐述可以看到，在 CAP 的权衡中，注册中心的可用性比数据强一致性更宝贵，所以整体设计更应该偏向 AP，而非 CP，数据不一致在可接受范围，而P下舍弃A却完全违反了注册中心不能因为自身的任何原因破坏服务本身的可连通性的原则。</p>
<h3 id="服务规模、容量、服务联通性"><a href="#服务规模、容量、服务联通性" class="headerlink" title="服务规模、容量、服务联通性"></a>服务规模、容量、服务联通性</h3><p>你所在公司的“微服务”规模有多大？数百微服务？部署了上百个节点？那么3年后呢？互联网是产生奇迹的地方，也许你的“服务”一夜之间就家喻户晓，流量倍增，规模翻番！</p>
<p>当数据中心服务规模超过一定数量 (服务规模=F{服务pub数,服务sub数})，作为注册中心的 ZooKeeper 很快就会像下图的驴子一样不堪重负</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1LvIFhOCYBuNkSnaVXXcMsVXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1LvIFhOCYBuNkSnaVXXcMsVXa" alt></a></p>
<p>其实当ZooKeeper用对地方时，即用在粗粒度分布式锁，分布式协调场景下，ZooKeeper 能支持的tps 和支撑的连接数是足够用的，因为这些场景对于 ZooKeeper 的扩展性和容量诉求不是很强烈。</p>
<p>但在服务发现和健康监测场景下，随着服务规模的增大，无论是应用频繁发布时的服务注册带来的写请求，还是刷毫秒级的服务健康状态带来的写请求，还是恨不能整个数据中心的机器或者容器皆与注册中心有长连接带来的连接压力上，ZooKeeper 很快就会力不从心，而 ZooKeeper 的写并不是可扩展的，不可以通过加节点解决水平扩展性问题。</p>
<p>要想在 ZooKeeper 基础上硬着头皮解决服务规模的增长问题，一个实践中可以考虑的方法是想办法梳理业务，垂直划分业务域，将其划分到多个 ZooKeeper 注册中心，但是作为提供通用服务的平台机构组，因自己提供的服务能力不足要业务按照技术的指挥棒配合划分治理业务，真的可行么？</p>
<p>而且这又违反了因为注册中心自身的原因（能力不足）破坏了服务的可连通性，举个简单的例子，1个搜索业务，1个地图业务，1个大文娱业务，1个游戏业务，他们之间的服务就应该老死不相往来么？也许今天是肯定的，那么明天呢，1年后呢，10年后呢？谁知道未来会要打通几个业务域去做什么奇葩的业务创新？注册中心作为基础服务，无法预料未来的时候当然不能妨碍业务服务对未来固有联通性的需求。</p>
<h3 id="注册中心需要持久存储和事务日志么？"><a href="#注册中心需要持久存储和事务日志么？" class="headerlink" title="注册中心需要持久存储和事务日志么？"></a>注册中心需要持久存储和事务日志么？</h3><p>需要，也不需要。</p>
<p>我们知道 ZooKeeper 的 ZAB 协议对每一个写请求，会在每个ZooKeeper节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，以及宕机之后的数据可恢复，这是非常好的特性，但是我们要问，在服务发现场景中，其最核心的数据-实时的健康的服务的地址列表真的需要数据持久化么？</p>
<p>对于这份数据，答案是否定的。</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB10N.Jqf9TBuNjy1zbXXXpepXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB10N.Jqf9TBuNjy1zbXXXpepXa" alt></a></p>
<p>如上图所示，如果 svcB 经历了注册服务(ip1)到扩容到2个节点（ip1，ip2）到因宕机缩容 (ip1 宕机），这个过程中，产生了3次针对 ZooKeeper 的写操作。</p>
<p>但是仔细分析，通过事务日志，持久化连续记录这个变化过程其实意义不大，因为在服务发现中，服务调用发起方更关注的是其要调用的服务的实时的地址列表和实时健康状态，每次发起调用时，并不关心要调用的服务的历史服务地址列表、过去的健康状态。</p>
<p>但是为什么又说需要呢，因为一个完整的生产可用的注册中心，除了服务的实时地址列表以及实时的健康状态之外，还会存储一些服务的元数据信息，例如服务的版本，分组，所在的数据中心，权重，鉴权策略信息，service label等元信息，这些数据需要持久化存储，并且注册中心应该提供对这些元信息的检索的能力。</p>
<h3 id="Service-Health-Check"><a href="#Service-Health-Check" class="headerlink" title="Service Health Check"></a>Service Health Check</h3><p>使用 ZooKeeper 作为服务注册中心时，服务的健康检测常利用 ZooKeeper 的 Session 活性 Track机制 以及结合 Ephemeral ZNode的机制，简单而言，就是将服务的健康监测绑定在了 ZooKeeper 对于 Session 的健康监测上，或者说绑定在TCP长链接活性探测上了。</p>
<p>这在很多时候也会造成致命的问题，ZK 与服务提供者机器之间的TCP长链接活性探测正常的时候，该服务就是健康的么？答案当然是否定的！注册中心应该提供更丰富的健康监测方案，服务的健康与否的逻辑应该开放给服务提供方自己定义，而不是一刀切搞成了 TCP 活性检测！</p>
<p>健康检测的一大基本设计原则就是尽可能真实的反馈服务本身的真实健康状态，否则一个不敢被服务调用者相信的健康状态判定结果还不如没有健康检测。</p>
<h3 id="注册中心的容灾考虑"><a href="#注册中心的容灾考虑" class="headerlink" title="注册中心的容灾考虑"></a><a href="#注册中心的容灾考虑" title="注册中心的容灾考虑"></a>注册中心的容灾考虑</h3><p>前文提过，<strong>在实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性</strong>，那么在可用性上，一个本质的问题，如果注册中心（Registry）本身完全宕机了，svcA 调用 svcB链路应该受到影响么？</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1RAP6qXGWBuNjy0FbXXb4sXXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1RAP6qXGWBuNjy0FbXXb4sXXa" alt></a></p>
<p>是的，不应该受到影响。</p>
<p>服务调用（请求响应流）链路应该是弱依赖注册中心，必须仅在服务发布，机器上下线，服务扩缩容等必要时才依赖注册中心。</p>
<p>这需要注册中心仔细的设计自己提供的客户端，客户端中应该有针对注册中心服务完全不可用时做容灾的手段，例如设计客户端缓存数据机制（我们称之为 client snapshot）就是行之有效的手段。另外，注册中心的 health check 机制也要仔细设计以便在这种情况不会出现诸如推空等情况的出现。</p>
<p>ZooKeeper的原生客户端并没有这种能力，所以利用 ZooKeeper 实现注册中心的时候我们一定要问自己，如果把 ZooKeeper 所有节点全干掉，你生产上的所有服务调用链路能不受任何影响么？而且应该定期就这一点做故障演练。</p>
<h3 id="你有没有ZooKeeper的专家可依靠？"><a href="#你有没有ZooKeeper的专家可依靠？" class="headerlink" title="你有没有ZooKeeper的专家可依靠？"></a><a href="#你有没有ZooKeeper的专家可依靠？" title="你有没有ZooKeeper的专家可依靠？"></a>你有没有ZooKeeper的专家可依靠？</h3><p>ZooKeeper 看似很简单的一个产品，但在生产上大规模使用并且用好，并不是那么理所当然的事情。如果你决定在生产中引入 ZooKeeper，你最好做好随时向 ZooKeeper 技术专家寻求帮助的心理预期，最典型的表现是在两个方面:</p>
<ul>
<li><strong>难以掌握的Client/Session状态机</strong></li>
</ul>
<p>ZooKeeper 的原生客户端绝对称不上好用，Curator 会好一点，但其实也好的有限，要完全理解 ZooKeeper 客户端与 Server 之间的交互协议也并不简单，完全理解并掌握 ZooKeeper Client/Session 的状态机（下图）也并不是那么简单明了:</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1gBwkqb1YBuNjSszeXXablFXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1gBwkqb1YBuNjSszeXXablFXa" alt></a></p>
<p>但基于 ZooKeeper 的服务发现方案却是依赖 ZooKeeper 提供的长连接/Session管理，Ephemeral ZNode，Event&amp;Notification, ping 机制上，所以要用好ZooKeeper 做服务发现，恰恰要理解这些 ZooKeeper 核心的机制原理，这有时候会让你陷入暴躁，我只是想要个服务发现而已，怎么要知道这么多？而如果这些你都理解了并且不踩坑，恭喜你，你已经成为ZooKeeper的技术专家了。</p>
<ul>
<li>难以承受的异常处理</li>
</ul>
<p>我们在阿里巴巴内部应用接入 ZooKeeper 时，有一个《ZooKeeper 应用接入必知必会》的 WIKI，其中关于异常处理有过如下的论述:</p>
<blockquote>
<p>如果说要选出应用开发者在使用ZooKeeper的过程中，最需要了解清楚的事情？那么根据我们之前的支持经验，一定是异常处理。</p>
<p>当所有一切（宿主机，磁盘，网络等等）都很幸运的正常工作的时候，应用与ZooKeeper可能也会运行的很好，但不幸的是，我们整天会面对各种意外，而且这遵循墨菲定律，意料之外的坏事情总是在你最担心的时候发生。</p>
<p>所以务必仔细了解 ZooKeeper 在一些场景下会出现的异常和错误，确保您正确的理解了这些异常和错误，以及知道您的应用如何正确的处理这些情况。</p>
<ul>
<li>ConnectionLossException 和 Disconnected 事件</li>
</ul>
</blockquote>
<blockquote>
<p>简单来说，这是个可以在同一个 ZooKeeper Session 恢复的异常(Recoverable), 但是应用开发者需要负责将应用恢复到正确的状态。</p>
<p>发生这个异常的原因有很多，例如应用机器与ZooKeeper节点之间网络闪断，ZooKeeper节点宕机，服务端Full GC时间超长，甚至你的应用进程Hang死，应用进程 Full GC 时间超长之后恢复都有可能。</p>
<p>要理解这个异常，需要了解分布式应用中的一个典型的问题，如下图：<br><a href="https://img.alicdn.com/5476e8b07b923/TB1inZ6qf1TBuNjy0FjXXajyXXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1inZ6qf1TBuNjy0FjXXajyXXa" alt></a></p>
</blockquote>
<blockquote>
<p>在一个典型的客户端请求、服务端响应中，当它们之间的长连接闪断的时候，客户端感知到这个闪断事件的时候，会处在一个比较尴尬的境地，那就是无法确定该事件发生时附近的那个请求到底处在什么状态，Server端到底收到这个请求了么？已经处理了么？因为无法确定这一点，所以当客户端重新连接上Server之后，这个请求是否应该重试（Retry）就也要打一个问号。</p>
</blockquote>
<blockquote>
<p>所以在处理连接断开事件中，应用开发者必须清楚处于闪断附近的那个请求是什么（这常常难以判断），该请求是否是幂等的，对于业务请求在Server端服务处理上对于”仅处理一次” “最多处理一次” “最少处理一次”语义要有选择和预期。</p>
</blockquote>
<blockquote>
<p>举个例子，如果应用在收到 ConnectionLossException 时，之前的请求是Create操作，那么应用的catch到这个异常，应用一个可能的恢复逻辑就是，判断之前请求创建的节点的是否已经存在了，如果存在就不要再创建了，否则就创建。</p>
</blockquote>
<blockquote>
<p>再比如，如果应用使用了exists Watch 去监听一个不存在的节点的创建的事件，那么在ConnectionLossException的期间，有可能遇到的情况是，在这个闪断期间，其它的客户端进程可能已经创建了节点，并且又已经删除了，那么对于当前应用来说，就miss了一次关心的节点的创建事件，这种miss对应用的影响是什么？是可以忍受的还是不可接受？需要应用开发者自己根据业务语义去评估和处理。</p>
</blockquote>
<blockquote>
<ul>
<li>SessionExpiredException 和 SessionExpired 事件</li>
</ul>
</blockquote>
<blockquote>
<p>Session 超时是一个不可恢复的异常，这是指应用Catch到这个异常的时候，应用不可能在同一个Session中恢复应用状态，必须要重新建立新Session，老Session关联的临时节点也可能已经失效，拥有的锁可能已经失效。<br>…</p>
</blockquote>
<p>我们阿里巴巴的小伙伴在自行尝试使用 ZooKeeper 做服务发现的过程中，曾经在我们的内网技术论坛上总结过一篇自己踩坑的经验分享</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1Z2O8h5CYBuNkSnaVXXcMsVXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1Z2O8h5CYBuNkSnaVXXcMsVXa" alt></a></p>
<p>在该文中中肯的提到:</p>
<blockquote>
<p>… 在编码过程中发现很多可能存在的陷阱，毛估估，第一次使用zk来实现集群管理的人应该有80%以上会掉坑，有些坑比较隐蔽，在网络问题或者异常的场景时才会出现，可能很长一段时间才会暴露出来 …</p>
</blockquote>
<p>这篇文章已经分享到云栖社区,你可以点击<a href="https://yq.aliyun.com/articles/227260" target="_blank" rel="noopener"><strong>这里</strong></a>详细阅读。</p>
<h2 id="向左走，向右走"><a href="#向左走，向右走" class="headerlink" title="向左走，向右走"></a>向左走，向右走</h2><p>阿里巴巴是不是完全没有使用 ZooKeeper？并不是。</p>
<p>熟悉阿里巴巴技术体系的都知道，其实阿里巴巴维护了目前国内最大规模的ZooKeeper集群，整体规模有近千台的ZooKeeper服务节点。</p>
<p>同时阿里巴巴中间件内部也维护了一个面向大规模生产的、高可用、更易监控和运维的ZooKeeper的代码分支TaoKeeper，如果以我们近10年在各个业务线和生产上使用ZooKeeper的实践，给ZooKeeper 用一个短语评价的话，那么我们认为ZooKeeper应该是 “The King Of Coordination for Big Data”！</p>
<p><a href="https://img.alicdn.com/5476e8b07b923/TB1CTniqb9YBuNjy0FgXXcxcXXa" target="_blank" rel="noopener"><img src="https://img.alicdn.com/5476e8b07b923/TB1CTniqb9YBuNjy0FgXXcxcXXa" alt></a></p>
<p>在粗粒度分布式锁，分布式选主，主备高可用切换等不需要高TPS 支持的场景下有不可替代的作用，而这些需求往往多集中在大数据、离线任务等相关的业务领域，因为大数据领域，讲究分割数据集，并且大部分时间分任务多进程/线程并行处理这些数据集，但是总是有一些点上需要将这些任务和进程统一协调，这时候就是 ZooKeeper 发挥巨大作用的用武之地。</p>
<p>但是在交易场景交易链路上，在主业务数据存取，大规模服务发现、大规模健康监测等方面有天然的短板，应该竭力避免在这些场景下引入 ZooKeeper，在阿里巴巴的生产实践中，应用对ZooKeeper申请使用的时候要进行严格的场景、容量、SLA需求的评估。</p>
<p>所以可以使用 ZooKeeper，但是大数据请向左，而交易则向右，分布式协调向左，服务发现向右。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>感谢你耐心的阅读到这里，至此，我相信你已经理解，我们写这篇文章并不是全盘否定 ZooKeeper，而只是根据我们阿里巴巴在近10年来在大规模服务化上的生产实践，对我们在服务发现和注册中心设计及使用上的经验教训进行一个总结，希望对业界就如何更好的使用 ZooKeeper，如何更好的设计自己的服务注册中心有所启发和帮助。</p>
<p>最后，条条大路通罗马，衷心祝愿你的注册中心直接就诞生在罗马。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a><a href="#References" title="References"></a>References</h2><ul>
<li><a href="https://medium.com/knerd/eureka-why-you-shouldnt-use-zookeeper-for-service-discovery-4932c5c7e764" target="_blank" rel="noopener">https://medium.com/knerd/eureka-why-you-shouldnt-use-zookeeper-for-service-discovery-4932c5c7e764</a></li>
<li><a href="https://yq.aliyun.com/articles/227260" target="_blank" rel="noopener">https://yq.aliyun.com/articles/227260</a></li>
</ul>
<blockquote>
<p>企业级互联网架构Aliware，让您的业务能力云化：<a href="https://www.aliyun.com/aliware" target="_blank" rel="noopener">https://www.aliyun.com/aliware</a></p>
</blockquote>
<p>作者：中间件小哥</p>
<p>原文链接：<a href="http://jm.taobao.org/2018/06/13/做服务发现？/" target="_blank" rel="noopener">http://jm.taobao.org/2018/06/13/做服务发现？/</a></p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 060 Permutation Sequence</title>
    <url>/posts/26693/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>Given n and k, return the kth permutation sequence.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>Given n will be between 1 and 9 inclusive.</p>
</li>
<li><p>Given k will be between 1 and n! inclusive.</p>
</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 3, k = 3</span><br><span class="line">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 4, k = 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定数字n和k，返回1到n的全排列中第k个结果。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>若n=4，则有{1,2,3,4}，此时列出其全排列顺序如下：</p>
<p>1 + {2,3,4}的全排列<br>2 + {1,3,4}的全排列<br>3 + {1,2,4}的全排列<br>4 + {1,2,3}的全排列  </p>
<p>对第一位来说后面三个数字排列组合有3!即6种，所以当k=9换算成下标为8，肯定在上述第二组种，第一个数字的下标为8/6=1即数字2。在确定了第一位为2的情况下，剩余组合为{1,3,4}，k更新为8%6=2。找后面数字的方式和第一位一样。</p>
<p>对第二位来说后面两个数字排列组合有2!即2种，第二个数字的下标为2/2=1即数字3。在确定了第二位为3的情况下，剩余组合为{1,4}，k更新为2%2=0。</p>
<p>因为k已经为0，则后面的数字为其组合的升序即{1,4}。所以最终结果为2314。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span>[] fn = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        fn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fn[i] = fn[i-<span class="number">1</span>]*i;</span><br><span class="line">            nums.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = k/fn[i-<span class="number">1</span>];</span><br><span class="line">            k = k%fn[i-<span class="number">1</span>];</span><br><span class="line">            res+=nums.get(j);</span><br><span class="line">            nums.remove(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 059 Spiral Matrix II</title>
    <url>/posts/5021/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定正整数n，生成一个正方形矩阵，用从1到n的平方以螺旋到方式进行填充。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>注意上右下左四条边up、right、down、left。</p>
<p>1、在上边up上，从左向右即left到right开始填充，结束后up向下移，并判断若up大于down则退出<br>2、在右边right上，从上向下即up到down开始填充，结束后right向左移，并判断若right小于left则退出<br>3、在下边down上，从右向左即right到left开始填充，结束后down向上移，并判断若down小于up则退出<br>4、在左边left上，从下向上即down到up开始填充，结束后left向右移，并判断若left大于right则退出</p>
<p>继续循环，直至满足退出条件，此时所以元素都已经按照螺旋到方式填充完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> up=<span class="number">0</span>, down=n-<span class="number">1</span>, left=<span class="number">0</span>, right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) res[up][i]=num++;</span><br><span class="line">            <span class="keyword">if</span>(++up&gt;down) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=up;i&lt;=down;i++) res[i][right]=num++;</span><br><span class="line">            <span class="keyword">if</span>(--right&lt;left) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--) res[down][i]=num++;</span><br><span class="line">            <span class="keyword">if</span>(--down&lt;up) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=down;i&gt;=up;i--) res[i][left]=num++;</span><br><span class="line">            <span class="keyword">if</span>(++left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)。</p>
<p><strong>空间复杂度:</strong> O(n2)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 058 Length of Last Word</title>
    <url>/posts/34918/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串包含大小写字母和空格，返回最后一个单词的长度。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>把字符串转成字符数组，start为当前单词的起始位置初始为0，len为当前遍历最后一个单词的长度。</p>
<p>遍历字符数组，若遇到位置i的字符为空格且其前一个字符不为空格，说明上个单词结束，len为i-start，start更新为i+1。</p>
<p>若位置i的字符为空格但其前一个字符也为空格，说明最后一个单词没有发生变化，只更新start为i+1。</p>
<p>最后一个单词理论上len为字符串的长度s.length()-start，但要考虑若最后一个字符是空格的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i-<span class="number">1</span>&gt;=<span class="number">0</span>)&amp;&amp;s.charAt[i-<span class="number">1</span>]!=<span class="string">' '</span>) len = i-start;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length()-start==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()-start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>先对字符串进行预处理，将开头和结尾对空格都去掉。</p>
<p>遍历剩余都字符串，用计数器res去累计当前单词都长度，若遇到空格res重置为0，否则res+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=s.length()-<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;s.charAt(left)==<span class="string">' '</span>) left++;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;s.charAt(right)==<span class="string">' '</span>) right--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">                res=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>遍历字符串，如果当前字符为非空字符，并且前一个字符为空则说明是新单词，单词长度res置为1，否则res++。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=<span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; s.charAt(i-<span class="number">1</span>)==<span class="string">' '</span>)&#123;</span><br><span class="line">                    res=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>由于只关心最后一个单词，先将末尾空格去掉，从后往前遍历，找到非空格字符都长度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=s.length()-<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=<span class="number">0</span>&amp;&amp;s.charAt(right)==<span class="string">' '</span>) right--;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=<span class="number">0</span>&amp;&amp;s.charAt(right)!=<span class="string">' '</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 057 Insert Interval</title>
    <url>/posts/25158/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一系列非重叠对区间，然后插入一个新区间，若和原有区间重叠，则要进行合并操作。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>用变量cur来遍历所有区间，若当前区间cur的end比要插入区间的start小，说明没有重叠，直接将当前区间存入结果集。<br>直到cur到达末尾或者第一次遇到重叠，则退出上述循环。</p>
<p>新进行循环，条件是当前区间cur的start要小于等于要插入区间的end，说明有重叠，那么更新新插入区间的start和end作为两个区间合并后的区间。<br>直到cur到达末尾或者已经没有重叠，则退出上述循环。</p>
<p>之后将重叠部分合并后的区间即更新后的插入区间放入结果集，并将未遍历的区间也放入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;n &amp;&amp; intervals[cur][<span class="number">1</span>]&lt;newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">            res.add(intervals[cur++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;n &amp;&amp; intervals[cur][<span class="number">0</span>]&lt;=newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = Math.min(intervals[cur][<span class="number">0</span>],newInterval[<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = Math.max(intervals[cur][<span class="number">1</span>],newInterval[<span class="number">1</span>]);</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(newInterval);</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;n)&#123;</span><br><span class="line">            res.add(intervals[cur++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用for循环遍历所有区间，使用count表示合并后的区间插入的位置。</p>
<p>若当前区间的end小于新插入区间的start，说明没有重叠，直接放入结果集并count+1。<br>若当前区间的start大于新插入区间的end，说明也没有重叠，直接放入结果集。<br>其他情况说明有重叠，更新新插入的区间的start和end去代表合并后的区间。</p>
<p>最后将最终合并的区间放入结果集适当的位置，即count所在的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cur = intervals[i];</span><br><span class="line">            <span class="keyword">if</span>(cur[<span class="number">1</span>]&lt;newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">                res.add(cur);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur[<span class="number">0</span>]&gt;newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">                res.add(cur);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>]=Math.min(cur[<span class="number">0</span>],newInterval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>]=Math.max(cur[<span class="number">1</span>],newInterval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(count, newInterval);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>震惊！线上四台机器同一时间全部 OOM，到底发生了什么？</title>
    <url>/posts/12092/</url>
    <content><![CDATA[<h3 id="案发现场"><a href="#案发现场" class="headerlink" title="案发现场"></a>案发现场</h3><p>昨天晚上突然短信收到 APM （即 Application Performance Management 的简称），我们内部自己搭建了这样一套系统来对应用的性能、可靠性进行线上的监控和预警的一种机制）大量告警<br><strong>画外音: 监控是一种非常重要的发现问题的手段，没有的话一定要及时建立哦</strong></p>
<p>紧接着运维打来电话告知线上部署的四台机器全部 OOM (out of memory, 内存不足)，服务全部不可用,赶紧查看问题!</p>
<a id="more"></a>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>首先运维先重启了机器，保证线上服务可用，然后再仔细地看了下线上的日志，确实是因为 OOM 导致服务不可用<br><img src="https://www.markeditor.com/file/get/c368792a9589d699db0cb14ccea6ec2e.png" alt></p>
<p>第一时间想到 dump 当时的内存状态，但由于为了让线上尽快恢复服务，运维重启了机器，导致无法 dump 出事发时的内存。所以我又看了下我们 APM 中对 JVM 的监控图表</p>
<p><strong>画外音： 一种方式不行，尝试另外的角度切入！再次强调，监控非常重要！完善的监控能还原当时的事发现场，方便定位问题。</strong></p>
<p><img src="https://www.markeditor.com/file/get/049e110afa45164bef07b432b4b1fe06.png" alt></p>
<p>不看不知道，一看吓一跳，从 16：00 开始应用中创建的线程居然每时每刻都在上升，一直到 3w 左右，重启后（蓝色箭头），线程也一直在不断增长），正常情况下的线程数是多少呢，600！问题找到了，应该是在下午 16:00 左右发了一段有问题的代码，导致线程一直在创建，且创建的线程一直未消亡!查看发布记录,发现发布记录只有这么一段可疑的代码 diff：在 HttpClient 初始化的时候额外加了一个 <strong>evictExpiredConnections</strong> 配置</p>
<p><img src="https://www.markeditor.com/file/get/a8c589f564f6232ef44d19dded63c419.png" alt></p>
<p>问题定位了，应该是就是这个配置导致的！（线程上升的时间点和发布时间点完全吻合！），于是先把这个新加的配置给干掉上线，上线之后线程数果然恢复正常了。那 <strong>evictExpiredConnections</strong> 做了什么导致线程数每时每刻在上升呢？这个配置又是为了解决什么问题而加上的呢？于是找到了相关同事来了解加这个配置的前因后果</p>
<h3 id="还原事发经过"><a href="#还原事发经过" class="headerlink" title="还原事发经过"></a>还原事发经过</h3><p>最近线上出现不少 <strong>NoHttpResponseException</strong> 的异常，那是什么导致了这个异常呢?</p>
<p>在说这个问题之前我们得先了解一下 http 的 keep-alive 机制。</p>
<p>先看下正常的一个 TCP 连接的生命周期<br><img src="https://www.markeditor.com/file/get/0d25bfbda6edc8c9ca8630e154ddee32.png" alt></p>
<p>可以看到每个 TCP 连接都要经过<strong>三次握手</strong>建立连接后才能发送数据，要经过<strong>四次挥手</strong>才能断开连接，如果每个 TCP 连接在 server 返回 response 后都立马断开，则发起多个 HTTP 请求就要多次创建断开 TCP, 这在 <strong>Http 请求很多</strong>的情况下无疑是很耗性能的， 如果在 server 返回 response 不立即断开 TCP 链接，而是<strong>复用</strong>这条链接进行下一次的 Http 请求，则无形中省略了很多创建 / 断开 TCP 的开销，性能上无疑会有很大提升。</p>
<p>如下图示，左图是不复用 TCP 发起多个 HTTP 请求的情况，右图是复用 TCP 的情况，可以看到发起三次 HTTP 请求，复用 TCP 的话可以省去两次建立 / 断开 TCP 的开销，理论上发起 一个应用只要启一个 TCP 连接即可，其他 HTTP 请求都可以复用这个 TCP 连接，这样 n 次 HTTP 请求可以省去 n-1 次创建 / 断开 TCP 的开销。这对性能的提升无疑是有巨大的帮助。</p>
<p><img src="https://www.markeditor.com/file/get/1970dcdc8d61a37eb1bd7311b2a3bcae.png" alt></p>
<p>回过头来看 keep-alive （又称持久连接，连接复用）做的就是复用连接， 保证连接持久有效。<br>画中音: Http 1.1 之后 keep-alive 才默认支持并开启，不过目前大部分网站都用了 http 1.1 了，也就是说大部分都默认支持链接复用了</p>
<p><strong>天下没有免费的午餐</strong> ,虽然 keep-alive 省去了很多不必要的握手/挥手操作，但由于连接长期保活，如果一直没有 http 请求的话，这条连接也就长期闲着了，会占用系统资源,有时反而会比复用连接带来更大的性能消耗。 所以我们一般会为 keep-alive 设置一个 timeout, 这样如果连接在设置的 timeout 时间内一直处于空闲状态（未发生任何数据传输），经过 timeout 时间后，连接就会释放，就能节省系统开销。</p>
<p>看起来给 keep-alive 加 timeout 是完美了，但是又引入了新的问题（一波已平，一波又起!）,考虑如下情况:</p>
<p>如果服务端关闭连接，发送 FIN 包（注：在设置的 timeout 时间内服务端如果一直未收到客户端的请求，服务端会主动发起带 Fin 标志的请求以断开连接释放资源），在这个 FIN 包发送但是还未到达客户端期间，客户端如果继续复用这个 TCP 连接发送 HTTP 请求报文的话，服务端会因为在四次挥手期间不接收报文而发送 RST 报文给客户端，客户端收到 RST 报文就会提示异常 (即 <strong>NoHttpResponseException</strong>)</p>
<p>我们再用流程图仔细梳理一下上述这种产生 <strong>NoHttpResponseException</strong> 的原因,这样能看得更明白一些</p>
<p><img src="https://www.markeditor.com/file/get/1fe2358540883a03ba3c900efed13eef.png" alt></p>
<p>费了这么大的功夫，我们终于知道了产生 ** <strong>NoHttpResponseException</strong>** 的原因，那该怎么解决呢，有两种策略</p>
<ol>
<li>重试，收到异常后，重试一两次，由于重试后客户端会用有效的连接去请求，所以可以避免这种情况，不过一次要注意重试次数，避免引起雪崩!</li>
<li>设置一个定时线程，定时清理上述的闲置连接,可以将这个定时时间设置为 keep alive timeout 时间的一半以保证超时前回收。</li>
</ol>
<p><strong>evictExpiredConnections</strong> 就是用的上述第二种策略，来看下官方用法使用说明</p>
<pre><code>Makes this instance of HttpClient proactively evict idle connections from the
connection pool using a background thread.
</code></pre><p>调用这个方法只会产生一个定时线程，那为啥应用中线程会一直增加呢,因为我们对每一个请求都创建了一个 HttpClient! 这样由于每一个 HttpClient 实例都会调用 <strong>evictExpiredConnections</strong> ,导致有多少请求都会创建多少个 定时线程！</p>
<p>还有一个问题，为啥线上四台机器几乎同一时间点全挂呢？<br>因为由于负载均衡，这四台机器的权重是一样的，硬件配置也一样，收到的请求其实也可以认为是差不多的，这样这四台机器由于创建 HttpClient 而生成的后台线程也在同一时间达到最高点，然后同时 OOM。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>所以针对以上提到的问题，我们首先把 HttpClient 改成了单例，这样保证服务启动后只会有一个定时清理线程，另外我们也让运维针对应用的线程数做了监控，如果超过某个阈值直接告警，这样能在应用 OOM 前及时发现处理。<br><strong>画外音：再次强调，监控相当重要，能把问题扼杀在摇篮里！</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文通过线上四台机器同时 OOM 的现象，来详细剖析产定位了产生问题的原因，可以看到我们在应用某个库时首先要对这个库要有充分的了了解（上述 HttpClient 的创建不用单例显然是个问题），其次必要的网络知识还是需要的，所以要成为一个合格的程序员，不关对语言本身有所了解，还要对网络，数据库等也要有所涉猎，这些对排查问题以及性能调优等会有非常大的帮助，再次，完善的监控非常重要，通过触发某个阈值提前告警，可以将问题扼杀在摇篮里！</p>
<p>作者：ErnestEvan</p>
<p>原文链接：<a href="https://www.cnblogs.com/xiekun/p/12010337.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiekun/p/12010337.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 056 Merge Intervals</title>
    <url>/posts/8023/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一组区间，要求合并所有重叠的区间。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>先将区间进行排序，用每个区间的起始位置进行比较。</p>
<p>将第一个区间存入结果集，循环遍历所有区间。</p>
<p>若当前区间和结果集中最后一个区间有重叠，那么修改最后一个区间的end，其值为两个区间end的最大值。</p>
<p>若无重叠，则直接将当前区间存入结果集，其作为结果集中最后一个区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals==<span class="keyword">null</span>||intervals.length&lt;<span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals,(i1,i2) -&gt; Integer.compare(i1[<span class="number">0</span>],i2[<span class="number">0</span>]));</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] newInterval = intervals[<span class="number">0</span>];</span><br><span class="line">        res.add(newInterval);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(interval[<span class="number">0</span>]&lt;=newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">                newInterval[<span class="number">1</span>]=Math.max(newInterval[<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                newInterval = interval;</span><br><span class="line">                res.add(newInterval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>将每个区间的起始位置和结束位置分别存入数组starts和ends，并分别对其进行排序。</p>
<p>令i，j起始为0，start[i+1]若比前一个位置end[i]大，说明区间不连续，可以直接{start[j],end[i]}添加到结果集。</p>
<p>j为上一个不连续区间的下一个位置。</p>
<p>注意：若区间为[[8,19],[15,18]]，则starts为[8,15]，ends为[19,18]，那么分别排序后starts为[8,15]，ends为[18,19]，对结果没有影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals==<span class="keyword">null</span>||intervals.length&lt;<span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            starts[i]=intervals[i][<span class="number">0</span>];</span><br><span class="line">            ends[i]=intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(starts);</span><br><span class="line">        Arrays.sort(ends);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==intervals.length-<span class="number">1</span>||starts[i+<span class="number">1</span>]&gt;ends[i])&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;starts[j],ends[i]&#125;);</span><br><span class="line">                j=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 055 Jump Game</title>
    <url>/posts/19449/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个非负数组，每个数字表示在当前位置最大能跳跃的跨度，初始位置在第一个位置，求是否能达到最后一个位置。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用动态规划，dp[i]表示是否能从位置i跳到最后的位置，从后往前遍历。</p>
<p>在位置i的时候，其值为n，则依次判断跳1至n的距离j后，下一个位置上dp[i+j]是否为true，若true直接返回表明能跳到最后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dp[n-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=helper(nums,dp,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] dp, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nums[start];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[start+j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>依然使用动态规划，dp[i]表示到达位置i上剩余的跳力。</p>
<p>dp[i]的值取决于前一个位置dp[i-1]的剩余跳力与前一个位置上的本身的跳力，其等于二者最大值减1。</p>
<p>若某时刻dp[i]为负数，则说明无法抵达当前位置，那么也就无法到达末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],nums[i-<span class="number">1</span>])-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(n)。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>贪婪算法，对每个位置的剩余跳力并不关心，只关心目前能到达的最远位置。若能到达末尾，本质上所有的位置都必须可达。</p>
<p>令max=0表示能到达的最远位置，遍历数组中每个元素，若当前坐标大于max则退出。</p>
<p>否则更新max，其值为当前max和i+nums[i]中的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            max = Math.max(max, i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>访问图片出现403的解决办法</title>
    <url>/posts/19298/</url>
    <content><![CDATA[<p><strong>访问图片出现403的解决办法</strong></p>
<p>有时候在页面里用img标签访问页面图片返回403 forbidden，而浏览器可以直接打开。</p>
<p>是因为图片服务器加了防盗链，会检测访问图片的referer。</p>
<p>总结了一下,有两种方法是可以解决这个问题的:</p>
<ul>
<li>使用<code>images.weserv.nl</code>方案</li>
<li>使用<code>no-referrer</code>方案</li>
</ul>
<a id="more"></a>
<h2 id="第一种-使用images-weserv-nl方案"><a href="#第一种-使用images-weserv-nl方案" class="headerlink" title="第一种:使用images.weserv.nl方案"></a>第一种:使用<code>images.weserv.nl</code>方案</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getImage(url)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(url);</span><br><span class="line">    <span class="comment">// 把现在的图片连接传进来，返回一个不受限制的路径</span></span><br><span class="line">    <span class="keyword">if</span>(url !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> url.replace(<span class="regexp">/^(http)[s]*(\:\/\/)/</span>,<span class="string">'https://images.weserv.nl/?url='</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把图片路径直接传进去,替换一下原来<code>url</code>的<code>http/https</code>.或者直接在图片url前加上<code>https://images.weserv.nl/?url=</code><br>如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://images.weserv.nl/?url=http://img.zcool.cn/community/01d881579dc3620000018c1b430c4b.JPG@3000w_1l_2o_100sh.jpg</span><br></pre></td></tr></table></figure>
<p>原图片的<code>http://</code>是可以省略的(与上面的<code>getImage</code>函数是一样的结果)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://images.weserv.nl/?url=mg.zcool.cn/community/01d881579dc3620000018c1b430c4b.JPG@3000w_1l_2o_100sh.jpg</span><br></pre></td></tr></table></figure>
<h2 id="第二种-使用no-referrer方案"><a href="#第二种-使用no-referrer方案" class="headerlink" title="第二种:使用no-referrer方案"></a>第二种:使用<code>no-referrer</code>方案</h2><p>http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。</p>
<p>这种方案不仅针对图片的防盗链,还可以是其他标签。</p>
<p>在前端页面头部添加一个<code>meta</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"no-referrer"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>referrer的几种状态</p>
<p><img src="https://img-blog.csdnimg.cn/2018110514103997.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW50YW5nXzE5ODY=,size_16,color_FFFFFF,t_70" alt></p>
<p>a标签的<code>referrer</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> <span class="attr">referrer</span>=<span class="string">"no-referrer|origin|unsafe-url"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>img/image标签的<code>referrer</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">referrer</span>=<span class="string">"no-referrer|origin|unsafe-url"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item.src&#125;&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">referrer</span>=<span class="string">"no-referrer|origin|unsafe-url"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item.src&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>如果访问gif图片，使用第一种方案是没有gif效果的，只能显示静态图片，这个时候推荐大家使用第二种。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑组装之硬件选择</title>
    <url>/posts/13466/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<blockquote>
<p><strong>目录</strong></p>
<p><a href="#主板">主板</a><br><a href="#Intel芯片组主板">  Intel芯片组主板</a><br><a href="#AMD芯片组主板">  AMD芯片组主板</a><br><a href="#主板尺寸">  主板尺寸</a><br><a href="#关于品牌">  关于品牌</a><br><a href="#CPU">CPU</a><br><a href="#关键参数">  关键参数</a><br><a href="#Intel-CPU后面的数字">  Intel CPU后面的数字</a><br><a href="#Intel-CPU后面的字母">  Intel CPU后面的字母</a><br><a href="#AMD-CPU后面的数字">  AMD CPU后面的数字</a><br><a href="#CPU天梯图">  CPU天梯图</a><br><a href="#CPU的主要厂商">  CPU的主要厂商</a><br><a href="#显卡">显卡 </a><br><a href="#显卡品牌：N卡和A卡">  显卡品牌：N卡和A卡</a><br><a href="#关于品牌">  关于品牌</a><br><a href="#核心显卡、主板集成显卡和独立显卡的区别">  核心显卡、主板集成显卡和独立显卡的区别</a><br><a href="#内存条">内存条</a><br><a href="#单通道与双通道">  单通道与双通道</a><br><a href="#硬盘">硬盘</a><br><a href="#机械硬盘">  机械硬盘</a><br><a href="#固态硬盘">  固态硬盘</a><br><a href="#电源">电源</a><br><a href="#功率的选择">  功率的选择</a><br><a href="#80Plus认证">  80Plus认证</a><br><a href="#模组选择">  模组选择</a><br><a href="#电源尺寸">  电源尺寸</a><br><a href="#关于品牌">  关于品牌</a><br><a href="#散热器">散热器</a><br><a href="#散热器的工作原理">  散热器的工作原理</a><br><a href="#影响散热效果的因素（风冷）">  影响散热效果的因素（风冷）</a><br><a href="#热量传递的效率">  热量传递的效率</a><br><a href="#风冷散热器的类型">  风冷散热器的类型</a><br><a href="#关于品牌">  关于品牌</a><br><a href="#显示器">显示器</a><br><a href="#显示器接口">  显示器接口</a><br><a href="#液晶面板">  液晶面板</a><br><a href="#带鱼屏">  带鱼屏</a><br><a href="#机箱">机箱</a><br><a href="#搭配选择">搭配选择</a><br><a href="#如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？">如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？</a><br><a href="#参考">参考</a><br><a href="#硬件知识">  硬件知识</a><br><a href="#组装电脑">  组装电脑</a>  </p>
</blockquote>
<hr>
<p><strong>电脑主要配件</strong>：主板、CPU、显卡、显示器、电源、机箱、内存条、硬盘。CPU、显卡、内存条、硬盘是插在主板上的，电源用来给主板上的部件进行供电，CPU，主板，显卡，内存条、硬盘、电源这几个放在机箱中就构成了我们通常所说的主机。摩尔定律，硬件的性能每隔18～20个月就会提升一倍。</p>
<a id="more"></a>
<h1 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h1><p><strong>主板主要接口</strong>：CPU插槽；内存条插槽；SATA硬盘接口；M.2接口(用于M.2接口的固态硬盘)；背板I/O接口；PCLE-X16插槽(用来接显卡)；PCLE-X1插槽(用来接声卡、网卡等)；供电插槽</p>
<p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929145343685-315109850.jpg" alt></p>
<p><strong>主板性能指标</strong>：芯片组、供电项数目（供电项越多，平分下来每一路的电流就会减小了，减少主板发热 超频时更加稳定）、做工、扩展能力（是否支持USB3.0或者USB3.1，是否支持超频）。</p>
<p>对于主板最重要的就是其<strong>稳定能力</strong>，其次才是<strong>芯片组</strong></p>
<p>因为<strong>芯片组有Intel和AMD</strong>，所以主板可以根据芯片组分类，英特尔和AMD这两家公司每次发布新的CPU的时候，都会先各大主板厂家发布适配自己CPU的芯片组，意思就是说：“我这边CPU已经做出来了，你们主板厂得按照我的这个标准，做出来的主板才能用我的这个CPU”</p>
<p><strong>如何区分intel主板和AMD主板：</strong></p>
<ul>
<li>intel主板会有亮闪闪的金属扣，且主板的安装位置是一个一个针脚，均匀分布，因为intel处理器是触点式接口</li>
<li>AMD主板没有金属扣，且主板的安装位置是一个一个小凹槽，因为AMD处理器是针脚式接口</li>
</ul>
<h2 id="Intel芯片组主板"><a href="#Intel芯片组主板" class="headerlink" title="Intel芯片组主板"></a>Intel芯片组主板</h2><p>芯片组是主板的核心芯片，选对芯片组，主板和CPU才能兼容。</p>
<h3 id="型号字母"><a href="#型号字母" class="headerlink" title="型号字母"></a>型号字母</h3><p>目前英特尔的芯片组有4个等级，<strong>H</strong>、<strong>B</strong>、<strong>Z</strong>、<strong>X</strong>分别适配不同的用户，下面只是一个大概的规律，不能以偏概全，比如：H370&gt;B360</p>
<p><strong><strong>H</strong></strong>：<strong>中低端、入门</strong>，<strong>不支持超频</strong>。价格在300元左右。</p>
<p><strong>B：**</strong>中低端、主流，<strong>这类主板</strong>几乎不能超频<strong>（有特殊几个主板能通过人工破解来进行超频），而且仅支持最高DDR4 2666GHz的内存条频率，所以如果你买的CPU是不带K的如 i3-8100；i5-8500这类不支持超频的CPU，或者本身没有超频需求，B系主板是非常划算和</strong>有性价比**的选择。价格在500元左右。</p>
<p><strong>Z：**</strong>高端，<strong>这类主板</strong>天生支持超频功能<strong>（需要CPU支持，</strong>英特尔CPU后面带K的都支持超频**，如i3-8350K;I5-8600K;I7-8700K），同时芯片组支持更多原生的扩展卡槽的接口，而且这类主板通常也支持非常高的内存频率，价格也会贵一些，一般在1000元以上。</p>
<p><strong>X：**</strong>特殊、顶级**，这类主板有2066个针脚，也就是只能用英特尔后面带X的CPU。如i9-7960X、i7-7800X。当然这类主板和CPU价格都高的吓人，市场很小众。</p>
<p>H、B、Z芯片组的主板/CPU接口都是 LGA 1151的，X系列的主板/CPU接口是 LGA 2066</p>
<h3 id="字母后面的数字"><a href="#字母后面的数字" class="headerlink" title="字母后面的数字"></a>字母后面的数字</h3><p><strong>100系列支持英特尔6代CPU</strong>，如B150芯片组支持i3-6100、i5-6500、i7 6700等。（intel的<strong>100系列</strong>主板刷新bios是可以上<strong>7</strong>代cpu的）</p>
<p><strong>**200系列</strong>支持<strong>英特尔</strong>6、7代CPU**，如：B250芯片组支持i3-7100、i5-7500、i7-7700k等。</p>
<p><strong>300系列支持</strong>英特尔<strong>8</strong>、<strong>9代CPU</strong>，如：B360芯片组支持i3-8100、i5-8500、i7-8700k、i7-9700k、i9-9900k等。</p>
<p>至于后面个位和十位数上的数字，越高代表主板在同等级中越高端。</p>
<h2 id="AMD芯片组主板"><a href="#AMD芯片组主板" class="headerlink" title="AMD芯片组主板"></a>AMD芯片组主板</h2><p>芯片组是主板的核心芯片，选对芯片组，主板和CPU才能兼容。</p>
<h3 id="型号字母-1"><a href="#型号字母-1" class="headerlink" title="型号字母"></a>型号字母</h3><p>AMD平台的主板芯片组，有<strong>A</strong>、<strong>B</strong>、<strong>X</strong>三个档次</p>
<p><strong>A：低端</strong>，这类芯片组的主板不能超频，普通用户使用也足够了。价格大多在500元以下。</p>
<p><strong>B：中端</strong>，这类芯片组的主板<strong>也能超频</strong>，高性能的接口数量要少一些，价格在500元左右，是普通装机用户的<strong>性价比选择。</strong></p>
<p><strong><strong>X：高端</strong></strong>，芯片组支持更多可以扩展的接口，<strong>可以超频</strong>。</p>
<p>AMD芯片组的主板CPU接口大都是AM4的，像高端的X399CPU接口是TR4的。</p>
<h3 id="字母后面的数字-1"><a href="#字母后面的数字-1" class="headerlink" title="字母后面的数字"></a>字母后面的数字</h3><p><strong>**300系列</strong>支持 <strong><strong>一代</strong></strong>锐龙，需要更新BIOS才能支持二代锐龙<strong><strong>**</strong></strong></p>
<p><strong>**</strong>400系列<strong>支持 一代、二代锐龙**</strong></p>
<p>锐龙二代或一代的用户买300 400系列芯片组的主板都可以</p>
<h2 id="主板尺寸"><a href="#主板尺寸" class="headerlink" title="主板尺寸"></a>主板尺寸</h2><p>常见的主板板型分为：E-ATX(加强型)、ATX(标准型)、M-ATX(紧凑型)、MINI-ITX(迷你型)。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114095147601-1312966062.png" alt> </p>
<p>常见的主板板型对比</p>
<p><strong>E-ATX型主板</strong>：<strong>高性能主板</strong>，一般会有8跟内存插槽，芯片组也多为X等级的，也就是说适用于英特尔以X结尾的CPU，如i9-7960X。价格非常高</p>
<p><strong>ATX型主板：</strong>用的最多的主板，俗称“<strong>大板</strong>”。这类主板由于体型稍大，需要搭配中塔以上大机箱，做工用料较好，扩展接口比较丰富，不过价位略贵</p>
<p><strong>M-ATX型主板：</strong>比ATX要短了一些，俗称“<strong>小板</strong>”，也叫紧凑型主板，其结构为方形。M-ATX主板主要用于小机箱电脑中，如今装机非常主流的主板板型。</p>
<p><strong>MINI-ITX型主板：</strong>俗称<strong>迷你型主板</strong>，结构是方形，主板尺寸小，适合一些迷你小机箱电脑，这种主板通常作为小巧的HTPC电脑，因此这类主板大部分都内置了Wifi模块。</p>
<h3 id="主板小板和大板的区别是什么？主板小板和大板优缺点分析："><a href="#主板小板和大板的区别是什么？主板小板和大板优缺点分析：" class="headerlink" title="主板小板和大板的区别是什么？主板小板和大板优缺点分析："></a><strong>主板小板和大板的区别是什么？主板小板和大板优缺点分析：</strong></h3><p>1、同芯片的主板大板和小板性能没有任何提升，主板尺寸并不会影响到电脑的整体性能；</p>
<p>2、大板相比小板的扩展接口也许会更加丰富，比如大板标配4个内存插槽，而小板有可能是2个或则4个，大板的PCI-E显卡插槽拥有两个，而小板只有一个。此外，PCI插槽方面，大板也更丰富一些，USB方面，大板通常也多出两个；</p>
<p>3、大主板做工用料相对充足，不过价位上也会更加贵一些；</p>
<p>4、大板需要中塔以上大机箱支持，而小主板既能够兼容大机箱，还能够兼容一些迷你机箱，价位上也相对可能实惠一些；</p>
<p>　　对于买主板是选择小板还是大板，关于这个问题，关键看个人需求。通常来说，组装入门级电脑，选用小巧的M-ATX机箱，那么肯定需要选用M-ATX主板或者迷你主板，对于注重散热并定位中高端或者高端，选用大机箱的装机用户，建议搭配ATX大主板，其扩展、做工更加有优势，一般用户，建议选择M-ATX小主板，价格相对实惠一些，扩展接口也基本足够使用了，属于大众型主板。</p>
<h2 id="关于品牌"><a href="#关于品牌" class="headerlink" title="关于品牌"></a>关于品牌</h2><p><strong>华硕：</strong>三大板厂之一，主板的BIOS界面做的超一流，简单易懂，好用，而且功能很多。高端主板非常强，中低端主板与其他牌子拉不开差距。ROG玩家国度系列主板用料豪华，超频能力非常强，是最高端主板的象征。</p>
<p><strong>技嘉：</strong>三大板厂之一，技嘉的主板一般比较耐用。AROUS系列主板定位高端，类ROG玩家国度。</p>
<p><strong>微星：</strong>三大板厂之一，微星的板子跟华硕技嘉都差不多，BIOS比华硕稍差一些，价格也低一点点。</p>
<p><strong>华擎：</strong>华擎是华硕的子公司，是华硕面对中低端市场与二三线品牌竞争的品牌，在低价位中用料算是不错的，性价比高，价格比三大厂要低一两百块，被称为价格屠夫。</p>
<p><strong>映泰</strong>：映泰也是台湾的主板大厂，主板相对来说稍微低端一些，稳定性可以，价格也很低。</p>
<p><strong>七彩虹：</strong>七彩虹的品牌宣传做的好，线下电脑城卖的好，但线上销量有点凄惨，不建议购买。</p>
<p>高端板子最好选择华硕的，低中端主板最好选择技嘉、华擎的。</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>CPU有几个重要的参数：架构、主频(频率)、核心数、线程数、缓存、最大睿频。</p>
<h2 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h2><p><strong>主频</strong>：CPU的工作频率，我们可以直接理解为运算速度，主频越高，计算能力越强，现在CPU主频都以GHz为单位。</p>
<p><strong>最大睿频</strong>：睿频是指当启动一个运行程序后，处理器会自动加速到合适的频率，而原来的运行速度会提升 10%~20% 以保证程序流畅运行的一种技术。</p>
<p><strong>核心数</strong>与<strong>线程数</strong>：核心数就相当于有多少只手，线程数就相当于你能同时干几样活，核心数*线程数=马路宽度，频率等于车速</p>
<p><strong>架构</strong>：架构对性能的影响最大。一般来说，每一代CPU的架构都是一样的，</p>
<p><strong>缓存</strong>：位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。有一级缓存和二级缓存，一级缓存的容量基本在4KB~64KB，二级缓存的容量则分为128KB/256KB/512KB/1MB/2MB等，一级缓冲容量相差不大，二级缓存容量则是提高CPU内存的关键。</p>
<p>如果玩游戏，就需要选主频高的，简单粗暴的进行计算。如果做图形渲染，建议多核心多线程的</p>
<p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929113926637-1532822600.png" alt></p>
<p>CPU有两家厂商在做Intel和AMD，处理器有两种接口接口类型，<strong>AMD的CPU是针脚式</strong>，<strong>Intel的CPU是触点式</strong>，由于intelCPU采用了触点式所以intel主板就必须有针脚，而AMD则是与之相反，CPU使用针脚，主板采用触点式。虽然方式不同，但是从性能上完全没有区别，主要AMD的处理器针脚特别怕弯，弯了或者断了处理器基本就要凉凉了。而intel处理器就不会这样，不过intel主板的针脚也极易容易弯折。现在AMD也推出了自己的触点式处理器——线程撕裂者，以后AMD处理器也会朝着触点式发展。</p>
<p><strong>Intel CPU</strong>：稳定性强，功耗低（发热量少，常规散热系统），兼容性强</p>
<p><strong>AMD CPU</strong>：爆发力强，多线程（适合画图）、功耗高（发热量大，散热系统需要规划）</p>
<p>Intel CPU和AMD CPU在相同性能下，价格往往AMD会更加实惠，换句话说相同价位的CPU，AMD的性能普遍更强，说虽然这么说，但是还是要看个人需求，毕竟这两款CPU的针对性不同，当然对于AMD的高端CPU散热量和Intel差不多，不用很担心AMD处理器散热问题。</p>
<h2 id="Intel-CPU后面的数字"><a href="#Intel-CPU后面的数字" class="headerlink" title="Intel CPU后面的数字"></a>Intel CPU后面的数字</h2><p>　　以i5 3450U为例</p>
<p><strong>第一位**</strong>数字 **是i 后面的数字代表的是家族名称。</p>
<p><strong>第二位**</strong>数字 **“3”代表它是第几代架构的产品，后面的三位数字是CPU型号，一般越高越好，</p>
<p><strong>第三位数字 </strong>“4”代表的是处理器等级。</p>
<p><strong>第四位和第五位数字 </strong>“50”代表处理器的频率。如果后面还有@ 3.0GHz  @ 3.0GHz，前一个是主频后一个是睿频</p>
<h2 id="Intel-CPU后面的字母"><a href="#Intel-CPU后面的字母" class="headerlink" title="Intel CPU后面的字母"></a>Intel CPU后面的字母</h2><p><strong>K</strong>代表不锁倍频的处理器；也就是可以超频；</p>
<p><strong>M</strong>代表标准电压cpu，可以拆卸的；</p>
<p><strong>U</strong>代表低电压节能的，可以拆卸的；</p>
<p><strong>X</strong>代表高性能，可拆卸的；</p>
<p><strong>Q</strong>代表至高性能级别；</p>
<p><strong>H</strong>是高电压的，是焊接的，不能拆卸；</p>
<p><strong>Y</strong>代表超低电压的，除了省电，没别的优点的了，是不能拆卸的；</p>
<p><strong>F</strong>代表不带内置显卡(核显)</p>
<p>两个字母的，属于上面这些特性的组合</p>
<blockquote>
<p>相同性能的CPU，Intel的CPU价格要比AMD贵，且Intel的CPU功耗比AMD处理器功耗低。如果手头预算不多，建议选择AMD的CPU，而手头宽裕的话，建议选择Intel的CPU。相比而言AMD 的CPU性价比较高。</p>
</blockquote>
<h2 id="AMD-CPU后面的数字"><a href="#AMD-CPU后面的数字" class="headerlink" title="AMD CPU后面的数字"></a>AMD CPU后面的数字</h2><p>　　以R5 1500X为例</p>
<p><strong>第一位数字</strong> 是R 后面的数字代表的是家族名称。</p>
<p><strong>第二位数字</strong> “1”代表它是第几代架构的产品，</p>
<p>后面的三位数字是CPU型号，一般越高越好，</p>
<p>X代表支持完整的XFR技术（带X的超频能力更强，而且超频是全自动智能的）。</p>
<h2 id="CPU天梯图"><a href="#CPU天梯图" class="headerlink" title="CPU天梯图"></a>CPU天梯图</h2><p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929140546242-149217135.png" alt></p>
<p>想要看更详细的CPU性能天梯图请移步：<a href="http://www.mydrivers.com/zhuanti/tianti/cpu/index.html" target="_blank" rel="noopener">http://www.mydrivers.com/zhuanti/tianti/cpu/index.html</a></p>
<p>中关村CPU性能天梯图：<a href="https://cpu.zol.com.cn/soc/" target="_blank" rel="noopener">https://cpu.zol.com.cn/soc/</a></p>
<p>注意事项：选购CPU、主板的时候要特别注意接口时候匹配</p>
<h2 id="CPU的主要厂商"><a href="#CPU的主要厂商" class="headerlink" title="CPU的主要厂商"></a><strong>CPU的主要厂商</strong></h2><ul>
<li>Intel：主要有赛扬（Celeron）、奔腾（Pentinum）、酷睿2（Core2）、酷睿i（Core i）这三个系列，赛扬系列以低端产品为主，奔腾系列以低端和低中端产品为主，Core2以低端和中低端产品为主，Core i系列以中端和高端产品为主，酷睿i3 i5 i7 是英特尔主流的处理器家族。总的来说，性能强弱为赛扬&lt;奔腾&lt;酷睿2&lt;酷睿 i。但是不是绝对的，还要看该系列的产品是第几代的，比如酷睿2系列的CPU不一定就绝对地比奔腾系列的CPU性能强，从天梯排行中就可以看出来，Pentinum E5700&gt;Core2 duo E4300.</li>
<li>AMD：主要有锐龙(Ryzen，性价比)、AMD FX(推土机，高端)、APU(以四核为主)、速龙（Athlon，性价比）、闪龙（Sempron），这几个系列，闪龙系列主要以低端产品为主，速龙以低端和低中端产品为主，弈龙主要以中端和高端产品为主，A系列（A系列集成了显卡芯片）主要以低中端和中低端产品为主，FX系列以中高端和高端产品为主。总的来说，性能强弱为：闪龙&lt;速龙&lt;A系列&lt;弈龙&lt;FX。但是这个也不是绝对的。比如弈龙1代的很多产品性能就比不上速龙2代的产品。AMD现在只有锐龙系列的CPU值得买</li>
</ul>
<h1 id="显卡"><a href="#显卡" class="headerlink" title="显卡 "></a>显卡 </h1><p><strong>显卡的性能指标</strong>：架构、流处理器个数、GPU频率、核心频率、显存带宽、显存大小（按重要程度排序）</p>
<p>架构：越新越好</p>
<p>流处理器：简称SP，也叫渲染管，是显卡最重要的参数，流处理器的数量直接影响显卡的性能，流处理器越多，显卡画图能力越强，速度越快(同一代的显卡比较流处理器才有意义)。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114162727474-1218538472.png" alt></p>
<p>GPU频率：GPU频率越高，性能越强，发热也越大，功耗越高；频率低，性能弱，发热也越小。</p>
<p>显存带宽：显存带宽=显存位宽×显存频率，显存位宽就相当于公路路宽，显存频率就像汽车的速度，所以，显卡位宽和显存频率对显卡的性能影响很大。</p>
<p>显存容量：显存能提供临时的存储功能。很多奸商会把显存当做显卡的卖点来忽悠小白，这里要说的是，大显存有用，但不是那么的重要。举个例子：显存是停车场，如果停车场的马路不够宽（位宽 bit），汽车的速度也不够快（显存频率MHz)，那么这个停车场的吞吐量就很小，修一个超大的停车场纯属浪费资源。</p>
<h2 id="显卡品牌：N卡和A卡"><a href="#显卡品牌：N卡和A卡" class="headerlink" title="显卡品牌：N卡和A卡"></a>显卡品牌：N卡和A卡</h2><p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929113017828-590241116.png" alt></p>
<h3 id="Nvida-Geforce——N卡"><a href="#Nvida-Geforce——N卡" class="headerlink" title="Nvida Geforce——N卡"></a>Nvida Geforce——N卡</h3><p>N卡有GT、GTS、GTX这几个系列。</p>
<p>GT是普通系列，而GTS和GTX是中高端系列的，如果后面跟了 Ti 表示是该型号的的加强版。</p>
<p>在选择N卡来说，一般看第一位数字和第二位数字，</p>
<p><strong>第一位数字</strong> 第几代显卡</p>
<p><strong>第二位数字</strong> 表示是该系列的低端、中端还是高端。1，2，3的话表示是该系列的低端产品；4，5，6表示是中端产品，7，8，9表示是高端产品，比如GT610就是第六代的低端显卡，还有一点就是产品低一代的话，而第二个数字高一点的话，两个显卡的性能基本很接近的，比如GT640和GT550，GT640是第六代的显卡，GT550是第五代的显卡，而GT550第二位数字是5，GT640第二位数字是4，通常来说，像这样的情况下，两个显卡的性能是很接近的。</p>
<p><strong>第三位数字</strong> “0”表示常规显卡，“5”表示升级版</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114164801692-196287110.png" alt></p>
<p><strong>N卡优缺点</strong></p>
<ul>
<li>设计侧重点：3D性能和速度，</li>
<li>性能运算：执行效率高，但运行能力较低</li>
<li>视频处理：色彩稍淡，需要手动调节分辨率</li>
</ul>
<h3 id="ATI——A卡"><a href="#ATI——A卡" class="headerlink" title="ATI——A卡"></a><strong>ATI——</strong>A卡</h3><p><strong>ATI</strong>(已经被AMD收购)，<strong>A卡</strong>；N卡有镭、HD、R、X系列。</p>
<p><strong>第一位数字</strong> 表示是第几代，</p>
<p><strong>第二位数字</strong> 表示该系列的低端、中端还是高端。4，5的话表示是低端；6，7表示是中端；8，9表示是高端。</p>
<p><strong>第三位数字</strong> “0”表示常规显卡，“5”表示升级版</p>
<p><strong>A卡优缺点</strong></p>
<ul>
<li>设计侧重点：2D平面画质</li>
<li>性能运算：运算能力强大，但执行效率不高，对于复杂的任务适应性不强，需要软件的支持</li>
<li>视频处理：自动调节分辨率，色彩还原度高</li>
</ul>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114164906037-1495443491.png" alt></p>
<p>娱乐一下</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114163710411-1578557060.png" alt></p>
<p>　　相同性能情况下N卡价格比A卡贵，A卡的性价比相对来说要高一点。现在来说，N卡和A卡区别不大，普通用户根本用不出来区别。但是A卡较N卡性价比高是真的。有时候我们看到一个显卡相同的型号，但是却买不同的价格，其主要原因是因为显卡的核心频率、散热设计等不同。</p>
<h2 id="关于品牌-1"><a href="#关于品牌-1" class="headerlink" title="关于品牌"></a>关于品牌</h2><p>目前较大的显卡品牌有：华硕、技嘉、微星、蓝宝石、索泰、映众、七彩虹、影驰等。</p>
<p><strong>华硕</strong>：三大显卡厂之一，显卡用料好、散热猛、售后好、价格高。<strong>ROG玩家国度系列在性能、散热、外观等各个方面都几乎完美</strong>，但是就是贵。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170114606-713450572.png" alt></p>
<p><strong>技嘉</strong>：三大显卡厂之一，显卡做工用料都很好。<strong>旗下有AORUS系列，定位类似ROG玩家国度</strong>，价格和玩家国度也差不多。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170132809-1182807883.png" alt></p>
<p><strong>微星</strong>：三大显卡厂之一，是<strong>三大厂中性价比最高的</strong>。微星红龙系列显卡性能和用料还是很强的，而且价格要便宜一些。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170143521-129482932.png" alt></p>
<p><strong>蓝宝石</strong>：是AMD最忠实的合作伙伴，<strong>A卡最强厂家</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170150071-1375418241.png" alt></p>
<p><strong>索泰</strong>：索泰和映众都是香港柏能旗下的品牌，索泰被称为“<strong>堆料狂魔</strong>”，显卡<strong>性能极强</strong>，核心频率调的很高，性能甚至超越三大厂，价格还便宜，但是高频带来的<strong>散热问题较大</strong>，可能会比较吵。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170155985-645292354.png" alt></p>
<p><strong>映众</strong>：映众跟索泰的做法刚好相反，映众在显卡的核心频率上没索泰那么激进，为了<strong>散热和静音</strong>将显卡频率调低了一点点，牺牲了小部分性能。映众冰龙系列<strong>散热极佳，风扇非常静音</strong>，价格也较低。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170202171-45700482.png" alt></p>
<p><strong>影驰</strong>：影驰的显卡其实也是非常不错的，<strong>名人堂系列</strong>显卡用料足，外观也很好看，但是价格非常非常高，性价比很低，感觉不如买三大厂的旗舰型号。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170218827-479568681.png" alt></p>
<p><strong>七彩虹</strong>：七彩虹也被称为“凄惨红”，七彩虹在十年前的名声并不好，但是现在七彩虹的igame系列显卡做的还可以，价格和性能都中规中矩。如果<strong>遇上打折力度较大，也是可以选择的</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114170213496-277375763.png" alt></p>
<h2 id="核心显卡、主板集成显卡和独立显卡的区别"><a href="#核心显卡、主板集成显卡和独立显卡的区别" class="headerlink" title="核心显卡、主板集成显卡和独立显卡的区别"></a>核心显卡、主板集成显卡和独立显卡的区别</h2><p><strong>核心显卡：</strong>处理器集成显卡就是指集成在cpu内部的显卡</p>
<p><strong>集成显卡：</strong>集成在主板北桥中的显卡，目前处理器核心显卡性能已经领先于主板集成的显卡，并且将显卡集成在CPU中比集成在主板中更有优势。新的主板厂商已经不会在主板上集成显卡了。</p>
<p><strong>独立显卡：</strong>我们自己加的独立的显示芯片，采用PCI接口插槽。</p>
<p>注意：下图左边NVIDIA卡的支持光追改成RTX了，不支持光追的还是GTX</p>
<p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929141351372-804157291.png" alt></p>
<p>想要看更详细的显卡性能天梯图请移步：<a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html" target="_blank" rel="noopener">https://www.mydrivers.com/zhuanti/tianti/gpu/index.html</a><a href="http://www.mydrivers.com/zhuanti/tianti/cpu/index.html" target="_blank" rel="noopener">  
</a></p>
<p>中关村显卡性能天梯图：<a href="http://vga.zol.com.cn/soc/" target="_blank" rel="noopener">http://vga.zol.com.cn/soc/</a></p>
<h1 id="内存条"><a href="#内存条" class="headerlink" title="内存条"></a>内存条</h1><p>　　DDR内存，目前分为4代。每到新一代的内存的开发，都是为了解决上一代内存速度极限的问题，DDR2到了1066就不能再高了，而DDR3是从1066起步的，DDR3内存条基本上到了2400的频率，就上不去了。而DDR4代，从2400起步，同之前的内存是一样的。所以，这个其实是根本区别。再高的频率，意味着更大的带宽，就可以更好的适应新的CPU的要求。</p>
<p><strong>DDR3 </strong>支持频率有6种：<strong>800Mhz</strong>(DDR2和DDR3换代时候的产品)、<strong>1066Mhz</strong>(DDR2和DDR3换代时候的产品)、<strong>1333Mhz</strong>(常见)、<strong>1600Mhz</strong>(常见)、<strong>1866Mhz</strong>(高端电脑配备)、<strong>2400Mhz</strong>(高端电脑配备)</p>
<p><strong>DDR4 </strong>支持频率有6种：<strong>2133MHZ</strong>(常见)、<strong>2400MHz</strong>(常见)、<strong>2666MHz</strong>、<strong>2800MHz</strong>、<strong>3000MHz</strong>、<strong>3200MHZ</strong>、<strong>3300MHZ，</strong></p>
<p>内存最高频率 &lt; 主板最大支持频率</p>
<p><img src="https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191008213214451-1909427204.png" alt></p>
<p>　　内存是CPU与硬盘之间的传输的中间设备，以DDR4为例，内存条的读写速度相比于硬盘快很多很多很多。</p>
<p><strong>内存的主要参数</strong>：频率、时延、颗粒、容量、下行速度（按重要程度排序）</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114185345848-1662642306.png" alt></p>
<p><strong>频率和时序</strong>：我们经常看到的2133MHz、2400MHz、3200MHz就是内存条的频率，它可以看成是内存条数据的传输速度，超高频率的内存条固然能给游戏带来一点性能提升，但是需要更高端的主板和CPU的支持，普通用户选择2400MHz的也已经足够用了，频率是内存条最重要的参数。</p>
<p>　　还有一个重要参数就是<strong>时延</strong>，一般用CL表示，时延就是寻址所需的时钟周期。同一频率的内存条时延越低越好。</p>
<p>现在普通的DDR4代内存条一般为频率2400MHz，时序CL15-17左右。但是一些使用极品颗粒的超频内存条如三星的B-die颗粒就可以轻松做到频率3200MHz，而且时序只有CL12。这类极品内存条可以做到保证时序不超标的情况下，超频上4000MHz以上。</p>
<p>几乎所有的<strong>DDR4代的内存条默认的频率只有2133MHz</strong>，所以即使你买的是高频内存条，也需要在<strong>主板BIOS设置中打开XMP</strong>（自动超频）或手动设置超频后才能达到商家所给出的频率，而且，<strong>很多主板并不支持超过2666MHz以上的频率</strong>，所以即使你的内存条是4000MHz的神条，也会自动降频到2666MHz使用，这个需要用户去看主板上的说明。</p>
<p><strong>内存条颗粒</strong>：颗粒就是内存条的存储数据的东西，现在主流的颗粒生产商就是 <strong>三星</strong>、<strong>海力士</strong>、<strong>镁光</strong>这三家。由于颗粒在生产时候会有质量参差不齐的情况，所以一些成色极品的颗粒会被挑选出来做成高端超频内存条，而一些成色普通但合格的颗粒会被拿去做成普通内存条。至于怎么看颗粒的好坏，我们可以从内存条的频率和时序来做一个购买前的初步判断。</p>
<p><strong>内存条容量</strong>：容量越大，存储的数据越多。每打开一个软件，这些软件的数据都会被保存到内存条中，如果内存条被塞满，我们继续打开其他软件的时候，CPU就只能从速度超慢的硬盘调取数据了</p>
<h2 id="单通道与双通道"><a href="#单通道与双通道" class="headerlink" title="单通道与双通道"></a>单通道与双通道</h2><p>CPU与内存条之间需要交换数据，就有上行数据(内存条数据传入CPU)和下行数据(CPU数据传入内存条)  ，如果只有一根内存条，那么上行数据和下行数据的传输就需要占用一条通道，争抢通道的使用权限和带宽。如果有两根内存条组双通道，那么上行数据和下行数据的传输就可以分别在两根内存条之间分别传输，互不影响。</p>
<p>　　一般来说，两根相同规格的内存条插在主板对应的位置上就可以组成双通道了（看B站<a href="https://space.bilibili.com/54245027/article" target="_blank" rel="noopener">斜耳朵</a>UP主说的）。</p>
<p>双通道能够给计算机带来<strong>5%左右的性能提升</strong>，双通道最大受益者是集显/核显，因为CPU要同时负责程序数据和显示数据的处理，需要的数据流量更大，所以双通道带来的双倍带宽才能满足这么大的数据流量的需求。英特核显可以提高20％性能，amd核显可以提升30％-50％。</p>
<p>内存条选择注意事项：</p>
<ol>
<li>对于普通用户，选择内存条的时候，一般来说4g就可以了，最多8g，16g的内存条看需求，如果自己也不知道自己需要多少容量的，可以先买一根8GB的使用，发现不够可以再买一根8GB组双通道。</li>
<li>如果有两根或多根不同频率的内存条同时使用，会<strong>以频率最低的来统一频率</strong>。比如有一根2133MHz、一根2400MHz、一根3200MHz的内存条同时使用的话，所有内存条都是按照2133MHz来使用。所以一般组双通道建议购买两根相同规格的内存条插在主板对应的位置上。所以如果是升级内存条的用户，一定要看看已有的是多少频率的，不要盲目购买高频内存条。</li>
<li>有4根内存插槽的主板，你把内存条插满它依然是双通道的</li>
<li>关于内存条PCB板的层数，层数越多，电路板内部的电路走线层数增加，每一层的电路走线就不会那么拥挤了，这样会有更好的电气性能，使得超频更加稳定。</li>
<li>AMD锐龙平台用户可以选择芝奇、英睿达等牌子的内存条，可以兼容。</li>
<li>关于品牌：各个主流品牌之间内存条价格差距不大，普通用户建议在 <strong>芝奇</strong>、<strong>英睿达</strong>、<strong>海盗船</strong>、<strong>影驰</strong>、<strong>金士顿</strong>、<strong>威刚</strong>、<strong>阿斯加特</strong>、<strong>十铨</strong>、<strong>宇瞻</strong>等这几个品牌中对比挑选一款频率、时序、价格都不错的内存条，然后认准官方自营旗舰店、官方旗舰店，因为内存条官方都会终身质保。</li>
</ol>
<h1 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h1><p>　　我们都知道木桶的短板效应，就电脑的速度来说，<strong>CPU缓存、显卡缓存、甚至是内存条都是以至少十倍百倍以上的速度差距远远的超过了所有的机械硬盘</strong>的，这就一定会给电脑的性能带来一些瓶颈。固态硬盘的存储速度是机械硬盘的5-10倍左右，多少能弥补一些硬盘在速度上的短板，<strong>所以如果你觉得你的旧电脑有些卡，反应慢，换一块固态硬盘绝对能给你的旧电脑带来新的生命</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114202727339-1973588211.png" alt></p>
<h2 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h2><p>　　机械硬盘是<strong>利用磁性来记录信息数据</strong>，原理类似与小时候听歌用的磁带，如果我们需要找到某个数据，磁盘就会转动到记录这个信息的部位，然后由磁头感应磁性来读取数据。</p>
<p>注意事项：硬盘建议选择西部数据和希捷的，我个人倾向于西部数据，相比而言稳定一点，硬盘的转速有7200转和5400转的，最好选择7200转的，西部数据硬盘有三种：黑盘，蓝盘和绿盘，在买硬盘的时候注意千万不要买绿盘，最好选择蓝盘或者黑盘（价格有点贵）。好像现在又出了红盘，具体不是很清楚。</p>
<p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929150819499-2128493526.png" alt></p>
<h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><p>　　固态硬盘（SSD）是<strong>利用电流来记录信息数据</strong>，原理类似与MP3，如果我们要找到某个数据，直接去找到存放数据的区域，就可以直接读取了。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114203439951-325641122.png" alt>  <img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114203448104-2040709388.png" alt></p>
<p>固态硬盘的性能参数：固态硬盘的颗粒、主控、缓存、3D NAND堆栈技术、接口\总线\协议、（按重要程度排序）</p>
<h3 id="颗粒"><a href="#颗粒" class="headerlink" title="颗粒"></a>颗粒</h3><p>闪存颗粒是固态硬盘用来存储数据的东西，分为<strong>SLC</strong>、<strong>MLC</strong>、<strong>TLC</strong>三种，是挑选固态最重要的参数。</p>
<p><strong>SLC</strong>：每个存储单元存储<strong>1bit</strong>的数据。这种存储方式稳定性最强，读写速度很快，而且不会出错，寿命长，但是成本高。</p>
<p><strong>MLC</strong>：每个存储单元存储<strong>2bit</strong>的数据，速度会比SLC慢一点，稳定性较强，寿命还好，但是价格贵。</p>
<p><strong>TLC</strong>：每个存储单元存储<strong>3bit</strong>的数据，效率低、速度慢、还容易出错、寿命相对于上面两种短一些,，说虽这么说，但是现在使用最多的还是TLC，重度使用5年是没有问题的，且价格相对便宜。</p>
<p>现在世界上能自主生产颗粒的厂家有：intel、三星、闪迪、东芝、镁光（英睿达）、海力士。所有正规的固态硬盘使用的都是这几家的检验合格的原厂颗粒。如使用自家颗粒的intel、三星、闪迪、镁光（英睿达）、东芝等；还有虽然自己不会生产颗粒，但是使用从原厂购买颗粒的浦科特、海盗船、建兴等。</p>
<h3 id="主控"><a href="#主控" class="headerlink" title="主控"></a><strong>主控</strong></h3><p>　　主控很重要，就相当于颗粒的管理员。比较好的主控品牌有：马牌（Marvell）、SandForce、三星、intel、东芝等</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h3><p>　　和前面一样，缓存就是CPU和固态硬盘之间的缓冲区，方便传输，缓存越大越好</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a><strong>总线</strong></h3><p>　　总线有SATA总线、PCI-E总线(PCIE×1、PCIE×2、PCIE×4、PCIE×8、PCIE×16 数字越大，速度越快)目前固态硬盘用的都是PCIEx2和PCIEx4的总线，显卡是PCIEx16总线</p>
<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>　　传输协议有：IDE(老的机械硬盘)、AHCI(机械硬盘)、SATA(目前主流硬盘协议)和NVMe(高速度低延迟)。越后面传输速度越快，拥有NVME协议的固态硬盘速度比无NVME协议的固态硬盘快很多。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>目前固态硬盘接口有：SATA、mSATA、M.2、PCI-E</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114205327799-2076300470.png" alt></p>
<p><strong>SATA接口</strong>：属于老式的接口，分SATA 3GB和SATA6 GB，我们的机械硬盘使用的也是这种接口。这种接口速度稍慢，延迟稍高，最大速度不会超过600MB/s，</p>
<p><strong>mSATA接口</strong>：这种接口不多，一般用在笔记本上</p>
<p><strong>M.2接口</strong>有两种：B key和M key。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114210747297-924690287.png" alt></p>
<p><strong>B key M.2接口</strong>：又称“SOCKET 2”，豁口在左边，比较老，支持PCI-Ex2总线和SATA总线，速度比较慢</p>
<p><strong>M key M.2接口</strong>：又称“SOCKET 3”，豁口在右边，目前主流，支持PCI-Ex4总线，速度比较快</p>
<p>B&amp;M型接口的固态硬盘兼容性好，两种M.2的插槽都能用，性能和B key差不多。</p>
<p><strong>PCI-E接口</strong>：一般这个插槽是给显卡用的，但也可以用它来插固态硬盘，这个长得跟显卡一样的固态硬盘也是 PCI-E ×4的接口，支持PCI-E ×4的总线。但是现在的主板大多数是没有PCIE-4的插槽的。所以一般都是接在显卡的插槽里使用的。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191114212811099-1261214911.png" alt></p>
<p><strong>4KB随机读写：</strong>固态硬盘虽然顺序读写速度超快，但是那是只有在读写一整个大文件（如一部电影）时才能体会到它的优势，而影响我们日常使用的是硬盘的4KB 随机读写速度</p>
<p>排名</p>
<p><img src="https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190929141919965-1141374635.png" alt></p>
<blockquote>
<p>固态硬盘推荐：</p>
<ul>
<li>120GB装个系统，装几个日常软件、装一个大型游戏就差不多满了，建议首选240GB容量。</li>
<li>新配电脑的用户建议选择M.2接口的硬盘，因为这是未来的主流。老电脑升级的用户要检查主板是否有M.2插槽。</li>
<li>4k读写性能才是影响日常体验的重中之重，购买前需要重点关注。 </li>
</ul>
</blockquote>
<h1 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h1><p>　　电源的选择是最容易被我们忽略，又非常重要的一项，我们的核心部件如：CPU、固态硬盘、内存条都是由额定电压的。如果如果供电不稳定忽高忽低，很容易造成元器件的损坏与老化。理想情况下，供电12V就是12V，但是市面上几乎没有一款真正能做到0偏差，intel CPU对电压的要求是偏差不超过±5±5\pm5%，电源的好坏和品牌没有绝对的关系，即便是品牌好的牌子如海盗船，也依然有差的电源，如：VS系列。</p>
<h2 id="功率的选择"><a href="#功率的选择" class="headerlink" title="功率的选择"></a>功率的选择</h2><p>直流输出中+12V的，是给CPU和显卡供电的电压和电流。最好买单路12V的，因为双路12V的会限制CPU和显卡的使用功率，单路的直接给他们，谁需求多谁就取得多。买电源的时候，+12V的直流电源功率大于显卡和CPU的额定功率就不会出问题。</p>
<h2 id="80Plus认证"><a href="#80Plus认证" class="headerlink" title="80Plus认证"></a><strong>80Plus认证</strong></h2><p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115093316122-42975311.png" alt></p>
<p>80Plus认证是一个电源转换率标准，转化率越高，也就越省电。就是说，如果你的电源额定功率是500W的白牌电源（满载转化率为80%），那么当你的电源满载时，你家电表实际用电为：500÷80%=625W</p>
<p>注意：80plus认证仅仅是转化率标准，不能直接反应电源的好坏，所以这个指标在购买时仅作为参考就行了。</p>
<p><strong>电源用料</strong>：日系电容&gt;台系电容&gt;国产电容（大概排名，不绝对）</p>
<h2 id="模组选择"><a href="#模组选择" class="headerlink" title="模组选择"></a><strong>模组选择</strong></h2><p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115093630340-1637950448.png" alt></p>
<p><strong>非模组</strong>：非模组电源价格便宜，但是<strong>全部线材固定</strong>，多余线头不能拆卸，理线稍微麻烦一些。</p>
<p><strong>半模组</strong>：比非模组贵一点，重要线材固定，<strong>部分线材可拆卸</strong>，可以去除多余线材。</p>
<p><strong>全模组</strong>：价格最贵，全<strong>部线材可拆卸</strong>，美观，方便理线。</p>
<h2 id="电源尺寸"><a href="#电源尺寸" class="headerlink" title="电源尺寸"></a>电源尺寸</h2><p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115093829824-233476730.png" alt></p>
<p>一般来说选择ATX的电源就够了，SFX尺寸的电源一般用在MINI型机箱上面。</p>
<h2 id="关于品牌-2"><a href="#关于品牌-2" class="headerlink" title="关于品牌"></a>关于品牌</h2><p><strong>振华（super flower）</strong>：台企，振华电源有战碟、金蝶、金蝶GX、Leadex这几个系列，建议从金蝶开始买起，</p>
<p><strong>海韵</strong>：台企，海韵的电源清一色<strong>日系电容</strong>，用料很不错。</p>
<p><strong>酷冷至尊</strong>：台企，<strong>全日系电容</strong>，全模组，性价比高，稳定性很好。</p>
<p><strong>美商海盗船</strong>：美企，<strong>海盗船的电源一定要买高端的，也就是800元起步</strong>，低端的VS系列价格高，配置低，臭名在外；</p>
<p><strong>EVGA</strong>：美企，EVGA的电源500元以下的都不建议买，性价比太低了。高端的如G、P、T系列都是全日系电容，主流的LLC半桥+ DC-DC 结构。质保7-10年，性价比稍低。</p>
<p><strong>讯景（XFX）</strong>：讯景低端的XT2电源（价格在300左右）不建议买，因为虽然价格不低，但是电源方案很落后，高端点的XTR、XTS系列价格在500元以上，方案主流，可以购买，但性价比稍低。</p>
<p><strong>台达</strong>：台企，台达是世界最大的电源生产商，<strong>主要是做服务器电源和高端专业的电源解决方案</strong>，在零售商做的不是很多。有几款在售的电源如NX系列和VX静音王系列价格便宜，全日系电容用料很不错，很耐用。</p>
<p><strong>航嘉</strong>：深圳企业，国内老牌电源厂商，型号多，价格从100-1000都有。航嘉的电源是国内做工非常好的，低端电源也比国内杂牌好的很多，安全有保障，<strong>300元以内还是推荐买的，超过300的还是建议去买酷妈和振华</strong>。</p>
<p><strong>鑫谷</strong>：东莞企业，国内老牌电源厂商，<strong>比较推荐的是GP 白金版，使用日系和台系电容，而且是白金牌认证，电压波形很稳，价格也很便宜，性价比很高</strong>。</p>
<blockquote>
<p>注意事项：</p>
<ol>
<li>不要不舍得为电源花钱，多花100块钱有时就能拯救你好几块儿机械硬盘。</li>
<li>功率选择不要看厂家标多少瓦，主要看+12V，把显卡和CPU满载功耗加起来还有几十瓦余量就够了。</li>
<li>80PLUS金银铜牌认证仅代表电源转化效率，高转化率更加省电，但是不能完全评判电源的好坏。</li>
<li>建议购买使用 LLC半桥+ DC-DC方案，使用日系、台系电容的电源。</li>
<li>尽量购买大品牌的电源，虽然贵一点点，安全有保障，不至于翻车烧坏主板。</li>
</ol>
<p><a href="http://www.huntkey.com.cn/service/calculator.html" target="_blank" rel="noopener">航嘉电源功率计算器</a>：航嘉电源功率计算器 输入你要买的主板、CPU、显卡型号 它就会自动计算出你电源的待机功率和最大功耗，然后推荐出适合你的电源型号</p>
</blockquote>
<h1 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h1><p>　　如果电脑散热不良，CPU的温度过高，CPU为了保护自己不被烧坏，首先会自动降低频率来减少发热，这会导致电脑性能下降，其次降频之后如果温度还是过高，CPU就会自动触发电脑死机来保护自己。所以保证良好的散热还是很有必要的。</p>
<h2 id="散热器的工作原理"><a href="#散热器的工作原理" class="headerlink" title="散热器的工作原理"></a>散热器的工作原理</h2><p>传热底座与CPU紧密接触，通过导热装置，将CPU产生的热量传导至散热鳍片，然后由风扇吹走鳍片上的热量。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115100121446-1174300693.png" alt></p>
<p>导热装置有三种</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115100200434-70980180.png" alt></p>
<p>①<strong>纯铜（纯铝）导热</strong>：这种方式导热效率比较低，但是结构简单，价格便宜，很多<strong>原装散热器都是这种方式</strong>。</p>
<p>②<strong>导热铜管</strong>：这是现在最常用的方式，它的铜管是<strong>中空的，里面注有一种导热液</strong>，温度升高时铜管底部的液体蒸发吸收热量，将热量传递给散热鳍片后温度降低凝结成液体，流回铜管底部，如此循环，<strong>导热效率很高。所以现在的大部分散热器都是这种方式</strong>。</p>
<p>③<strong>水冷散热</strong>：严格来说它并不是水，是一种导热率很高的液体。它是通过水将CPU的热量带走，然后高温的水在通过曲曲折折的冷排（结构跟家里的暖气片差不多）的时候被风扇吹走热量，变为凉水再次循环。</p>
<h2 id="影响散热效果的因素（风冷）"><a href="#影响散热效果的因素（风冷）" class="headerlink" title="影响散热效果的因素（风冷）"></a>影响散热效果的因素（风冷）</h2><p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115100433217-1131807579.png" alt></p>
<h2 id="热量传递的效率"><a href="#热量传递的效率" class="headerlink" title="热量传递的效率"></a>热量传递的效率</h2><p>热量的传递效率是散热的关键，影响热量传递效率的因素有以下4点。</p>
<h3 id="热管的数量以及粗细"><a href="#热管的数量以及粗细" class="headerlink" title="热管的数量以及粗细"></a>热管的数量以及粗细</h3><p>热管根数越多越好，一般2根凑合，4根够用，6根及以上就是高端散热器了；热管越粗越好（大部分为6mm,也有8mm的）。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115100544006-1531324743.png" alt></p>
<h3 id="传热底座的工艺："><a href="#传热底座的工艺：" class="headerlink" title="传热底座的工艺："></a>传热底座的工艺：</h3><p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115100626116-53643246.png" alt></p>
<p>①<strong>热管直触</strong>：这种方案的底座非常普遍，一般的百元及以下散热器都是这种的。这种方案为了保证与CPU接触面的平整，会把铜管拍扁、打磨，这使得本来就很薄的铜管更薄了，<strong>时间久了就会出现凹凸不平的现象</strong>，影响导热效率。正规大厂都会把铜管打磨的非常平整，这样就与CPU的接触面积更大，导热效率高。一些山寨厂家的铜管凹凸不平，导致有些铜管工作时根本接触不到CPU，所以再多铜管也只是花架子。</p>
<p>②<strong>铜底焊接（镜面打磨）</strong>：这种方案的底座价格<strong>稍微贵</strong>一些，因为把传热底座直接做成镜面，接触面积更高，导热效果也更好。所以<strong>中高端的风冷散热器</strong>都是用这种方案。</p>
<p>③<strong>均热板</strong>：这是一种很少很少见到的方案，<strong>原理类似于热管</strong>，也是通过液体遇热蒸发，然后遇冷液化来传递热量，这种方案导<strong>热均匀效率高，但是成本很高</strong>，所以很少见。</p>
<h3 id="导热硅脂"><a href="#导热硅脂" class="headerlink" title="导热硅脂"></a>导热硅脂</h3><p>　　由于制造工艺问题，散热器底座与CPU之间不可能有完全平整的接触面（即使你看上去很平整，但是在放大镜下是能看到凹凸不平的），所以就需要涂一层导热系数较高的硅脂来填补这些凹凸不平的地方帮助导热。硅脂的导热系数比铜低很多，所以只要均匀的涂上薄薄的一层就好了，如果涂太厚，反倒影响散热了。一般好的硅脂的导热系数在5-8之间，也有非常昂贵的导热系数在10-15。</p>
<h3 id="散热鳍片与热管交接处的工艺"><a href="#散热鳍片与热管交接处的工艺" class="headerlink" title="散热鳍片与热管交接处的工艺"></a>散热鳍片与热管交接处的工艺</h3><p>热管是穿插在鳍片之间的，要把热量传递到鳍片上，所以他们交接地方的处理工艺也会影响导热性，目前的处理工艺有两种</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101011458-796024594.png" alt></p>
<p>①回流焊：顾名思义就是将两者焊接到一起。这种方案成本较高，但是导热性能好，而且很牢固，不容易出现鳍片松动的现象。</p>
<p>②穿fin：也叫“穿片”工艺。顾名思义就是在鳍片上开孔，然后借助外力将导热铜管插进鳍片里。这种工艺成本较低，虽然简单，但是要想做好却并不容易，因为要考虑接触不良、鳍片松动等问题（如果你随手一拨，鳍片就在热管上滑动，导热效果可想而知了）。</p>
<h3 id="鳍片与空气的接触面积大小"><a href="#鳍片与空气的接触面积大小" class="headerlink" title="鳍片与空气的接触面积大小"></a>鳍片与空气的接触面积大小</h3><p>鳍片承担着散热的重任，<strong>它的任务是将热管送来的热量散发到空气中，所以鳍片必须尽可能多的与空气进行接触</strong>，有些厂家会细心的设计一些凸点来尽可能大的增加鳍片的表面积。</p>
<h3 id="风量"><a href="#风量" class="headerlink" title="风量"></a>风量</h3><p><strong>风量表示每分钟风扇能送出风的总体积，一般用CFM表示</strong>。风量越大，散热也就越好。关于风扇的参数还有：转速、风压、扇叶尺寸、噪音等。现在大多数风扇都支持PWM智能调速，<strong>我们需要关注的也就是风量、噪音等</strong>。</p>
<h2 id="风冷散热器的类型"><a href="#风冷散热器的类型" class="headerlink" title="风冷散热器的类型"></a>风冷散热器的类型</h2><p>风冷散热器有三种类型：被动式散热（无风扇设计）、塔式、下压式。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101232477-2103575610.png" alt></p>
<p>1、<strong>被动式散热</strong>：它其实就是一个无风扇版的散热器，全靠空气流通带走鳍片上的热量。</p>
<ul>
<li>优点：完全没有噪音。</li>
<li>缺点：散热性能差，适合发热量特别小的平台（我们的手机几乎都是被动式散热，甚至不如被动式散热）。</li>
</ul>
<p>2、<strong>下压式散热</strong>：这种散热器风扇是朝下吹的，所以在兼顾CPU散热的同时也可以惠顾到主板和内存条散热。但是散热效果稍差，而且会扰乱机箱风道，所以适合发热小的平台，同时由于体积小不占空间，所以是小机箱的福音。</p>
<p>3、<strong>塔式散热</strong>：这种散热器高高耸立如高塔一般，故名塔式散热。这种散热器单向吹风，不会扰乱风道，而且鳍片和风扇可以做的比较大，因此散热性能最好。但是不能兼顾主板和内存散热，因此需要机箱上的风扇辅助才行。</p>
<h2 id="关于品牌-3"><a href="#关于品牌-3" class="headerlink" title="关于品牌"></a>关于品牌</h2><p><strong>猫头鹰</strong>：来自奥地利的品牌，猫头鹰主要以静音风扇久负盛名。<strong>猫头鹰的散热器最主要的特点是静音，而且设计绝对没有光污染，坚持使用回流焊工艺，但是价格昂贵</strong>。如果只是追求静音，可以买稍微便宜的型号，但如果还想要一个不错的散热效果，那就只能放血了。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101608849-1079651925.png" alt></p>
<p><strong>大镰刀</strong>：日本品牌，镰刀的散热器<strong>做工优秀，设计很人性化</strong>，扭曲式铜管设计可以避开内存条，所以<strong>不挡内存条</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101656393-388689453.png" alt></p>
<p><strong>利民</strong>：中国台湾品牌，利民的散热器主要还是<strong>面对高端的超频用户</strong>，</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101730429-670483489.png" alt></p>
<p><strong>九州风神</strong>：国内品牌，九州风神最出名的就是玄冰400和大塔霜了。但是<strong>99元的玄冰400不推荐</strong>，因为特别难安装。229元的6热管的大塔霜性价比非常高，但是可能会出现挡一根内存的情况。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101826510-295289614.png" alt></p>
<p><strong>酷冷至尊</strong>：台湾品牌，129元的T400，4热管，安装方便，比玄冰400要好，<strong>适合绝大多数人的装机需求</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101832099-717743911.png" alt></p>
<p>ID-COOLING：深圳品牌，产品<strong>设计很棒</strong>，而且<strong>性价比高</strong>。<strong>主力产品是下压式散热器</strong>，ITX机箱用户可以选择199元的IS-VC45，采用均热板设计，厚度仅为45mm；159元的is-60，采用6热管设计，也是一款性价比很高的产品。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101838051-557647675.png" alt></p>
<p><strong>超频三</strong>：深圳品牌，超频三的散热器<strong>性价比很高</strong>，最出名的就是红海mini了，不到40元的售价，2热管设计，不玩游戏的话足够了。东海X5和东海X6也都是很有性价比的选择。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115101845293-427766019.png" alt></p>
<blockquote>
<p>总结：</p>
<ol>
<li>虽然热管数量很重要，但是吸热底座做工必须要足够好才行，如果做工不平整，再多的热管都没用，因此散热器拼的更多是做工。</li>
<li>普通的i3、i5后面不带K的CPU和锐龙不带X的CPU，如i3 8100、i5 8500、锐龙1500 1600等选择4热管的散热器就足够了，比如99元的大镰刀STB120或双风扇的STB120 plus都能轻松应对。</li>
<li>i3 i5 i7后面带K的CPU和锐龙带X的CPU，如i3-8350k、i5 8600k、i7 8700K、锐龙1600X等选择6热管就可以了，如大镰刀的千石船、九州风神的大塔霜、利民的TS140P等。</li>
<li>选择散热器的时候一定要注意:①机箱限高和散热器的大小；②挡不挡内存条；③支不支持你的主板平台（大部分散热器都支持英特尔和AMD多平台）。</li>
<li>硅脂也很重要，尽量选择导热系数在5以上的硅脂。这东西很便宜，确是散热很重要的一环，均匀的涂上薄薄的一层就可以了。</li>
<li>不要迷信水冷。风冷才是最安全，最具性价比的选择。</li>
</ol>
</blockquote>
<h1 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h1><p>不要以为显示器不重要，显示器总结影响用户体验呀，</p>
<p><strong>主要参数</strong>：色域(能显示的色彩范围)、色深(bit)(色彩的精细程度)、色差(色彩还原的准确性)、对比度(对比度越高，越清晰)、分辨率(表示图像的清晰程度)、刷新率Hz(表示显示器1秒能刷新多少帧)、灰阶响应时间(画面延迟)</p>
<h2 id="显示器接口"><a href="#显示器接口" class="headerlink" title="显示器接口"></a>显示器接口</h2><p><strong>DVI：只支持视频</strong></p>
<p>DVI接口有两个标准，25针和29针，如下图所示。直观来说，这两种接口没有区别。DVI接口传输的是数字信号，可以传输大分辨率的视频信号。DVI连接计算机显卡和显示器时不用发生转换，所以<strong>信号没有损失</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191124210206619-1900508646.png" alt></p>
<p><strong>VGA：只支持视频</strong></p>
<p>针数为15的视频接口，主要用于老式的电脑输出。VGA输出和传递的是模拟信号。大家都知道计算机显卡产生的是数字信号，显示器使用的也是数字信号。所以使用VGA的视频接口相当于是经历了一个数模转换和一次模数转换。信号损失，<strong>显示较为模糊</strong></p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191124210233217-1469606628.png" alt></p>
<p><strong>HDMI接口 支持音视频</strong></p>
<p>HDMI既能传输高清图形画面信号，也能够传输音频信号，一般来说家里会接电视，而且抗干扰强。如数码相机的体积小，需要小的接口，可以使用micro HDMI。</p>
<p> <img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191124210950851-885396265.png" alt></p>
<p><strong>DP接口 支持音视频</strong></p>
<p>DP即DisplayPort，是一种高清数字显示接口标准，可以连接电脑和显示器，也可以连接连接电脑和家庭影院。DP接口可以理解是HDMI的加强版，在音频和视频传输方面更加强悍。目前情况下，DP与HDMI在性能上没有多大区别。如果你使用3840*2160分辨率（4K），HDMI由于带宽不足，最大只能传送30帧，DP就没有问题。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191124210726379-1756265637.png" alt> <img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191124210756518-1111947114.png" alt></p>
<p><strong>VGA和DVI互转</strong>：模拟信号和数字信号的转换，视频信号损失，造成失真。最好不要这样转换。</p>
<p><strong>DVI和HDMI互转</strong>：都是数字信号，转换不会发生是真。可以转换。但是从HDMI转换成DVI时会自动舍去音频信号。</p>
<h2 id="液晶面板"><a href="#液晶面板" class="headerlink" title="液晶面板"></a>液晶面板</h2><h3 id="TN面板"><a href="#TN面板" class="headerlink" title="TN面板"></a>TN面板</h3><p>TN面板的优点是：液晶分子偏转速度非常快，所以<strong>灰阶响应时间很短</strong>。<strong>缺点是：色域窄，色彩差，画面色彩苍白，可视角度很小</strong>，有条件的可以用手机屏幕对比一下老式的便宜的笔记本电脑屏幕。这种屏幕本来快被市场淘汰了，但是随着电竞的火热，<strong>TN面板借着刷新率高，灰阶响应时间短的优点又重新回到市场</strong>，散发第二春。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115104255253-388030584.png" alt></p>
<h3 id="IPS面板"><a href="#IPS面板" class="headerlink" title="IPS面板"></a>IPS面板</h3><p>IPS面板的优点：<strong>色彩显示效果好，可视角度大</strong>，色彩准。缺点是：<strong>容易漏光，黑色不够纯正</strong>。这类显示器由于色彩好，可视角度大，所以也是现在应用最广的显示器面板。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115104313254-1880343116.png" alt></p>
<h3 id="VA面板"><a href="#VA面板" class="headerlink" title="VA面板"></a>VA面板</h3><p>VA面板有两种：MVA面板和PVA面板，PVA是三星改良的MVA面板。这类面板算是TN面板和IPS的折中方案，<strong>优点是色彩准确，对比度高，可视角度较大，漏光少，黑色纯正。缺点是响应时间比IPS还要长。</strong></p>
<h3 id="PLS面板"><a href="#PLS面板" class="headerlink" title="PLS面板"></a>PLS面板</h3><p>PLS面板是三星独家研制的面板，<strong>类似IPS面板</strong>。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115104424880-2089323325.png" alt></p>
<h2 id="带鱼屏"><a href="#带鱼屏" class="headerlink" title="带鱼屏"></a>带鱼屏</h2><p>带鱼屏指屏幕比列为21：9或以上的显示器，特点是非常的长，跟带鱼一样，所以被调侃为“带鱼屏”。这种屏幕由于较长，所以一屏能显示更多的内容。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115104828033-2044685536.png" alt></p>
<p><strong>优点：</strong></p>
<p>1.多开网页或者软件、游戏时，<strong>同屏能显示更多的内容，因此很适合用来工作</strong>。</p>
<p>2.<strong>如果能找到21：9的电影片源，看电影会非常爽</strong>。（<strong>这种片源很少</strong>）</p>
<p>3.支持市面主流网络和单机游戏。LOL和绝地求生、cs go等都<strong>能有效扩宽左右视野</strong>。</p>
<p><strong>缺点：</strong></p>
<p>1.由于直播、电视剧、综艺节目等片源大多是传统的16：9的，所以看这些内容，屏幕两边会有很宽的黑边。</p>
<p>2.由于分辨率高，所以玩游戏时<strong>对显卡要求更高</strong>。</p>
<p>3.虽然<strong>视野变宽了，但是左右看时需要左右扭头，累脖子</strong>，适合单机游戏娱乐，不适合电竞。</p>
<p><img src="https://img2018.cnblogs.com/i1/1433301/201911/1433301-20191115104921450-1494442067.png" alt></p>
<p>所以，对于有多开需求的用户来说，带鱼屏或许是个能提高效率的选择。</p>
<blockquote>
<p>总结：</p>
<ol>
<li>144hz/1ms的电竞显示器对<strong>CF、CS GO、绝地求生、守望先锋等PFS射击游戏来说</strong>，效果区别非常大，<strong>是那种用了之后眼睛就再也受不了60hz显示器的那种，当然前提是你的显卡得支持这么高的帧数</strong>。</li>
<li><strong>一两千块钱的144hz/1ms电竞显示器都是TN面板的屏幕，色彩会很差</strong>，四五千的会好一些，但色彩依然比不过2千块的IPS。</li>
<li><strong>IPS屏幕色彩很好，可视角度也很大，但漏光是IPS的通病</strong>，你买到的显示器漏光严重与否，很大程度看运气。而且轻微漏光日常使用看不出区别，所以不用太纠结。</li>
<li>普通玩家选择IPS或者三星VA面板的显示器就够了，<strong>不是PFS射击类游戏玩家不用盲目追求144hz/1ms，效果不明显</strong>。</li>
<li>带鱼屏细长，能同时显示多个窗口，<strong>对于多开多任务需求的用户来说帮助很大。游戏时虽然能提供更宽的视野，但是需要左右扭头，累脖子，适合单机游戏娱乐，不适合电竞</strong>。</li>
</ol>
</blockquote>
<h1 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h1><p>散热器的选择也应该挑有品牌保障的产品，切勿贪图便宜，品牌产品不仅有售后保障，而且在设计时为了品牌发展也会下较大的成本，而非品牌产品则更加注重于散热器的外观，实际的散热性能会因为压缩成本而大打折扣。</p>
<h1 id="搭配选择"><a href="#搭配选择" class="headerlink" title="搭配选择"></a>搭配选择</h1><p>家用：对配置要求不高，看电影、上上网之类的，选择入门级CPU和显卡即可</p>
<p>打游戏：看游戏此配置情况选择显卡，游戏对显卡要求特别高，同时对CPU也有一定的要求。</p>
<p>办公：办公时常需要多线程切换，因此选择一款多线程处理能力好的CPU，</p>
<p>特殊领域：比如工程绘图或者图形渲染，深度学习等等，建议CPU和显卡都买比较好的</p>
<p>参考来自中关村：<a href="http://www.zol.com.cn/" target="_blank" rel="noopener">http://www.zol.com.cn/</a></p>
<p>推荐两个个自助装机的网站<a href="http://www.pc028.com/diy.php" target="_blank" rel="noopener">http://www.pc028.com/diy.php</a>和<a href="http://mydiy.pconline.com.cn/" target="_blank" rel="noopener">http://mydiy.pconline.com.cn/</a>，用户可以根据自己需要选择配置，而且会标出价格，配完之后可以在线咨询客服，更方面用户进行选择。</p>
<p> <a href="https://www.cnblogs.com/fjfsu/p/10945866.html" target="_blank" rel="noopener">https://www.cnblogs.com/fjfsu/p/10945866.html</a></p>
<h1 id="如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？"><a href="#如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？" class="headerlink" title="如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？"></a>如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？</h1><p><strong>可以买二手的电脑硬件部分</strong></p>
<p><strong>处理器(CPU)</strong>：处理器做工非常精细，一般都是在机箱内部，多层维护，轻易是不会损坏的，除非是人为把针脚搞坏或者是其它损坏，如果CPU正常点亮的话，买二手的话，是可以的。</p>
<p><strong>内存条</strong>：内存条也是如此，做工都是非常精细的，也是在机箱内部，不是人为损坏的话，除非你用力掰扯损坏或者是其它损坏。一般情况下正常用，买二手的都是没有问题的。</p>
<p><strong>机箱</strong>：机箱对电脑的整体性能不大，只要能保证完整，可以用，那么机箱可以考虑买二手的。</p>
<p><strong>显示器</strong>：显示器新的和旧的差别不太大，显示器保证正常，买二手的对于使用者来说完全没有问题。</p>
<p><strong>不可以买二手的电脑硬件部分</strong></p>
<p><strong>显卡(GPU)</strong>：显卡的性能和使用的程度是密切相关的，尤其是别人挖矿的显卡，长时间负载，元器件极易容易老化，影响较大，所以显卡最好买新的。</p>
<p><strong>主板</strong>：主板上的电容 ，接口，线路较多，很容易损坏，旧的很容易老化有问题，建议买新的。</p>
<p><strong>硬盘</strong>：无论是机械硬盘还是固态硬盘，它们都有一定的使用寿命与做擦写次数的问题，建议大家硬盘要买新的。</p>
<p><strong>电源</strong>：电源是维持电脑稳定工作的必备之一，二手电源会有一定的老化损耗，电压容易不稳定，建议买新的而且要买额定功率大的电源，用来保证电脑正常工作。</p>
<p><strong>散热器</strong>：二手的很多都是没有经过保养的，二手散热器经过长时间的使用会有磨损，使用时有明显的噪音，散热对电脑散热方面也是一个不可忽视的部分，所以建议大家散热，也要买新的。散热器的选择也应该挑有品牌保障的产品，切勿贪图便宜，品牌产品不仅有售后保障，而且在设计时为了品牌发展也会下较大的成本，而非品牌产品则更加注重于散热器的外观，实际的散热性能会因为压缩成本而大打折扣。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><p>哔哩哔哩 古宇胡：<a href="https://www.bilibili.com/video/av65451124/?spm_id_from=trigger_reload" target="_blank" rel="noopener">https://www.bilibili.com/video/av65451124/?spm_id_from=trigger_reload</a></p>
<p>哔哩哔哩 显卡吧DIY电脑团：<a href="https://www.bilibili.com/video/av68260293" target="_blank" rel="noopener">https://www.bilibili.com/video/av68260293</a></p>
<p>B站UP主“<a href="https://space.bilibili.com/54245027/article" target="_blank" rel="noopener">斜耳朵</a>”的专栏（强烈建议大家可以关注他，很多内容转载他的文章，对本文帮助很大）</p>
<p>J.Feng 博客园博客——<a href="https://www.cnblogs.com/fjfsu/p/10945866.html" target="_blank" rel="noopener">电脑组装知识</a></p>
<h2 id="组装电脑"><a href="#组装电脑" class="headerlink" title="组装电脑"></a>组装电脑</h2><p><a href="https://www.cnblogs.com/dolphin0520/archive/2013/01/17/2861164.html" target="_blank" rel="noopener">Matrix海 子的博客园——如何组装配置属于自己的台式机</a></p>
<p><a href="https://blog.csdn.net/billycoder/article/details/88987010" target="_blank" rel="noopener">CSDN博客——组装电脑的超详细步骤超级多图</a></p>
<p><a href="https://blog.csdn.net/ifisher999/article/details/79620310" target="_blank" rel="noopener">CSDN博客——组装深度学习电脑</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIzNjc1NzUzMw==&amp;mid=2247510319&amp;idx=1&amp;sn=db8db4cc6d329ce0bfcf3d52721b7596&amp;chksm=e8d01e5ddfa7974b30ed0b012140997dd8696f2fbad73c23cd0a583a22fc0c49d31858008f22&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">量子位的公众号文章——深度学习装机指南</a></p>
<p>作者：凌逆战</p>
<p>原文链接：<a href="https://www.cnblogs.com/LXP-Never/p/11607551.html" title="view: 电脑组装之硬件选择" target="_blank" rel="noopener">https://www.cnblogs.com/LXP-Never/p/11607551.html</a></p>
]]></content>
      <categories>
        <category>知识百科</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 054 Spiral Matrix</title>
    <url>/posts/57431/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定m x n的矩阵，按照螺旋的顺序返回所有元素。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>cc表示螺旋总的环数，i表示当前的环数，p为当前环的宽度，q为当前环的高度。</p>
<p>对每个环按顺序遍历四条边，当p或q为1时，表示最后一环只有一行或者一列，可以跳出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> c = Math.min((m+<span class="number">1</span>)/<span class="number">2</span>,(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> p = m, q = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++,p-=<span class="number">2</span>,q-=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=i;col&lt;i+q;col++)&#123;</span><br><span class="line">                res.add(matrix[i][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=i+<span class="number">1</span>;row&lt;i+p;row++)&#123;</span><br><span class="line">                res.add(matrix[row][i+q-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p==<span class="number">1</span>||q==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=i+q-<span class="number">2</span>;col&gt;=i;col--)&#123;</span><br><span class="line">                res.add(matrix[i+p-<span class="number">1</span>][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=i+p-<span class="number">2</span>;row&gt;i;row--)&#123;</span><br><span class="line">                res.add(matrix[row][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>注意四条边对变化，上边是up初始化0，下边down初始化m-1，左边left初始化0，右边right初始化n-1。</p>
<p>进行while循环，先遍历上边，结束后将上边加1，若上边大于下边说明遍历结束。其他边同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, down = m-<span class="number">1</span>, left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) res.add(matrix[up][i]);</span><br><span class="line">            <span class="keyword">if</span>(++up&gt;down) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=up;i&lt;=down;i++) res.add(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span>(--right&lt;left) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--) res.add(matrix[down][i]);</span><br><span class="line">            <span class="keyword">if</span>(--down&lt;up) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=down;i&gt;=up;i--) res.add(matrix[i][left]);</span><br><span class="line">            <span class="keyword">if</span>(++left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 053 Maximum Subarray</title>
    <url>/posts/54807/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure>
<p><strong>Follow Up:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个数字数组，找出一个连续都子数组，其所有数之和最大，并返回这个和。</p>
<p>如果已经找到来复杂度为O(n)的解法，可以试试分治的思路。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>定义两个变量res、curr，res表示最大子数组的和，curr表示当前子数组的和并初始化为0。</p>
<p>遍历数组，若curr+num比num大，说明当前curr是正数，那么肯定是新子数组肯定是要继续在之前大基础上往后扩展。</p>
<p>一旦curr是负数或者0，那么之前的都可以抛弃因为不能使新子数组之和变大。</p>
<p>所以curr取curr+num和num中大的数，再用curr去更新保存起来的最大和res。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            curr = Math.max(curr+num,num);</span><br><span class="line">            res = Math.max(res,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上道解法的另一种写法，通俗易懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            curr+=num;</span><br><span class="line">            <span class="keyword">if</span>(curr&gt;res) res=curr;</span><br><span class="line">            <span class="keyword">if</span>(curr&lt;<span class="number">0</span>) curr=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-divide-and-conquer</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 052 N-Queens II</title>
    <url>/posts/23032/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png" alt="pic"></p>
<p>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  // Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>N皇后问题，将n个皇后放在nxn的棋盘上，保证任意两个皇后不能相互攻击。</p>
<p>给定正整数n，求不重复的N皇后问题答案的个数。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>这道题和上一题一样，只需要返回结果数量更加简单，可以用上一题的解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                board[i][j]=<span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        helper(res,board,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;String&gt;&gt; res,<span class="keyword">char</span>[][] board,<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==board.length)&#123;</span><br><span class="line">            res.add(convert(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;board.length;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(board, row, col))&#123;</span><br><span class="line">                board[row][col]=<span class="string">'Q'</span>;</span><br><span class="line">                helper(res,board,row+<span class="number">1</span>);</span><br><span class="line">                board[row][col]=<span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==row||j==col||i-row==j-col||i-row==col-j)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">convert</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            String row = <span class="keyword">new</span> String(board[i]);</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>我们并不需要知道每一行皇后的具体位置，而只需要知道会不会产生冲突即可。</p>
<p>对于每行要新加的位置，需要看跟之前的列，对角线，及逆对角线之间是否有冲突。</p>
<p>同一条对角线上的点，其横坐标减纵坐标都相等（要保证数组边界）。同一条逆对角线，其横坐标加纵坐标都相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] cols;</span><br><span class="line">    <span class="keyword">boolean</span>[] posDiag;</span><br><span class="line">    <span class="keyword">boolean</span>[] negDiag;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        posDiag = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">        negDiag = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">        dfs(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(row,col,n))&#123;</span><br><span class="line">                update(row,col,n,<span class="keyword">true</span>);</span><br><span class="line">                dfs(row+<span class="number">1</span>,n);</span><br><span class="line">                update(row,col,n,<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n, <span class="keyword">boolean</span> used)</span></span>&#123;</span><br><span class="line">        cols[col]=used;</span><br><span class="line">        posDiag[row+col]=used;</span><br><span class="line">        negDiag[row-col+n-<span class="number">1</span>]=used;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !cols[col] &amp;&amp; !posDiag[row+col] &amp;&amp; !negDiag[row-col+n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 051 N-Queens</title>
    <url>/posts/55521/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png" alt="pic"></p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [</span><br><span class="line"> [&quot;.Q..&quot;,  // Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>N皇后问题，将n个皇后放在nxn的棋盘上，保证任意两个皇后不能相互攻击。</p>
<p>国际象棋中，皇后不仅能横竖走，还能走两个斜线。诞生八皇后问题，在一个8x8的棋盘上才能放8个皇后，保证不能相互攻击，即不能处于同一横线、竖线、斜线上。</p>
<p>给定正整数n，求不重复的N皇后问题答案。’Q’,’.’分别表示棋盘上的皇后和空格。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用递归列出所有符合条件的棋盘，从第0列开始，每列最多只能放一个皇后。</p>
<p>在第colIndex列，从每一行选择一个点进行检查，看如果在这一行及colIndex列的位置上放入皇后，棋盘是否还是有效。</p>
<p>若有效，则将这一点先置成’Q’，然后往下一列进行递归，递归后再将这一点还原便于其他行判断。直到检查超出棋盘最后一列，则说明已经全部放置完毕，将棋盘格式化后加入结果集。</p>
<p>对棋盘是否有效对判断方法是，因为用列递归，所以只用判断棋盘已有对皇后是否和新对皇后处于同一行或同一对角线上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                board[i][j]=<span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        dfs(board,<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> colIndex, List&lt;List&lt;String&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(colIndex==board.length)&#123;</span><br><span class="line">            res.add(construct(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(validate(board,i,colIndex))&#123;</span><br><span class="line">                board[i][colIndex]=<span class="string">'Q'</span>;</span><br><span class="line">                dfs(board,colIndex+<span class="number">1</span>,res);</span><br><span class="line">                board[i][colIndex]=<span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>&amp;&amp;(i==row||row-i==col-j||i-row==col-j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(board[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 050 Pow(x, n)</title>
    <url>/posts/46336/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Implement pow(x, n), which calculates x raised to the power n (xn).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n is a 32-bit signed integer, within the range [−231, 231 − 1]</li>
</ul>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求x的n次方，x范围是(-100.0, 100.0)，n是32位有符号整数其范围是[−231, 231 − 1]</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>采用递归来折半计算，每次把n除2来计算myPow(x,n/2)，最终第二个参数指数会变成0。</p>
<ul>
<li>若n为0，则返回1</li>
<li>若n为偶数，那么直接返回折半的结果的平方</li>
<li>若n为正的奇数，那么在折半结果平方的基础上再乘以x</li>
<li>若n为负的负数，那么在折半结果平方的基础上再除以x</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> half*half;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>) <span class="keyword">return</span> half*half*x;</span><br><span class="line">        <span class="keyword">return</span> half*half/x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用迭代去完成，在n折半时将x进行平方。i初始化为n，当i时2当倍数时，将x平方；否则res先乘以x，x再平方，然后i折半。</p>
<p>最后若n为整数，则直接返回结果res，若n为负数，则用返回1/res。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i!=<span class="number">0</span>;i/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>) res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span>?res:<span class="number">1</span>/res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>也可以将n先转成正数再折半，但是要注意n为Integer.MIN_VALUE的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==Integer.MIN_VALUE)&#123;</span><br><span class="line">            x=x*x;</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            n=-n;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">2</span>==<span class="number">0</span>)?myPow(x*x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 049 Group Anagrams</title>
    <url>/posts/4255/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of strings, group anagrams together.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一组字符串，按字谜（颠倒字母而成的字）分组。所有输入为小写，结果顺序不要求。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>对每个字符串统计其每个字母出现对次数，用int[26]表示，下标对应字母，值对应出现对个数，并将统计信息转化成字符串。</p>
<p>保存一个HashMap，key是统计信息字符串，value是一组的字符串，用上述结果去更新Map，最终返回Map中所有Value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; res = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:str.toCharArray())&#123;</span><br><span class="line">                count[c-<span class="string">'a'</span>]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.length;i++)&#123;</span><br><span class="line">                sb.append(<span class="string">'a'</span>+i).append(count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.containsKey(sb.toString()))&#123;</span><br><span class="line">                res.get(sb.toString()).add(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt; group = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                group.add(str);</span><br><span class="line">                res.put(sb.toString(),group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>对每个字符串对应对char[]进行排序，然后再将char[]转成String。</p>
<p>建立一个Map，其key是上述新生成对String，value是一组字谜对字符串数组，最后返回Map中所有value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; res = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            String key = <span class="keyword">new</span> String(chars);</span><br><span class="line">            <span class="keyword">if</span>(!res.containsKey(key)) res.put(key,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            res.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 048 Rotate Image</title>
    <url>/posts/41135/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p><strong>Note:</strong></p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个n x n的二维矩阵表示一张图片，将图片顺时针旋转90度。要求直接修改二维矩阵，不允许使用额外的二维矩阵去做旋转。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>可以一层层从最外层到最内层进行旋转，递归调用直到到达最内层。</p>
<p>例如在最外层level为0，则要调整的起始位置为matrix[level][level]到matrix[level][len-level-1]。</p>
<p>从这几个点出发，旋转一周即调整4条边上的值即可。针对当前点matrix[row][col]，其应该调整到matrix[col][len-row-1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">        helper(matrix,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> len, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;=len/<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=level;i&lt;len-level-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr=matrix[level][i];</span><br><span class="line">            <span class="keyword">int</span> nextRow=i, nextCol=len-level-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> next = matrix[nextRow][nextCol];</span><br><span class="line">                matrix[nextRow][nextCol]=curr;</span><br><span class="line">                curr=next;</span><br><span class="line">                <span class="keyword">int</span> tmp=nextRow;</span><br><span class="line">                nextRow=nextCol;</span><br><span class="line">                nextCol=len-tmp-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(matrix,len,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>不用递归，直接在一个方法中完成，i为行数，j为列数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  3                 7  2  1                 7  4  1</span><br><span class="line"></span><br><span class="line">4  5  6      --&gt;        4  5  6      --&gt;        8  5  2　　</span><br><span class="line"></span><br><span class="line">7  8  9                 9  8  3　　　            9  6  3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[n-j-<span class="number">1</span>][i];</span><br><span class="line">                matrix[n-j-<span class="number">1</span>][i]=matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>];</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>]=matrix[j][n-i-<span class="number">1</span>];</span><br><span class="line">                matrix[j][n-i-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>先将矩阵以对角线为轴翻转，在以x轴中线上下翻转即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  3　　　 　　 9  6  3　　　　　   7  4  1</span><br><span class="line"></span><br><span class="line">4  5  6　　--&gt;　　 8  5  2　　 --&gt;    8  5  2</span><br><span class="line"></span><br><span class="line">7  8  9 　　　 　　7  4  1　　　　　   9  6  3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[n-j-<span class="number">1</span>][n-i-<span class="number">1</span>];</span><br><span class="line">                matrix[n-j-<span class="number">1</span>][n-i-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[n-i-<span class="number">1</span>][j];</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][j]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>先将矩阵转置，再对每一行进行翻转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  3　　　 　　 1  4  7　　　　　    7  4  1</span><br><span class="line"></span><br><span class="line">4  5  6　　--&gt;　　 2  5  8　　 --&gt;  　 8  5  2　　</span><br><span class="line"></span><br><span class="line">7  8  9 　　　 　　3  6  9            9  6  3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[i][n-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][n-j-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 047 Permutations II</title>
    <url>/posts/30253/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一组可能包含重复数字的集合，返回所以不重复的全排列。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>笨办法，用Set对结果进行去重。把nums中的数字一个一个添加进结果集，注意当添加一个数字时有多个地方可以插入。</p>
<p>如已有[1,2]，那么3可以放在[3,1,2],[1,3,2],[1,2,3]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> HashSet&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; start = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        start.add(nums[<span class="number">0</span>]);</span><br><span class="line">        res.add(start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            Set&lt;List&lt;Integer&gt;&gt; tmp = <span class="keyword">new</span> HashSet&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt; curr:res)&#123;</span><br><span class="line">                    List&lt;Integer&gt; copy = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr);</span><br><span class="line">                    copy.add(j,nums[i]);</span><br><span class="line">                    tmp.add(copy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>递归，用boolean[]保存某个位置上对数字是否被使用过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(res,nums,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; curr, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]||(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;!used[i-<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            used[i]=<span class="keyword">true</span>;</span><br><span class="line">            helper(res,nums,curr,used);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            used[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 046 Permutations</title>
    <url>/posts/6792/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一系列非重复数字，返回全排列。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用递归，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curr.contains(num)) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(num);</span><br><span class="line">            helper(res,curr,nums);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>笨办法，把nums中的数字一个一个添加进结果集，注意当添加一个数字时有多个地方可以插入。</p>
<p>如已有[1,2]，那么3可以放在[3,1,2],[1,3,2],[1,2,3]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; start = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        start.add(nums[<span class="number">0</span>]);</span><br><span class="line">        res.add(start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; tmp = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt; curr:res)&#123;</span><br><span class="line">                    List&lt;Integer&gt; copy = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr);</span><br><span class="line">                    copy.add(j,nums[i]);</span><br><span class="line">                    tmp.add(copy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 045 Jump Game II</title>
    <url>/posts/28112/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2.</span><br><span class="line">    Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>You can assume that you can always reach the last index.</p>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个正数数组，初始化时指向数组的第一个元素，每个元素的值表示在这个位置上能向前跳的最大长度。</p>
<p>目标是跳动到最后一个元素，并且用到步数最少，并返回最少步数。假定一定能够到达最后一个元素。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用动态规划，令len表示nums第长度，有dp[len]，dp[i]表示从数组第i位跳到数组最后一位所需第最少步数。dp[len-1]=0，因为数组最后一位不需要跳。</p>
<p>从数组第倒数第二位开始往前遍历，取出当前位置i上的数字steps，初始化当前位置i用的最少步数min为int最大值。在位置i上最多有steps中跳法，但同时要保证不会跳出数组边界。</p>
<p>假定从位置i跳j步到位置i+j上，若dp[i+j]不能到达数组末尾即dp[i+j]为int最大值，则j加1。否则此时所用步数为1+dp[i+j]，更新min到值。</p>
<p>所有可能到步数遍历完后，确定位置i对应所需到步数dp[i]。最终结果返回dp[0]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[len-<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> steps=nums[i];</span><br><span class="line">            <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=steps&amp;&amp;i+j&lt;=len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i+j]==Integer.MAX_VALUE) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> curr = <span class="number">1</span> + dp[i+j];</span><br><span class="line">                min = Math.min(min,curr);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>贪婪算法，jumps代表跳到步数，curEnd表示当前能跳到点的范围是[curBegin, curEnd]，curFarthest表示在[curBegin, curEnd]下一次跳所能到达的最远的点。</p>
<p>遍历数组，i为数组当前所在点，则该点能最远到达的点为i+nums[i]，并据此更新curFarthest。</p>
<p>当i到达curEnd，表示[curBegin, curEnd]所能到达的点都已检查完毕，下次跳最远能跳到curFarthest。</p>
<p>那么将跳一次jumps++，同时此时能跳的最远位置curEnd更新为curFarthest，继续循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jumps=<span class="number">0</span>, curEnd=<span class="number">0</span>, curFarthest=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            curFarthest=Math.max(curFarthest,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i==curEnd)&#123;</span><br><span class="line">                jumps++;</span><br><span class="line">                curEnd=curFarthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 044 Wildcard Matching</title>
    <url>/posts/9565/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure>
<p>The matching should cover the entire input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li>s could be empty and contains only lowercase letters a-z.</li>
<li>p could be empty and contains only lowercase letters a-z, and characters like ? or *.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; matches any sequence.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;cb&quot;</span><br><span class="line">p = &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;acdcb&quot;</span><br><span class="line">p = &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串s和模式p，实现通配符匹配，支持？和<em>。？表示任意一个字符，</em>表示任何字符串。</p>
<p>匹配是完全匹配，s可能为空或者只包含a-z，p可能为空或者包含a-z和？或*。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>进行下列判断：</p>
<ol>
<li>p和s相等或者p为”*”，则直接返回true</li>
<li>p是否为空，若p为空，则直接返回s是否为空</li>
<li>s是否为空，若s为空，则p必须必须全部是*</li>
<li>若p[0]==’?’，则返回递归调用isMatch(s[1:],p[1:])</li>
<li>若p[0]==’*’，则要么星号没匹配上s中任何字符，通过递归调用isMatch(s,p[1:])；否则递归说明星号匹配上了递归调用isMatch(s[1:],p)</li>
<li>若p[0]不为’?’或’*’，比较p[0]==s[0]&amp;&amp;isMatch(s[1:],p[1:])</li>
</ol>
<p>但是这段代码提交时发现超过时间限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.equals(s)||p.equals(<span class="string">"*"</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.isEmpty()) <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(<span class="number">0</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> isMatch(s,p.substring(<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(<span class="number">0</span>)==<span class="string">'?'</span>) <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(<span class="number">0</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n&lt;p.length()&amp;&amp;p.charAt(n)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.substring(n-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(isMatch(s,p.substring(<span class="number">1</span>))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>),p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.charAt(<span class="number">0</span>)==s.charAt(<span class="number">0</span>) &amp;&amp; isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>定义i、j为s和p当前遍历对位置，iStar、jStar为星号出现时在s和p中匹配的最新位置。</p>
<p>进行while循环，条件时i小于s的长度。进行下列判断：</p>
<ol>
<li>若s[i]==p[j]或者p[j]==’?’，则i和j分别加1</li>
<li>若p[j]==’*’，则iStar=i，jStart=j，j++</li>
<li>若当前星号出现即iStar&gt;=0时，p[jStar]可以在s中多向前匹配一位，则i回退到iStart++，j回退到jStar+1</li>
<li>若星号没出现则返回false</li>
</ol>
<p>最后若s已经匹配完，但p还有剩余字符，则要判断p中剩余字符是否都是*</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, iStar=-<span class="number">1</span>, jStar=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;p.length()&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'?'</span>))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;p.length()&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                iStar=i;</span><br><span class="line">                jStar=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(iStar&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                i=++iStar;</span><br><span class="line">                j=jStar+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;p.length()&amp;&amp;p.charAt(j)==<span class="string">'*'</span>) j++;</span><br><span class="line">        <span class="keyword">return</span> j==p.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>使用动态规划，定义dp[m+1][n+1]，dp[i][j]表示s中的前i个字符组成的字符串和p中的前j个字符组成的字符串是否匹配。</p>
<p>初始化dp[0][0]为true，因为s和p都为空时应返回true。还有当s为空，p中都是星号时也返回true。</p>
<p>若p中第j个字符为星号，若星号匹配空串即dp[i][j-1]为true，则d[i][j]也为true；有dp[i-1][j]为true时星号也可再多匹配一个，则dp[i][j]也为true。</p>
<p>若p中第j个字符不为星号，则在直到dp[i-1][j-1]的情况下，看s[i-1]和p[j-1]是否匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=s.length(), n=p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)==<span class="string">'*'</span>) dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i][j-<span class="number">1</span>]||dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">'?'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>同解法1使用递归调用，但同时采用剪枝。递归方法返回但不是boolean而是int，有三种状态。0表示匹配到s到末尾，但是未匹配成功。1表示未匹配到s到末尾就失败了。2表示匹配成功。</p>
<p>若s和p都完成匹配则返回2。若s匹配完成，但p当前字符不是星号则返回0。若s未匹配完而p匹配完，返回1。</p>
<p>若s和p都匹配完成则对下一位字符递归调用。否则若p当前字符为星号，那么先跳过连续的星号，然后分别让星号匹配空串、1个字符、2个字符…</p>
<p>剪枝条件：当返回值为0或者2时，则返回，否则继续遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s, p, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==s.length() &amp;&amp; j==p.length()) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==s.length() &amp;&amp; p.charAt(j)!=<span class="string">'*'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(j==p.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s.length()&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'?'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(s, p, i+<span class="number">1</span>, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;p.length()&amp;&amp;p.charAt(j+<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> helper(s,p,i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s.length()-i;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> res=helper(s,p,i+k,j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(res==<span class="number">0</span>||res==<span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-backtracking</tag>
        <tag>leetcode-greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 043 Multiply Strings</title>
    <url>/posts/15075/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The length of both num1 and num2 is &lt; 110.</li>
<li>Both num1 and num2 contain only digits 0-9.</li>
<li>Both num1 and num2 do not contain any leading zero, except the number 0 itself.</li>
<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>
</ol>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个代表非负num1和num2的字符串，用字符串表示它们的乘积。字符串的长度小于110，只包含0-9。不能将输入转成int进行计算。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>用一个数组pos保存m+n长度的数字，代表每一位上的数字，最后一个数字表示结果的个位。</p>
<p>从字符串num1和num2的右侧开始，提取对应位置上的数字并计算乘积，确定相乘后所影响的pos位置上的数字。</p>
<p>num1[i] * num2[j]将会影响pos[i+j]和pos[i+j+1]上的数字，对其进行更新。</p>
<p>最后遍历pos返回结果字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>)||num2.equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> m=num1.length(), n=num2.length();</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> multiply(num2,num1);</span><br><span class="line">        <span class="keyword">int</span>[] pos=<span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = (num1.charAt(i)-<span class="string">'0'</span>)*(num2.charAt(j)-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">int</span> p1=i+j, p2=i+j+<span class="number">1</span>, sum=tmp+pos[p2];</span><br><span class="line">                pos[p1]+=sum/<span class="number">10</span>;</span><br><span class="line">                pos[p2]=sum%<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;pos[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sb.append(pos[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="string">"0"</span>:sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 042 Trapping Rain Water</title>
    <url>/posts/37397/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="pic"></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>收集雨水，给定n个非负整数代表宽为1不同高度柱子的容器，求它能收集多少雨水。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双指针left和right分别指向最左端和最右端，同时维护maxLeft和maxRight表示左侧和右侧遍历时最大高度。</p>
<p>若当前left的高度较小，则固定住right侧，填充左侧的格子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>,maxLeft=<span class="number">0</span>,maxRight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;=height[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[left]&gt;=maxLeft)&#123;</span><br><span class="line">                    maxLeft=height[left];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=maxLeft-height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right]&gt;maxRight)&#123;</span><br><span class="line">                    maxRight=height[right];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=maxRight-height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>从左侧及右侧更新两边的最大高度maxLeft和maxRight，当maxLeft比maxRight小时，意味着左侧可以存水，值为maxLeft-height[left]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>,maxLeft=<span class="number">0</span>,maxRight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            maxLeft=Math.max(maxLeft,height[left]);</span><br><span class="line">            maxRight=Math.max(maxRight,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(maxLeft&lt;=maxRight)&#123;</span><br><span class="line">                res+=maxLeft-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res+=maxRight-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>每次只处理最左侧left和最右侧right高度较小的一侧，拿出较小的高度去更新当前安全深度level，取其中较大的值。</p>
<p>然后用此level减去当前格子的高度，累加至结果res，同时更新left和right。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>,level=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> lower = height[height[left]&lt;height[right]?left++:right--];</span><br><span class="line">            level = Math.max(level,lower);</span><br><span class="line">            res+=level-lower;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>使用栈，从左到右遍历数组，保存递减的高度到下标。若找到当前格子比栈中最上面的下标对应的高度高，则栈中最顶上的格子就是一个洼地，可以存水。</p>
<p>从栈中弹出这块洼地的下标，用洼地格子的右方和左方的高度较小的一个减去当前格子的高度，累加进结果。相当于这一小块洼地被填平，并不断重复此判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;height.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;height[i]&gt;height[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> bar = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> h = Math.min(height[i],height[stack.peek()]);</span><br><span class="line">                    res+=(i-stack.peek()-<span class="number">1</span>)*(h-height[bar]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 041 First Missing Positive</title>
    <url>/posts/25277/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个未排序的整数数组，找出首个缺失的正数。时间复杂度要求O(n)，空间复杂度为O(1)。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>不能建立新的数组，只能在原有的数组上修改。当读到第i个元素当值是n时，应该把n放在nums[n-1]上，即应该把nums[i]放到nums[nums[i]-1]上。</p>
<p>遍历整个数组，若不满足nums[i]==nums[nums[i]-1]，则将两者调换位置。例如当发现5，则将其与nums[4]上的数字交换。</p>
<p>最后再次遍历数组，若nums[i]!=i+1，则返回i+1，否则说明现有数组都不缺，返回最后一个数都下一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;=len&amp;&amp;nums[nums[i]-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>]=nums[i];</span><br><span class="line">                nums[i]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 040 Combination Sum II</title>
    <url>/posts/55336/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>Each number in candidates may only be used once in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一系列候选数字candidates和目标值target，找出所有的不重复组合使得候选数字组合的和等于目标值。</p>
<p>一个组合中每个候选数字元素只能使用一次，所有数字均为正整数，不能包含重复的组合。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>与第39题类似，多了一个要求是候选元素只能使用一次，但候选元素之间可以重复。</p>
<p>同样使用递归，在递归中，遍历候选元素添加时，判断在选择当前位上数时，若从候选数字中后一个元素和前一个元素相同则跳过，因为之前已经在当前位上添加过该元素，完成去重。</p>
<p>并且已经递归调用时，候选元素但起始位置在当前元素上加1，同一个元素不会使用多次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        resolve(res,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolve</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;remain) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(candidates[i]);</span><br><span class="line">            resolve(res,curr,candidates,remain-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 039 Combination Sum</title>
    <url>/posts/19748/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>The same repeated number may be chosen from candidates unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定几个不重复的候选正整数和一个目标数，求所有不重复组合使得候选数相加等于目标值，候选数可以多次选择。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用递归，用Set去重，当前已有的数字放入curr的list中，将curr中所有数求和sum，若sum和target一样则加入结果集并返回。</p>
<p>若sum比target大，则不符合条件直接返回。否则遍历候选集，尝试将每个候选数加入当前curr，再去递归判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> HashSet&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        checkAll(candidates,target,res,curr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAll</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, Set&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:curr)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            Collections.sort(curr);</span><br><span class="line">            res.add(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:candidates)&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            tmp.addAll(curr);</span><br><span class="line">            tmp.add(num);</span><br><span class="line">            checkAll(candidates,target,res,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>解法1的优化，先把候选数组排序，然后增加从候选数组选择数字起始位置start，这样可以避免重复添加。</p>
<p>另外，直接传入target和当前数组的差值，这样不用每次都将当前数组的和算一遍，只保留最新的差值。</p>
<p>最后，为了减少临时数组的创建，递归调用后可以将当前数组删除末尾元素来进行恢复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        checkAll(candidates,res,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAll</span><span class="params">(<span class="keyword">int</span>[] candidates, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            curr.add(candidates[i]);</span><br><span class="line">            checkAll(candidates,res,curr,remain-candidates[i],i);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 038 Count and Say</title>
    <url>/posts/40563/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p>1 is read off as “one 1” or 11.</p>
<p>11 is read off as “two 1s” or 21.</p>
<p>21 is read off as “one 2, then one 1” or 1211.</p>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对于前一个数，找出其对应字符串中相同数字都个数，并将其个数和数字一起存到新都字符串中作为当前数字的对应结果。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>递归调用，当n等于1时直接返回”1”，否则利用该方法求得前一个数对应的字符串。再按照题意理解生成新的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String pre = countAndSay(n-<span class="number">1</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pre.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.charAt(i)!=pre.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                sb.append(count).append(pre.charAt(i-<span class="number">1</span>));</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(count).append(pre.charAt(pre.length()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>也可以对字符串”1”进行n-1次更新，更新规则与上述解法相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        String res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            String curr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i+<span class="number">1</span>&lt;res.length()&amp;&amp;res.charAt(i)==res.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                curr=curr+count+res.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            res=curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 037 Sudoku Solver</title>
    <url>/posts/21287/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy all of the following rules:</p>
<ol>
<li>Each of the digits 1-9 must occur exactly once in each row.</li>
<li>Each of the digits 1-9 must occur exactly once in each column.</li>
<li>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</li>
</ol>
<p>Empty cells are indicated by the character ‘.’.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="pic"></p>
<p>A sudoku puzzle…</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="pic"></p>
<p>…and its solution numbers marked in red.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The given board contain only digits 1-9 and the character ‘.’.</li>
<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>
<li>The given board size is always 9x9.</li>
</ul>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>将数独中的空白按规则正确填充，假设有且仅有唯一解。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>对每个空格子都带入1-9，每带入一个数字判定其是否合法，若合法则将其放入棋盘并递归调用。</p>
<p>若其递归调用都仍然合法，说明棋盘已经填充正确，直接返回；若不合法，说明这个数字不适合，将棋盘此位置重新放入<code>.</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span>||board.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> curr=<span class="string">'1'</span>;curr&lt;=<span class="string">'9'</span>;curr++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(board,i,j,curr))&#123;</span><br><span class="line">                            board[i][j]=curr;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                board[i][j]=<span class="string">'.'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">char</span> curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i]!=<span class="string">'.'</span>&amp;&amp;board[row][i]==curr) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][column]!=<span class="string">'.'</span>&amp;&amp;board[i][column]==curr) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span>*(row/<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(column/<span class="number">3</span>)+i%<span class="number">3</span>]!=<span class="string">'.'</span>&amp;&amp;board[<span class="number">3</span>*(row/<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(column/<span class="number">3</span>)+i%<span class="number">3</span>]==curr) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 036 Valid Sudoku</title>
    <url>/posts/43501/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<ol>
<li>Each row must contain the digits 1-9 without repetition.</li>
<li>Each column must contain the digits 1-9 without repetition.</li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="pic"></p>
<p>A partially filled sudoku which is valid.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being </span><br><span class="line">    modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character ‘.’.</li>
<li>The given board size is always 9x9.</li>
</ul>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>判断9x9的数独棋盘是否有效，要求满足以下条件：</p>
<ol>
<li>每一行必须包含1-9，不能重复</li>
<li>每一列必须包含1-9，不能重复</li>
<li>每个3x3的格子必须包含1-9，不能重复</li>
</ol>
<p>另外请注意</p>
<ol>
<li>数独棋盘已经填充的部分要求有效但不要求能解出来</li>
<li>只有已经填充的格子才需要验证是否符合上述条件</li>
<li>棋盘只包含1-9和字符<code>.</code></li>
<li>棋盘大小是9x9</li>
</ol>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>准备三个set，分别记录各行、各列、各小方阵是否出现某个数字，下标需要转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            Set&lt;Character&gt; row = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            Set&lt;Character&gt; column = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            Set&lt;Character&gt; block = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>&amp;&amp;!row.add(board[i][j]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i]!=<span class="string">'.'</span>&amp;&amp;!column.add(board[j][i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> rowIndex = <span class="number">3</span>*(i/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> colIndex = <span class="number">3</span>*(i%<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(board[rowIndex+j/<span class="number">3</span>][colIndex+j%<span class="number">3</span>]!=<span class="string">'.'</span>&amp;&amp;!block.add(board[rowIndex+j/<span class="number">3</span>][colIndex+j%<span class="number">3</span>]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>用一个set保存数字分别在行row、列column、块block中的值的字符串形式，若相同的数在同一行、同一列、同一块再次出现，则添加到set中会返回false，依次来判断是否有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(num==<span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!set.add(num+<span class="string">" in row "</span>+i)||</span><br><span class="line">                   !set.add(num+<span class="string">" in column "</span>+j)||</span><br><span class="line">                   !set.add(num+<span class="string">" in block "</span>+i/<span class="number">3</span>+<span class="string">"-"</span>+j/<span class="number">3</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 035 Search Insert Position</title>
    <url>/posts/10372/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个有序数组nums和一个目标值target，若数组中nums能找到target则返回下标，否则返回它应该放入的位置。数组中没有重复元素。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>先把target大于或者小于nums所有数的情况解决掉，剩下就是在nums中进行二分查找。</p>
<p>若能找到则返回下标，若不能，则退出循环时left的位置即为应插入的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;nums[len-<span class="number">1</span>]) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 034 Find First and Last Position of Element in Sorted Array</title>
    <url>/posts/53326/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个整数数组nums，按升序排列，元素可以重复，找出目标数target出现的起始和结束位置。时间复杂度要求O(log n)，若没找到，返回[-1, -1]。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>和二分查找一样，当找到mid的值等于target时，从mid分别往左和往右去找和target相等的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">int</span> start=mid,end=mid;</span><br><span class="line">                <span class="keyword">while</span>(--start&gt;=<span class="number">0</span>&amp;&amp;nums[start]==target)&#123;&#125;;</span><br><span class="line">                <span class="keyword">while</span>(++end&lt;=nums.length-<span class="number">1</span>&amp;&amp;nums[end]==target)&#123;&#125;;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start+<span class="number">1</span>,end-<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述解法1有个问题是在mid处找到target后，起点和终点点查找并不是二分的。下述是改进版。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[left]&lt;nums[right])&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==nums[right]&amp;&amp;nums[left]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 033 Search in Rotated Sorted Array</title>
    <url>/posts/61834/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个数组，其原本按升序排列，但后来在某个轴被旋转。给定一个目标数字，在数组中查找其下标，若不存在则返回-1。</p>
<p>数组中的元素不重复，算法时间复杂度必须是O(log n)。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>从时间复杂度看，必须要使用二分查找，问题的难点在于数组不是全部有序的。其先是升序，在某个点突然变小，后面接着升序。</p>
<p>对于数组[0,1,2,3,4,5,6,7]共有以下旋转后排列，若中间的数字小于最右边的数字，说明右半段是有序的，否则说明左半段是有序的。</p>
<p>利用有序半段的首尾两个数来判断目标数字应该落在哪半边。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0　　1　　2　　 4　　5　　6　　7</span><br><span class="line"></span><br><span class="line">7　　0　　1　　 2　　4　　5　　6</span><br><span class="line"></span><br><span class="line">6　　7　　0　　 1　　2　　4　　5</span><br><span class="line"></span><br><span class="line">5　　6　　7　　 0　　1　　2　　4</span><br><span class="line"></span><br><span class="line">4　　5　　6　　7　　0　　1　　2</span><br><span class="line"></span><br><span class="line">2　　4　　5　　6　　7　　0　　1</span><br><span class="line"></span><br><span class="line">1　　2　　4　　5　　6　　7　　0</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;nums[right]&gt;=target)&#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;nums[mid]&gt;target)&#123;</span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述解法1的优化算法，若mid和target在num[0]的同一侧，则取nums[mid]，否则按需取最大最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> value = (nums[mid]&lt;nums[<span class="number">0</span>])==(target&lt;nums[<span class="number">0</span>]) ? nums[mid] : (target&lt;nums[<span class="number">0</span>]?Integer.MIN_VALUE:Integer.MAX_VALUE);</span><br><span class="line">            <span class="keyword">if</span>(value==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 032 Longest Valid Parentheses</title>
    <url>/posts/65225/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个只包含<code>(</code>及<code>)</code>的字符串，求最长有效括号的子串的长度。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>遍历字符串，以当前字符为<code>(</code>，则开始检查以当前字符为起始位置到末尾，最大有效子串到长度。</p>
<p>检查最大有效子串长度到方法为借助栈，碰到左括号则压栈，碰到有括号则检查栈是否为空，若为空则返回，若不为空则弹出，更新匹配到到对数，并且再次判断栈是否为空。</p>
<p>此时栈为空表明，从起始位置到当前位置都是有效，并更新最大有效子串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;=<span class="number">1</span>||s.indexOf(<span class="string">"("</span>)==-<span class="number">1</span>||s.indexOf(<span class="string">")"</span>)==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = checkLongest(s,i);</span><br><span class="line">                res = Math.max(res,max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkLongest</span><span class="params">(String s, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> matched=<span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">'('</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> max;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">            matched++;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                max=<span class="number">2</span>*matched;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>在上诉解法1的基础上进行优化，只遍历一次数组。</p>
<p>定义res为最长子串长度，start为有效子串的起始位置。遍历字符串当前位置i，若遇到左括号，则将其下标压入栈中。若遇到右括号，如果栈为空，则说明从start到当前位置有效子串截止，start后移到当前位置后一位；若栈不为空，则弹出栈顶元素，再判断栈是否为空。</p>
<p>此时，若栈为空，则说明从start到当前位置都是有效，比较当前res和i-start+1并更新；若不为空，则说明前面有左括号并没有匹配，比较res和i-栈顶元素到值，即从最后一个没有匹配到左括号到当前位置到有效子串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;=<span class="number">1</span>||s.indexOf(<span class="string">"("</span>)==-<span class="number">1</span>||s.indexOf(<span class="string">")"</span>)==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>, start=<span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                res=Math.max(res,i-start+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res=Math.max(res,i-stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>使用动态规划，dp[i]表示从字符串开始位置到i下标到有效子串最大长度。若字符串当前位置为左括号，则跳过，因为并不能影响当前最长子串到长度值。</p>
<p>若当前字符串为右括号，则进行以下判断：</p>
<ol>
<li>若s[i]==’)’且s[i-1]==’(‘，则dp[i]=dp[i-2]+2;</li>
<li>若s[i]==’)’且s[i-1]==’)’，则判断s[i-dp[i-1]-1]==’(‘，则dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;=<span class="number">1</span>||s.indexOf(<span class="string">"("</span>)==-<span class="number">1</span>||s.indexOf(<span class="string">")"</span>)==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">'('</span>)&#123;</span><br><span class="line">                dp[i] = i&gt;=<span class="number">2</span>?dp[i-<span class="number">2</span>]+<span class="number">2</span>:<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">'('</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + ((i-dp[i-<span class="number">1</span>]-<span class="number">2</span>)&gt;=<span class="number">0</span>?dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>]+<span class="number">2</span>:<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 031 Next Permutation</title>
    <url>/posts/12241/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>1,2,3 → 1,3,2</p>
<p>3,2,1 → 1,2,3</p>
<p>1,1,5 → 1,5,1</p>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求全排列下一个排列顺序，参考如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>若给定数组是降序，则说明是全排列到最后一组，下一个排列顺序就是最开始到一组。</p>
<p>例如又一个数组<code>1　　2　　7　　4　　3　　1</code>，则下一个排列为<code>1　　3　　1　　2　　4　　7</code>。</p>
<p>从末尾往前看，数字逐渐变大，到来2开始减小，在从后往前找到第一个比2大的数3，将3与2进行交换，再将3后面的数字反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length, i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=len-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        i=i+<span class="number">1</span>;</span><br><span class="line">        j=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=tmp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 030 Substring with Concatenation of All Words</title>
    <url>/posts/6607/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定字符串s和一系列单词words，单词的长度都相等。找出所有匹配的子串的起始位置，匹配的字符子串需是由所有这些单词串联一次而成。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>首先若字符串s的长度m小于所有单词长度之和n，则返回空。同时令单词长度为l。</p>
<p>然后对字符串s从第0位到m-n位进行遍历，若从当前i到i+l，若单词列表中含有，则开始进行判断。</p>
<p>判读是重新copy一份单词列表到wordCopy，对从i开始的每一长度为l的子串，若在wordCopy中，则将其从wordCopy删除，并移动l重新查找，直到wordCopy不包含或者为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||words==<span class="keyword">null</span>||s.length()==<span class="number">0</span>||words.length==<span class="number">0</span>||words[<span class="number">0</span>]==<span class="keyword">null</span>||words[<span class="number">0</span>].length()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = words.length*words[<span class="number">0</span>].length(), l=words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(words);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m-n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wordList.contains(s.substring(i,i+l)))&#123;</span><br><span class="line">                List&lt;String&gt; wordCopy = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                wordCopy.addAll(wordList);</span><br><span class="line">                <span class="keyword">int</span> start = i;</span><br><span class="line">                <span class="keyword">while</span>(wordCopy.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(wordCopy.contains(s.substring(start,start+l)))&#123;</span><br><span class="line">                        wordCopy.remove(s.substring(start,start+l));</span><br><span class="line">                        start+=l;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(wordCopy.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述解法1有个缺陷是单词不能重复，为了针对单词有重复到情况，要使用HashMap代替List。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||words==<span class="keyword">null</span>||s.length()==<span class="number">0</span>||words.length==<span class="number">0</span>||words[<span class="number">0</span>]==<span class="keyword">null</span>||words[<span class="number">0</span>].length()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = words.length, l=words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">if</span>(n*l&gt;m) <span class="keyword">return</span> res;</span><br><span class="line">        Map&lt;String,Integer&gt; wordMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wordMap.containsKey(word))&#123;</span><br><span class="line">                wordMap.put(word,wordMap.get(word)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                wordMap.put(word,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m-n*l;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            Map&lt;String,Integer&gt; wordTmpMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;n;j++)&#123;</span><br><span class="line">                String word = s.substring(i+j*l,i+j*l+l);</span><br><span class="line">                <span class="keyword">if</span>(wordMap.containsKey(word))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(wordTmpMap.containsKey(word))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(wordTmpMap.get(word)==wordMap.get(word)) <span class="keyword">break</span>;</span><br><span class="line">                        wordTmpMap.put(word,wordTmpMap.get(word)+<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        wordTmpMap.put(word,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==n&amp;&amp;wordTmpMap.size()==wordMap.size()) res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>上述解法2到优化版，使用了Map.getOrDefault()来优化Map到操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String word : words) &#123;</span><br><span class="line">            counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; indexes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length(), num = words.length, len = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - num * len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Map&lt;String, Integer&gt; seen = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; num) &#123;</span><br><span class="line">                <span class="keyword">final</span> String word = s.substring(i + j * len, i + (j + <span class="number">1</span>) * len);</span><br><span class="line">                <span class="keyword">if</span> (counts.containsKey(word)) &#123;</span><br><span class="line">                    seen.put(word, seen.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (seen.get(word) &gt; counts.getOrDefault(word, <span class="number">0</span>)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == num) &#123;</span><br><span class="line">                indexes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 029 Divide Two Integers</title>
    <url>/posts/4645/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing dividend by divisor.</p>
<p>The integer division should truncate toward zero.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</li>
</ul>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>实现整数的除法，禁止使用乘法、除法、取余。整数范围为有符号int，除数不会是0，结果溢出后返回231 − 1。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>思路是把数转成正数long，再按位移动的操作。若被除数m比除数n大，将n往左移一位成t再比较，这样可以快速定位到例如1、2、4、8倍的倍数p。</p>
<p>然后将m减去t，倍数结果res加上p，不断循环，最后根据符号返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span>(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(divisor==-<span class="number">1</span>) <span class="keyword">return</span> -dividend;</span><br><span class="line">        <span class="keyword">long</span> m = Math.abs(Long.valueOf(dividend)), n = Math.abs(Long.valueOf(divisor));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, sign = (dividend&lt;<span class="number">0</span>)^(divisor&lt;<span class="number">0</span>)?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=n)&#123;</span><br><span class="line">            <span class="keyword">long</span> t=n,p=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(m&gt;=(t&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=p;</span><br><span class="line">            m-=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span>?res:-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>在解法1的基础上使用递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span>(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(divisor==-<span class="number">1</span>) <span class="keyword">return</span> -dividend;</span><br><span class="line">        <span class="keyword">long</span> m = Math.abs(Long.valueOf(dividend)), n = Math.abs(Long.valueOf(divisor));</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, sign = (dividend&lt;<span class="number">0</span>)^(divisor&lt;<span class="number">0</span>)?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t=n,p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=(t&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=p+divide(Long.valueOf(m-t).intValue(),Long.valueOf(n).intValue());</span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span>?res:-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 028 Implement strStr()</title>
    <url>/posts/18258/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>实现String.indexOf()的功能，返回needle在haystack第一次出现的下标，若不存在则返回-1。若needle是空字符串，则返回0。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>遍历haystack直到其当前字符等于needle的首字符，然后基于needle比较后续字符是否相等。</p>
<p>若有不想等或者到达haystack末尾，则说明不匹配，haystack往后移动一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle==<span class="keyword">null</span>||needle.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(haystack==<span class="keyword">null</span>||haystack.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;needle.length();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i+j&gt;=haystack.length() || haystack.charAt(i+j)!=needle.charAt(j))&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>解法1的优化版本，遍历haystack时，直接比较needle的所有字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle==<span class="keyword">null</span>||needle.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(haystack==<span class="keyword">null</span>||haystack.length()&lt;needle.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=haystack.length()-needle.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;needle.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(i+j)!=needle.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==needle.length()) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 027 Remove Element</title>
    <url>/posts/39064/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个整数数组nums，将所有等于val的元素移除，并且返回新数组的长度。</p>
<p>不允许分配额外的空间同创建新数组，必须直接修改当前数组以达到空间复杂度为O(1)。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用双指针，left指向最终去掉目前元素数组掉最新位置，right指向当前遍历掉位置。</p>
<p>若right的值不等于目标值val，则nums在left的值更新为right的值，left及right加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=val)&#123;</span><br><span class="line">                nums[left++]=nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 026 Remove Duplicates from Sorted Array</title>
    <url>/posts/12484/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个有序的数字数组，移除重复的元素，并且返回新的长度。不允许分配额外的空间给另外一个数组，要直接修改输入数组达到O(1)的空间复杂度。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用双指针，left指向该数字出现的第一个位置，right初始指向left的下一位，len表示最终的长度。</p>
<p>遍历数组，若right位置上的数字和left相同，则right往后移动一位，直到发现不同的数字或者达到末尾。</p>
<p>当发现不同数字时，更新len，并将数组len-1上的值更新为最新发现的数字，同时left移动到right位置，right后移一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[right]==nums[left])&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(right&gt;=nums.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            len++;</span><br><span class="line">            nums[len-<span class="number">1</span>]=nums[right];</span><br><span class="line">            left=right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>对解法1进行优化，left指向最终去重后对当前位置，right指向当前遍历对位置。</p>
<p>当right位置上到元素和left不相等时，left后移一位，同时给left位置赋right的值，然后继续right后移一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(++right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=nums[left])&#123;</span><br><span class="line">                nums[++left]=nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>也可以如解法2，只使用左侧指针，右侧依靠for循环来取出当前位置的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">0</span> || num!=nums[n-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[n++]=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 025 Reverse Nodes in k-Group</title>
    <url>/posts/34575/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p><strong>Note:</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个链表，将其每k个节点反转，并返回修改后的链表。k是小于等于链表长度的正整数，不足k个时保持原样。不允许修改节点的值，只允许修改整个节点。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>把每k个节点为一组进行反转，那样需要两个函数，一个用来分段，一个用来反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), curr= head, start = curr , lastDone = dummy;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            ListNode nextOne = curr.next;</span><br><span class="line">            <span class="keyword">if</span>(count==k)&#123;</span><br><span class="line">                lastDone.next=reverse(start,k);</span><br><span class="line">                lastDone=start;</span><br><span class="line">                start=nextOne;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=nextOne;</span><br><span class="line">        &#125;</span><br><span class="line">        lastDone.next=start;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), curr = node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            ListNode tmp = dummy.next;</span><br><span class="line">            dummy.next = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            dummy.next.next=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述解法，是以k为步进来生成最终的结果链表，保存了很多状态。也可以很平滑地进行反转，在反转是带上k个节点为一组的前置和后置节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), pre = dummy, curr = head;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;curr!=<span class="keyword">null</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">                pre = reverse(pre,curr.next);</span><br><span class="line">                curr = pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre, ListNode next)</span></span>&#123;</span><br><span class="line">        ListNode last = pre.next, curr = last.next;</span><br><span class="line">        <span class="keyword">while</span>(curr!=next)&#123;</span><br><span class="line">            last.next = curr.next;</span><br><span class="line">            curr.next = pre.next;</span><br><span class="line">            pre.next = curr;</span><br><span class="line">            curr = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>上述过程也可以在一个方法中完成，先遍历整个链表计算出链表长度，然后每次对k个节点进行反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), pre = dummy, curr = head;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;k)&#123;</span><br><span class="line">            curr = pre.next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                ListNode tmp = curr.next;</span><br><span class="line">                curr.next=tmp.next;</span><br><span class="line">                tmp.next=pre.next;</span><br><span class="line">                pre.next=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">            num -= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>递归调用，我们用pre记录每段的开始位置的前一个节点，cur记录结束位置的下一个节点，然后我们调用reverse函数来将这段翻转，然后得到一个new_head，原来的head就变成了末尾，这时候后面接上递归调用下一段得到的新节点，返回new_head即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), pre = dummy, curr = head;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(pre,curr);</span><br><span class="line">        head.next = reverseKGroup(curr,k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre, ListNode next)</span></span>&#123;</span><br><span class="line">        ListNode last = pre.next, curr = last.next;</span><br><span class="line">        <span class="keyword">while</span>(curr!=next)&#123;</span><br><span class="line">            last.next = curr.next;</span><br><span class="line">            curr.next = pre.next;</span><br><span class="line">            pre.next = curr;</span><br><span class="line">            curr = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 024 Swap Nodes in Pairs</title>
    <url>/posts/65154/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个链表，按顺序将每两个节点交换，并返回链表头部。不能修改节点的值，只能改变整个节点。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>若链表为空或只有一个节点则返回头节点。循环遍历，条件是当前节点和当前节点的下一个节点都存在，在循环体中把这两个交换位置放入结果链表中。</p>
<p>当退出循环体后，只有一个节点没有遍历或者都遍历过，只需要在将其添加到结果链表中去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), curr = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>&amp;&amp;head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = head.next.next;</span><br><span class="line">            curr.next=head.next;</span><br><span class="line">            curr.next.next=head;</span><br><span class="line">            curr=curr.next.next;</span><br><span class="line">            head=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next=head;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>递归调用，先把链表的前两个节点交换，再对除去这两个节点对链表进行递归调用，并将其赋给第二个节点的下一位，返回第一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode res = head.next;</span><br><span class="line">        head.next=swapPairs(head.next.next);</span><br><span class="line">        res.next=head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 023 Merge k Sorted Lists</title>
    <url>/posts/44312/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>把K个有序链表合并成一个有序链表。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>和合并两个链表类似，建立哨兵节点，结果返回哨兵节点下一位。进循环，循环中每次遍历所有链表的首个节点，并比较各个节点，找出值最小的节点。</p>
<p>将结果链接的当前节点指向这个最小节点，并将链表数组中最小节点所在的链表移动到最小节点到下一节点。</p>
<p>若碰到某个链表当前节点为空则跳过，若所有链表当前节点都为空则退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>), curr=dummy;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = lists.length;</span><br><span class="line">            <span class="keyword">int</span> minVal = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">            ListNode minNode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">                ListNode node = lists[i];</span><br><span class="line">                <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    num--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.val&lt;minVal)&#123;</span><br><span class="line">                    minVal=node.val;</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                    minNode=node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                curr.next=minNode;</span><br><span class="line">                curr=curr.next;</span><br><span class="line">                lists[minIndex]=minNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用PriorityQueue来维持一个最小堆，把k个链表到首节点放入优先队列中，它们会自动根据值val排序好。</p>
<p>每次取出最小的节点加入到结果链表中，并把该最小节点的下一位放入队列中。依此类推，直到队列中没有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>), curr=dummy;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.val&lt;o2.val)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.val==o2.val)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            curr.next=queue.poll();</span><br><span class="line">            curr=curr.next;</span><br><span class="line">            <span class="keyword">if</span>(curr.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(curr.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>不管几个链表，都可以两两合并，最终合并成一个链表。利用分治思想，将链表数组从中划分为两部分，分别顺序合并两部分每一个链表并赋给前半部分。</p>
<p>不停地对半划分并合并更新，直到应该合并的链表数量为1，即已经合并完成所有链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = lists.length;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> steps = (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                lists[i]=mergeTwoLists(lists[i],lists[i+steps]);</span><br><span class="line">            &#125;</span><br><span class="line">            n=steps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>), curr=dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">                curr.next=l1;</span><br><span class="line">                curr=curr.next;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr.next=l2;</span><br><span class="line">                curr=curr.next;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) curr.next=l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) curr.next=l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-divide-and-conquer</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 022 Generate Parentheses</title>
    <url>/posts/28316/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定n对括弧，生成所有正确形式组合的字符串。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>对于这种列出所有结果的题目优先考虑递归Recursion求解。对于n，则有n个左括号和n个右括号，定义两个变量open、close表示左右括号还剩下的个数。因为总是先出现左括号，所有open应该不大于close。</p>
<p>若出现open大于close则直接返回。若open和close都为0则将当前字符串放入结果中。若open或者close不为0，则递归调用并更新open或close的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        generate(n,n,res,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> open, <span class="keyword">int</span> close, List&lt;String&gt; res, String out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(close&lt;open) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(open==<span class="number">0</span>&amp;&amp;close==<span class="number">0</span>) res.add(out);</span><br><span class="line">        <span class="keyword">if</span>(open&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            generate(open-<span class="number">1</span>,close,res,out+<span class="string">"("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            generate(open,close-<span class="number">1</span>,res,out+<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>没当N加1时，找现有N的所有结果，在结果字符串中如果遇见左括号，则直接在其后加入()或者在该字符串末尾加上()，然后返回。使用Set去重，变化如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n＝1:    ()</span><br><span class="line"></span><br><span class="line">n=2:    (())    ()()</span><br><span class="line"></span><br><span class="line">n=3:    (()())    ((()))    ()(())    (())()    ()()()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Set&lt;String&gt; res = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        res.add(<span class="string">"()"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Set&lt;String&gt; tmp = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String str:res)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str.charAt(j)==<span class="string">'('</span>)&#123;</span><br><span class="line">                        tmp.add(str.substring(<span class="number">0</span>,j+<span class="number">1</span>)+<span class="string">"()"</span>+str.substring(j+<span class="number">1</span>));</span><br><span class="line">                        tmp.add(str+<span class="string">"()"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 021 Merge Two Sorted Lists</title>
    <url>/posts/13700/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>把K个有序链表合并成一个有序链表。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>建立哨兵节点，当前节点指向哨兵节点。开始While循环，条件是l1和l2都不为空。在循环体中，比较l1和l2到值找出较小的节点，到将其放在结果链表当前位置之后，并将该节点及结果链接都往后移一位，继续循环。</p>
<p>由于遍历到最后，肯定有一个链表先遍历到末尾退出循环，则结果链表的后面接上未完成的链表，最终返回哨兵节点的后一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>), curr=dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">                curr.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next=l1!=<span class="keyword">null</span>?l1:l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(M+N)，两个链表的长度。</p>
<p><strong>空间复杂度:</strong> O(M+N)，两个链表的长度。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用递归，比较两个链表当前节点的大小找出较小的节点，则对剩余对节点进行递归调用，将返回对结果赋给此节点对下一位，同时返回该节点作为结果。</p>
<p>相当于每次递归只找出一个合适的节点，递归结束的条件是有个链表为空，则直接返回另一个链表未完成的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(M+N)，两个链表的长度。</p>
<p><strong>空间复杂度:</strong> O(M+N)，两个链表的长度。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 020 Valid Parentheses</title>
    <url>/posts/29601/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]‘, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，只包含”(){}[]”，判断输入到字符串是否有效。开括号和必须以同样到类型到闭括号关闭，开括号必须以正确到顺序关闭。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>看到开括号必要要以相同到顺序关闭，自然想到栈，读取到开括号则压栈，读取到闭括号则出栈并判断是否配对。读取完栈需为空，否则无效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        String left = <span class="string">"([&#123;"</span>;</span><br><span class="line">        String right = <span class="string">")]&#125;"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> curr:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.indexOf(curr)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right.indexOf(curr)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">char</span> open = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(right.charAt(left.indexOf(open))!=curr)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(N)，字符串长度。</p>
<p><strong>空间复杂度:</strong> O(N)，字符串长度。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>把所有括号符号依次拼接成字符串，Stack里面存括号在字符串中位置，以简化计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; p = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        String brackets = <span class="string">"()&#123;&#125;[]"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> curr:s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = brackets.indexOf(curr);</span><br><span class="line">            <span class="keyword">if</span>(q % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.isEmpty() || p.pop() != q - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> p.push(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(N)，字符串长度。</p>
<p><strong>空间复杂度:</strong> O(N)，字符串长度。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 019 Remove Nth Node From End of List</title>
    <url>/posts/58507/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Given n will always be valid.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do this in one pass?</p>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个链表，移除链表的倒数第N个节点，并返回链表的头节点。限定N总是有效的不会超出链表长度，最好遍历一次。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>在第一个节点的前面建立一个哨兵节点，使用双指针left和right，最初都指向哨兵节点。</p>
<p>然后先把right往后移N位，若right的next为空则表明N和链表的长度相同，要删除第一个节点。</p>
<p>否则开始同时移动left和right，保持right和left间距为N，直至right的next为空即移动到末尾。此时，left到下一个节点即为要删除到节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode left = dummy, right = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right.next==<span class="keyword">null</span>) <span class="keyword">return</span> dummy.next.next;</span><br><span class="line">        <span class="keyword">while</span>(right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            right=right.next;</span><br><span class="line">            left=left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next=left.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(N)，遍历一次。</p>
<p><strong>空间复杂度:</strong> O(1)，使用恒定到额外空间。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 018 4Sum</title>
    <url>/posts/52863/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定n个整数和一个目标整数，从n个整数中找出所有不重复的4个数字组合，使得它们之和等于目标整数。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>和三数之和一样，把数组从小到大排序，循环固定前两个数字，后两个数组采用双指针，一个从前往后，一个从后往前。</p>
<p>若四数之和等于目标值则加入结果集，若大于，则右侧数字往左移，否则左侧数字往右移。通过Set过滤重复元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> HashSet&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left=j+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>下面解法不使用Set去重，对于四个数的每一位取值上，若当前数字和前一位一样则跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left=j+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left+<span class="number">1</span>]==nums[left]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right-<span class="number">1</span>]==nums[right]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 017 Letter Combinations of a Phone Number</title>
    <url>/posts/35100/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="pic"></p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个包含数字2-9的字符串，返回数字代表的所有可能的字符组合。数字和字母的映射和电话按钮一样。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用递归进行，递归方法没有返回值，只有当递归到输入字符串为空时，才将当前字符组合添加进结果集并返回。</p>
<p>否则，找到当前字符串第一位对应到所有字符，循环调用递归，更新参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.isEmpty()) <span class="keyword">return</span> result;</span><br><span class="line">        String[] mapping = <span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        generateAll(digits,result,<span class="string">""</span>,mapping);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateAll</span><span class="params">(String digits, List&lt;String&gt; result, String out, String[] mapping)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.isEmpty())&#123;</span><br><span class="line">            result.add(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> index = (digits.charAt(<span class="number">0</span>)-<span class="string">'0'</span>)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> curr:mapping[index].toCharArray())&#123;</span><br><span class="line">            generateAll(digits.substring(<span class="number">1</span>),result,out+curr,mapping);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用迭代，结果集初始化进去一个空字符串。在遍历digits中的所有数字时，先建立一个临时字符串结果列表，通过数字取出其对应字符数组，遍历字符数组并取出结果集中所有字符串，将字符拼接在后面并放入临时列表。</p>
<p>每遍历一个数字，将结果集重新指向临时列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.isEmpty()) <span class="keyword">return</span> result;</span><br><span class="line">        String[] mapping = <span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        result.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++)&#123;</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> index = (digits.charAt(i)-<span class="string">'0'</span>)-<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(String s:result)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c:mapping[index].toCharArray())&#123;</span><br><span class="line">                    tmp.add(s+c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 016 3Sum Closest</title>
    <url>/posts/38928/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定n个整数和一个目标整数，找出三个整数，其和和目标整数最接近。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>和求三数之和为0类似，循环固定第一个数，第二个数从第一个数下一位往右取，第三个从末尾往左取。</p>
<p>定义一个变量记录三数之和与给定值差的绝对值，比较差值，若小则更新最小差值并记录和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest = Integer.MAX_VALUE, res = Integer.MAX_VALUE;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span>(closest&gt;Math.abs(sum-target))&#123;</span><br><span class="line">                    closest = Math.abs(sum-target);</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，每个数字最多遍历两遍。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 015 3Sum</title>
    <url>/posts/42879/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定n个整数，求所有三个数字组合使得它们之和为0，数字组合不能重复。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>可以将数字排序，顺序取三个满足条件的数字。循环固定第一个数字，肯定不大于0，否则之和会大于0。第二个数字从第一个数的右边开始往右，第三个从末尾开始往左。</p>
<p>若之和为0，则添加进结果集。若小于0，则第二个数字太小，需要往右侧移动。若大于0，则表明第三个数字过大，需要往左侧移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>&amp;&amp;nums[i]&lt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="number">0</span>)&#123;</span><br><span class="line">                    List&lt;Integer&gt; match = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    match.add(nums[i]);</span><br><span class="line">                    match.add(nums[j]);</span><br><span class="line">                    match.add(nums[k]);</span><br><span class="line">                    res.add(match);</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j+<span class="number">1</span>]==nums[j])&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k-<span class="number">1</span>]==nums[k])&#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，每个数字最多遍历两遍。</p>
<p><strong>空间复杂度:</strong> O(1)，需要保存结果集。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>可以使用Set来保存结果，这样可以去掉去重部分的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>&amp;&amp;nums[i]&lt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，每个数字最多遍历两遍。</p>
<p><strong>空间复杂度:</strong> O(1)，需要保存结果集。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 014 Longest Common Prefix</title>
    <url>/posts/48879/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>All given inputs are in lowercase letters a-z.</p>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在字符串数组中找出最长的公共前缀字符串，若没有则返回空字符串。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>已字符串数组到第一个元素为基础，遍历该字符串取得当前字符，然后遍历其他字符串到当前位置，若其他字符串已经到达末尾或者字符不一致，则返回已经匹配过的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>||strs[<span class="number">0</span>]==<span class="keyword">null</span>||strs[<span class="number">0</span>].length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j].length()&lt;=i||strs[j].charAt(i)!=curr)&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(S)，S是所有字符串字符的长度，因为所有字符都只遍历一次。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>可以将所以字符串排序，那么最前和最后的字符串肯定是差距最大的，此时只需要比较这两个字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(strs[<span class="number">0</span>].length(),strs[strs.length-<span class="number">1</span>].length());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[<span class="number">0</span>].charAt(i)!=strs[strs.length-<span class="number">1</span>].charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(S)，S是所有字符串字符的长度，因为所有字符都只遍历一次。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 013 Roman to Integer</title>
    <url>/posts/19839/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9. </li>
<li>X can be placed before L (50) and C (100) to make 40 and 90. </li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>将罗马数字转成整数，假定此整数范围在1到3999。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>将罗马字符和其整数值相对应，遍历罗马数字字符串，若后一位字符所代表到位数比当前位数高，则用后一位到整数值减去当前位到整数值再累加，否则直接累加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String roman = <span class="string">"MDCLXVI"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;s.length()-<span class="number">1</span>&amp;&amp;roman.indexOf(s.charAt(i))&gt;roman.indexOf(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                result += values[roman.indexOf(s.charAt(i+<span class="number">1</span>))] - values[roman.indexOf(s.charAt(i))];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result += values[roman.indexOf(s.charAt(i))];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，数字到长度。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>我们需要用到HashMap数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可：<br>第一，如果当前数字不是最后一个数字且之后的数字比它大的话，则减去当前数字。<br>第二，其他情况则加上这个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; romans = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        romans.put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        romans.put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">        romans.put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">        romans.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        romans.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        romans.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        romans.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;s.length()-<span class="number">1</span>&amp;&amp;romans.get(curr)&lt;romans.get(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                result -= romans.get(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result += romans.get(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 012 Integer to Roman</title>
    <url>/posts/56606/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9. </li>
<li>X can be placed before L (50) and C (100) to make 40 and 90. </li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个整数，将其转成罗马数字，整数的范围在1到3999。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>给定的整数范围在1到3999，那么只有千位、百位、十位、个位。例如计算出百位的数字，那么这个百位数字涉及到到罗马字符只有’M’,’D’,’C’，同理其他位。<br>写一个工具方法，可以根据当前位的值及涉及的三个罗马字符得到此位最后的罗马字符。对数不断对位的权重取商，并更新为对位的权重求余结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] symbols = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'M'</span>,<span class="string">'D'</span>,<span class="string">'C'</span>,<span class="string">'L'</span>,<span class="string">'X'</span>,<span class="string">'V'</span>,<span class="string">'I'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = num/weight;</span><br><span class="line">            appendRoman(sb,n,symbols[index],symbols[index+<span class="number">1</span>],symbols[index+<span class="number">2</span>]);</span><br><span class="line">            num = num%weight;</span><br><span class="line">            weight=weight/<span class="number">10</span>;</span><br><span class="line">            index+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendRoman</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> n, <span class="keyword">char</span> prev, <span class="keyword">char</span> five, <span class="keyword">char</span> one)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">            sb.append(one).append(five);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">9</span>)&#123;</span><br><span class="line">            sb.append(one).append(prev);   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                sb.append(one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(five);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">5</span>;i++)&#123;</span><br><span class="line">                sb.append(one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，数字的长度。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上述解法还有另外一种写法，在一个函数即可完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] romans = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'M'</span>,<span class="string">'D'</span>,<span class="string">'C'</span>,<span class="string">'L'</span>,<span class="string">'X'</span>,<span class="string">'V'</span>,<span class="string">'I'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num/values[i];</span><br><span class="line">            num=num%values[i];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;x;j++) sb.append(romans[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>)&#123;</span><br><span class="line">                sb.append(romans[i]).append(romans[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">4</span>&amp;&amp;x&lt;<span class="number">9</span>)&#123;</span><br><span class="line">                sb.append(romans[i-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;x-<span class="number">5</span>;j++) sb.append(romans[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">9</span>)&#123;</span><br><span class="line">                sb.append(romans[i]).append(romans[i-<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，数字的长度。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>将十进制进一步细分到每次罗马字符变动到数表，如十位划分成90、50、40、10。每次找到当前最大的数，返回结果加上对应的罗马字符并减去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] romans = <span class="keyword">new</span> String[]&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;romans.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num&gt;=values[i])&#123;</span><br><span class="line">                sb.append(romans[i]);</span><br><span class="line">                num-=values[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，数字的长度。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>建立更加详细的数表，把位上的1-9都给列出来，直接查表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String[] m = <span class="keyword">new</span> String[]&#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">        String[] c = <span class="keyword">new</span> String[]&#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">        String[] x = <span class="keyword">new</span> String[]&#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">        String[] i = <span class="keyword">new</span> String[]&#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> m[num / <span class="number">1000</span>] + c[(num % <span class="number">1000</span>) / <span class="number">100</span>] + x[(num % <span class="number">100</span>) / <span class="number">10</span>] + i[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(1)，直接查表。</p>
<p><strong>空间复杂度:</strong> O()。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 011 Container With Most Water</title>
    <url>/posts/12616/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="pic"></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定正整数1, a2, …, an，代表坐标轴横轴上1到n到地方，各有一条垂直到线段，其另一端到高度为正整数到值。<br>两根线及横轴组成了容器，求使容器装最多水到两条线段，并返回装水到面积。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用双指针，定义i和j分别指向数组到左右两端，然后两个指针向中间搜索。<br>搜索到策略是如果左右两端某端的高度要小一些，则将这一端向中间移动，并更新最大面积。<br>因为如果往中间移动高度较高的一端，则面积只会减小，因为最终的面积的高度是由较低的那端决定的，这样高度不变，长度缺减少，面积只能也减小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.length-<span class="number">1</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[i],height[j]);</span><br><span class="line">            max = Math.max(h*(j-i),max);</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，遍历一遍数组。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>也可以在上述解法上小优化，不用每步都计算面积。当确定左侧还是右侧向中间移动后，跳过高度小于上次计算时那侧高度的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.length-<span class="number">1</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[i],height[j]);</span><br><span class="line">            max = Math.max(h*(j-i),max);</span><br><span class="line">            <span class="keyword">boolean</span> moveRight = height[i]&lt;height[j]?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;moveRight&amp;&amp;h&gt;=height[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;!moveRight&amp;&amp;h&gt;=height[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，遍历一遍数组。</p>
<p><strong>空间复杂度:</strong> O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 010 Regular Expression Matching</title>
    <url>/posts/47345/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure>
<p>The matching should cover the entire input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li>s could be empty and contains only lowercase letters a-z.</li>
<li>p could be empty and contains only lowercase letters a-z, and characters like . or *.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>这道题关于正则表达式，’.’表示任意字符，’*’表示其之前的字符可以出现0次或者多次。要求返回字符串是否完全匹配正则表达式。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用递归来解，大致思路如下：</p>
<ul>
<li>当p为空时，若s为空则返回true，否则返回false</li>
<li>当p的长度为1时，若s当长度也为1并且s[0]==p[0]或者p[0]==’.’则返回true，否则返回false</li>
<li>当p的第二个字符不为’*’时，若s为空则返回false，否则判断首字符是否匹配，并且从各自的第二个字符递归调用去匹配</li>
<li>当p的第二个字符为’*’时，进行下列循环，条件时s不为空并且首字符匹配，在循环中递归调用去匹配s和去掉前两个字符的p（假设此时p星号的作用是让前面的字符出现0次）<br>  若匹配则返回true，否则去掉s首字符继续循环（因为首字符已经匹配所以可以去掉s首字符往后面去匹配）</li>
<li>返回递归调用去匹配s和去掉前两个字符的p，因为要处理以下两种情况<ul>
<li>若s为空，则表明p的星号表示出现0次</li>
<li>若s不为空，首字符不匹配，也表明p的星号表示出现0次</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.length()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()==<span class="number">1</span>&amp;&amp;(s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>)&amp;&amp;isMatch(<span class="string">""</span>,p.substring(<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>)&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s.length()!=<span class="number">0</span>&amp;&amp;(s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(isMatch(s,p.substring(<span class="number">2</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s=s.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s,p.substring(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>上面的解法可以换一种写法，让代码更简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.isEmpty()) <span class="keyword">return</span> s.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!s.isEmpty() &amp;&amp;</span><br><span class="line">                               (p.charAt(<span class="number">0</span>) == s.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.length() &gt;= <span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(s, p.substring(<span class="number">2</span>)) ||</span><br><span class="line">                    (first_match &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O()。</p>
<p><strong>空间复杂度:</strong> O()。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>动态规划解法，dp[i][j]表示s[0:i)和p[0:j)是否匹配，从前往进行匹配。</p>
<p>条件判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  P[i][j] = P[i - 1][j - 1], if p[j - 1] != &apos;*&apos; &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;);</span><br><span class="line">2.  P[i][j] = P[i][j - 2], if p[j - 1] == &apos;*&apos; and the pattern repeats for 0 times;</span><br><span class="line">3.  P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;), if p[j - 1] == &apos;*&apos; and the pattern repeats for at least 1 times.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">1</span> &amp;&amp; p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i][j-<span class="number">2</span>]||(i&gt;<span class="number">0</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>)||p.charAt(j-<span class="number">2</span>)==<span class="string">'.'</span>)&amp;&amp;dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=i&gt;<span class="number">0</span>&amp;&amp;(s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span>)&amp;&amp;dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(SP)，S代表字符串长度，P代表正则表达式长度。</p>
<p><strong>空间复杂度:</strong> O(SP)，S代表字符串长度，P代表正则表达式长度。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>使用动态规划，dp[i][j]表示s[i:]和p[j:]是否匹配，从后往前进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        dp[s.length()][p.length()] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> first_match = (i &lt; s.length() &amp;&amp;</span><br><span class="line">                                       (p.charAt(j) == s.charAt(i) ||</span><br><span class="line">                                        p.charAt(j) == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(SP)，S代表字符串长度，P代表正则表达式长度。</p>
<p><strong>空间复杂度:</strong> O(SP)，S代表字符串长度，P代表正则表达式长度。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 009 Palindrome Number</title>
    <url>/posts/5013/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>判断一个int数是否是回文格式，即从前读取和从后开始读取都是一样的。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>首先负数排除，不是回文数字。而0是回文数字。针对正数，可以从后往前读取并累加来找出其反向数字，并和原始数字进行比较。</p>
<p>若反转时溢出，那么最终的结果肯定不会相等，可以不用判断是否溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> reverseNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = x;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="number">0</span>)&#123;</span><br><span class="line">            reverseNum = reverseNum*<span class="number">10</span> + curr%<span class="number">10</span>;</span><br><span class="line">            curr = curr/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseNum==x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，取决于数字的长度。</p>
<p><strong>空间复杂度:</strong> O(1)，只使用int来保存结果。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>首先负数排除，不是回文数字。而0是回文数字。并且如果正数的末尾是0也不是回文。</p>
<p>其他正数只需要验证前后半段是否对称，和解法1相比快了一倍。具体做法是：每次对10取余取出数的末尾，把reverseNum乘以10并加上余数；同时把x除以10。<br>这样当reverseNum大于等于x时停止循环，x即为前半段，reverseNum为后半段。由于回文数的位数可奇可偶，偶数时两者相等，奇数时中间数字在reverseNum最低位需除以10后再比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> reverseNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;reverseNum)&#123;</span><br><span class="line">            reverseNum = reverseNum*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x==reverseNum || x==reverseNum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，取决于数字的长度。</p>
<p><strong>空间复杂度:</strong> O(1)，只使用int来保存结果。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 008 String to Integer (atoi)</title>
    <url>/posts/64402/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Implement atoi which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>Only the space character ‘ ‘ is considered as whitespace character.</p>
</li>
<li><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p>
</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>实现atoi函数将字符串转换为整数。</p>
<p>函数首先尽可能多的丢弃空白字符，直到发现第一个非空字符位为止。 接着从这个字符开始，读入一个可选的正负号，然后尽可能多的读入数字，最后将它们解析成数值。</p>
<p>字符串中在合法数字后可以包含额外的非法字符，对于这些字符只需丢弃即可。</p>
<p>如果字符串的非空字符不是一个有效的整数，或者，当字符串为空或者只包含空白字符时，不需要执行转换。</p>
<p>如果不能够执行有效的转换则返回0。如果得到的数值超出了整数范围，返回INT_MAX (2147483647) 或者 INT_MIN (-2147483648)。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用StringBuilder保存取出的数字，布尔类型保存是否是正数。开始遍历字符串，有以下情况：</p>
<ul>
<li>只有最前面的空格可以忽略</li>
<li>第一次遍历到’-‘或则’+’则更新是否是正数</li>
<li>若为数字<ul>
<li>如果当前已保存的数字为空，且当前数字为0后一位也为0，则忽略</li>
<li>其他则保存进StringBuilder</li>
</ul>
</li>
<li>其他情况则条件不符，退出遍历</li>
</ul>
<p>而后判断长度是否超出Integer的限制，并转成Long判断其具体是否超出Integer区间范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        nt len=str.length();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Boolean positive = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.length()==<span class="number">0</span>&amp;&amp;positive==<span class="keyword">null</span>&amp;&amp;str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sb.length()==<span class="number">0</span>&amp;&amp;positive==<span class="keyword">null</span>&amp;&amp;(str.charAt(i)==<span class="string">'-'</span>||str.charAt(i)==<span class="string">'+'</span>))&#123;</span><br><span class="line">                positive=str.charAt(i)==<span class="string">'-'</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sb.length()==<span class="number">0</span>&amp;&amp;str.charAt(i)==<span class="string">'0'</span>&amp;&amp;i&lt;len-<span class="number">1</span>&amp;&amp;str.charAt(i+<span class="number">1</span>)==<span class="string">'0'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(str.charAt(i));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = String.valueOf(Integer.MAX_VALUE).length();</span><br><span class="line">        <span class="keyword">if</span>(sb.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        positive=positive==<span class="keyword">null</span>?<span class="keyword">true</span>:positive;</span><br><span class="line">        <span class="keyword">if</span>(sb.length()&gt;maxLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> positive?Integer.MAX_VALUE:Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        Long longValue = positive?Long.valueOf(sb.toString()):<span class="number">0L</span>-Long.valueOf(sb.toString());</span><br><span class="line">        <span class="keyword">if</span>(longValue&gt;Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(longValue&lt;Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> longValue.intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，遍历一次字符串。</p>
<p><strong>空间复杂度:</strong> O(n)，使用StringBuilder，取决于字符串长度。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用一个int保存结果，另外一个int保存1或者-1代表正负数。截去字符串前后空格后，开始遍历字符串，有以下情况：</p>
<ul>
<li>首字符为’-‘或’+’则更新正负数</li>
<li>若为数字<ul>
<li>判断当前已保存的结果如果乘以10倍的过程中超出int范围则返回</li>
<li>把当前已保存的结果乘以10并加上当前字符的数值</li>
<li>再次判断是否超出int范围</li>
</ul>
</li>
<li>其他情况则条件不符，退出遍历</li>
</ul>
<p>其中判断是否超出int范围，可以用保存的数和加上当前数值后的符号是否发生变化来判断，因为超出区间后其正负发生反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str=str.trim();</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;curr==<span class="string">'+'</span>)&#123;</span><br><span class="line">                sign=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;curr==<span class="string">'-'</span>)&#123;</span><br><span class="line">                sign=-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr&gt;=<span class="string">'0'</span>&amp;&amp;curr&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                    prev+=num;</span><br><span class="line">                    <span class="keyword">if</span>(num&gt;<span class="number">0</span>&amp;&amp;prev&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;<span class="number">0</span>&amp;&amp;prev&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = <span class="number">10</span>*num + sign*(curr-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">0</span>&amp;&amp;prev&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;<span class="number">0</span>&amp;&amp;prev&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                num=prev;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，遍历一次字符串。</p>
<p><strong>空间复杂度:</strong> O(1)，使用int数字保存。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 007 Reverse Integer</title>
    <url>/posts/8972/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Noted:</strong></p>
<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1].<br>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个32位有符号的整数，找出其反转后的整数。反转后的数字如果溢出，则返回0。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>将数字转成字符串，然后保留符号反转，去除掉最前面多出的0。再将字符串转成Long，比较数字是否在Int的范围，如果不在返回0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(x);</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            result = <span class="keyword">new</span> StringBuilder(s.substring(<span class="number">1</span>)).reverse().toString();</span><br><span class="line">            <span class="keyword">if</span>(result.charAt(<span class="number">0</span>)==<span class="string">'0'</span>&amp;&amp;result.length()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                result=result.substring(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="string">'-'</span>+result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">            <span class="keyword">if</span>(result.charAt(<span class="number">0</span>)==<span class="string">'0'</span>&amp;&amp;result.length()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                result=result.substring(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Long out = Long.valueOf(result);</span><br><span class="line">        <span class="keyword">if</span>(out&gt;Integer.MAX_VALUE||out&lt;Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，取决于数字的长度。</p>
<p><strong>空间复杂度:</strong> O(n)，取决于数字的长度。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>不使用字符串，直接循环取出原始整数的尾数从后往前进行累加。中间注意判断当前结果数是否超出范围。</p>
<p>int的范围是在-2147483648到2147483647之间，边界条件下反转后的最后一位也只能是1或者2，即21474836471和21474836472。<br>再次反转得输入数字1463847412和2463847412，后者超出界限，故输入数字只能是1463847412。<br>所以当反转后数字除以10不需要比较214748364，因为满足条件的只有2147483641。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(result)&gt;Integer.MAX_VALUE/<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(log(n))，取决于数字的长度。</p>
<p><strong>空间复杂度:</strong> O(1)，只使用一个数字保留结果。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>跟解法2类似，使用long来保存中间结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Long result = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            result = result*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result&gt;Integer.MAX_VALUE||result&lt;Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(log(n))，取决于数字的长度。</p>
<p><strong>空间复杂度:</strong> O(1)，只使用一个数字保留结果。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo创建自定义页面的方法</title>
    <url>/posts/56866/</url>
    <content><![CDATA[<h2 id="自定义页面的问题"><a href="#自定义页面的问题" class="headerlink" title="自定义页面的问题"></a>自定义页面的问题</h2><p>只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只默认渲染source目录下的文件，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用Hexo添加自定义的web页面呢？</p>
<h2 id="第一种解决方法"><a href="#第一种解决方法" class="headerlink" title="第一种解决方法"></a>第一种解决方法</h2><p>第一种方法是使用Hexo提供的跳过渲染配置，针对某个文件或者目录进行排除。具体步骤，打开博客根目录_config.yml，找到其中skip_render项，这个项目用来配置/source/中需要跳过渲染的文件或目录。</p>
<a id="more"></a>
<p>假设source目录下的文件如以下目录树所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─ demo</span><br><span class="line">|  ├─ js-view-size</span><br><span class="line">|  |  ├─ 1.html</span><br><span class="line">|  |  └┈ 2.html</span><br><span class="line">|  ├─ other</span><br><span class="line">|  |  ├─ 3.html</span><br><span class="line">|  |  ├─ 4.html</span><br><span class="line">|  |  └┈ 5.md</span><br><span class="line">|  ├─ 6.html</span><br><span class="line">|  └┈ 7.md</span><br><span class="line">├─ baidu.html</span><br><span class="line">└┈ google.html</span><br></pre></td></tr></table></figure>
<h3 id="排除单个文件"><a href="#排除单个文件" class="headerlink" title="排除单个文件"></a>排除单个文件</h3><p>排除baidu.html</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'baidu.html'</span></span><br></pre></td></tr></table></figure>
<h3 id="排除多个文件"><a href="#排除多个文件" class="headerlink" title="排除多个文件"></a>排除多个文件</h3><p>排除baidu.html，google.html和3.html</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'baidu.html'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'google.html'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'demo/other/3.html'</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'*.html'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'demo/other/3.html'</span></span><br></pre></td></tr></table></figure>
<p>排除source/demo/other目录中的所有文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">'demo/other/**'</span></span><br></pre></td></tr></table></figure>
<p>匹配规则是一种类似正则的规则，官方给出的参考是<a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">这个</a>。另外修改了配置后为了及时应用新配置，最好在生成之前执行一下hexo clean命令，清除掉旧的生成文件和缓存。</p>
<h2 id="第二种解决方法"><a href="#第二种解决方法" class="headerlink" title="第二种解决方法"></a>第二种解决方法</h2><p>第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: false</span><br></pre></td></tr></table></figure>
<p>这样，这个文件就不会经过模板渲染，最终发布到/public/里的文件就是去掉标记后的文件的样子。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 006 ZigZag Conversion</title>
    <url>/posts/16365/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>And then read line by line: “PAHNAPLSIIGYIR”</p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>某字符串是基于给定的行数使用锯齿状格式书写，然后逐行读取成字符串。写一段代码完成该转换。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>可以使用nRows长的字符数组来保存格式转换后放置的所有字符。字符数组下标代表行数，该字符代表这一行的所有字符。<br>遍历字符串并将当前字符放入对应的行，然后在遍历该数组，逐行读取所有字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] rows = <span class="keyword">new</span> String[numRows];</span><br><span class="line">        Arrays.fill(rows,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">boolean</span> goDown = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> currRow =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            rows[currRow]+=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(currRow==<span class="number">0</span>||currRow==numRows-<span class="number">1</span>)&#123;</span><br><span class="line">                goDown=!goDown;</span><br><span class="line">            &#125;</span><br><span class="line">            currRow=goDown?currRow+<span class="number">1</span>:currRow-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(String row:rows)&#123;</span><br><span class="line">            result+=row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，只从左到右遍历一次原始字符串。</p>
<p><strong>空间复杂度:</strong> O(n)，使用来字符串数组来保存当前转换后到字符。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>按行直接读取转换后到字符。给定当前第几竖列k，有</p>
<ul>
<li>第0行到字符在原始字符串的下标是k(2*numRows-2)</li>
<li>第numRows-1行在原始字符串的下标是k(2*numRows-2)+numRows-1</li>
<li>在这之间的第i行在原始字符串的下标是k(2<em>numRows-2)+i和(k+1)(2</em>numRows-2)-i</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> cycleLen = <span class="number">2</span>*numRows -<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i+j&lt;s.length();j+=cycleLen)&#123;</span><br><span class="line">                result.append(s.charAt(i+j));</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows-<span class="number">1</span>&amp;&amp;j+cycleLen-i&lt;s.length())&#123;</span><br><span class="line">                    result.append(s.charAt(j+cycleLen-i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，只遍历一次原始字符串。</p>
<p><strong>空间复杂度:</strong> O(n)，使用StringBuilder来保存结果。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 005 Longest Palindromic Substring</title>
    <url>/posts/26628/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，找出最长的回文子串，假定字符串最大长度是1000。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>暴力遍历，外层作为子串的左侧，内层作为子串右侧，检查子串的左侧和右侧是否相等，若不等，则忽略，否则左侧和右侧往中间不断收缩继续检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">        String res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left=i,right=j;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(left)!=s.charAt(right))&#123;</span><br><span class="line">                        flag=<span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;max)&#123;</span><br><span class="line">                    max=j-i+<span class="number">1</span>;</span><br><span class="line">                    res=j==s.length()-<span class="number">1</span>?s.substring(i):s.substring(i,j+<span class="number">1</span>); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n3)，双层遍历，内部循环检查是否回文。</p>
<p><strong>空间复杂度:</strong> O(1)，没有使用额外空间。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>遍历字符串，以当前字符为中心去检查最大回文(奇数长度)，另外以当前字符及当前字符下一位检查最大回文长度(偶数长度)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>,maxLen=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            searchPalindrome(s,i,i);</span><br><span class="line">            searchPalindrome(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right-left-<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">            maxLen=right-left-<span class="number">1</span>;</span><br><span class="line">            start=left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，一层遍历，内部循环检查是否回文。</p>
<p><strong>空间复杂度:</strong> O(1)，没有使用额外空间。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>使用动态规划，维护一个二维数组dp，其中dp[i][j]表示字符串区间[i,j]是否为回文串。</p>
<p>当j=i时，因为只有一个字符肯定是回文串，结果为true。</p>
<p>当j=i+1时，说明是相邻字符，只需要比较s[j]==s[i]。</p>
<p>当j&gt;i+1时，则判断s[j]==s[i] &amp;&amp; dp[i+1][j-1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>, maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            dp[j][j]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                dp[i][j]=s.charAt(i)==s.charAt(j)&amp;&amp;(j&lt;=i+<span class="number">1</span>||dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                    left=i;</span><br><span class="line">                    right=j;</span><br><span class="line">                    maxLen=j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，两层遍历。</p>
<p><strong>空间复杂度:</strong> O(n2)，使用二维数组存储结果。</p>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h2><p>使用马拉车算法Manacher’s Algorithm，这个算法将时间复杂度提升到了O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 004 Median of Two Sorted Arrays</title>
    <url>/posts/40546/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Hard</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个有序数组，长度分别是m和n。找出这两个数组到中位数，总体到时间复杂度要求O(log (m+n))，假定两个数组都不为空。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>中位数是把一组有序数分成两个相等长度的部分，一部分比另外一部分都要大。如果是偶数个，则取最中间两个数的平均数。</p>
<p>如果两个有序数组混合起来成为一个有序数组再去找中位数，肯定很简单，但是时间复杂度应该是O(m+n)，不符合要求。O(log (m+n))提示应该是用二分查找，但是两个数组又如何去做，着实很难。</p>
<p>首先将数组A在随机的位置i切成两部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br></pre></td></tr></table></figure>
<p>因为A有m个元素，所以有m+1种切法(i=0~m)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(left_A)=i,len(right_A)=m−i.</span><br><span class="line">Note: when i = 0, left_A is empty, and when i = m, right_A is empty.</span><br></pre></td></tr></table></figure>
<p>使用同样的方式，把数组B在随机位置j切成两部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure>
<p>把left_A和left_B放到一起合并成left_part，把right_A和right_B放到一起合并成right_part。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure>
<p>如果我们能保证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. len(left_part)=len(right_part)</span><br><span class="line">2. max(left_part)≤min(right_part)</span><br></pre></td></tr></table></figure>
<p>那么我们就成功将数组A和B中所有的元素分成了长度相同的两部分，并且一部分总是比另外一部分大。那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">median= (max(left_part)+min(right_part))/2</span><br></pre></td></tr></table></figure>
<p>为了达到上述两个条件，只需要保证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. i+j=m−i+n−j or i+j=m−i+n−j+1</span><br><span class="line">    如果n&gt;=m，只需要设：i=0~m,j=(m+n+1)/2-i;</span><br><span class="line">2. B[j−1] ≤ A[i] and A[i−1] ≤ B[j]</span><br></pre></td></tr></table></figure>
<p>ps.1 为了简化，假定A[i-1],B[j-1],A[i],B[j]都是有效的即使i=0,i=m,j=0,j=n。后面会介绍这些边界值如何处理。</p>
<p>ps.2 为什么要保证n&gt;=m，因为要保证j是非负数。</p>
<p>所以我们需要做的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在[0~m]中查找i，能够满足</span><br><span class="line">B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j], j=(m+n+1)/2-i</span><br></pre></td></tr></table></figure>
<p>按照以下的步骤进行二分查找</p>
<ol>
<li>初始化imin=0 and imax=m，然后在[imin,imax]进行查找</li>
<li>设置i=(imin+imax)/2 and j=(m+n+1)/2-i</li>
<li><p>已经达成len(left_part)=len(right_part)，只会碰到3种情况</p>
<ul>
<li><p>B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j]</p>
<p>  意味着我们找到了目标i，停止查找</p>
</li>
<li><p>B[j-1]&gt;A[i]</p>
<p>  意味着A[i]太小，必须增大i以达到B[j-1]&lt;=A[i]。当i增大时，j减小，A[i]增大，B[j-1]减小。调整查找范围[i+1,imax]，imin=i+1，跳转到第2步。</p>
</li>
<li><p>A[i-1]&gt;B[j]</p>
<p>  意味着A[i-1]太大，必须减小i以达到A[i-1]&lt;=B[j]。调整查找范围[imin,i-1]，imax=i-1，跳转到第2步</p>
</li>
</ul>
</li>
</ol>
<p>当目标i找到时，中位数是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max(A[i-1],B[j-1])，当m+n是奇数</span><br><span class="line">(max(A[i-1],B[j-1)+min(A[i]+B[j])/2，当m+n是偶数</span><br></pre></td></tr></table></figure>
<p>现在考虑边界值，i=0,i=m,j=0,j=m，此时A[i-1],B[j-1],A[i],B[j]可能不存在。</p>
<p>只需要保证max(left_part)&lt;=min(right_part)，但是当A[i-1],B[j-1],A[i],B[j]不存在时，不需要检查所有的那两个条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j])，当j=(m+n+1)/2-i</span><br></pre></td></tr></table></figure>
<p>在循环搜索时，只会碰到以下三种情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. (j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j])</span><br><span class="line">    意味着i已经找到，可以停止搜索</span><br><span class="line">2. j&gt;0 and i&lt;m and B[j-1]&gt;A[i]</span><br><span class="line">    意味着i太小，要增大i</span><br><span class="line">3. i&gt;0 and j&lt;n and A[j-1]&gt;B[j]</span><br><span class="line">    意味着i太大，要减小i</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n=nums2.length;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> imin=<span class="number">0</span>,imax=m,halfLen=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(imin&lt;=imax)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = (imin+imax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen-i;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;imax&amp;&amp;nums2[j-<span class="number">1</span>]&gt;nums1[i])&#123;</span><br><span class="line">                imin=i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;imin&amp;&amp;nums1[i-<span class="number">1</span>]&gt;nums2[j])&#123;</span><br><span class="line">                imax=i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    maxLeft=nums2[j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    maxLeft=nums1[i-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    maxLeft=Math.max(nums1[i-<span class="number">1</span>],nums2[j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> maxLeft;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> minRight=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==m)&#123;</span><br><span class="line">                    minRight=nums2[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==n)&#123;</span><br><span class="line">                    minRight=nums1[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    minRight=Math.min(nums1[i],nums2[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (maxLeft+minRight)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(log (m+n))，每次调整i都是将其范围减半。</p>
<p><strong>空间复杂度:</strong> O(1)，只使用了固定几个变量保存状态。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-divide-and-conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 003 Longest Substring Without Repeating Characters</title>
    <url>/posts/33885/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，找出不包含重复字符的最长子串的长度。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>使用两层遍历，外层是子串起始字符，内层则进行遍历时检查是否包含重复字符，若不包含则继续往后面移动，直到有重复字符或者到达末尾则结束。</p>
<p>将此子串到最大长度和已保存到最大长度进行对比，去其中大的进行更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(s.charAt(j)))&#123;</span><br><span class="line">                    max = Math.max(max,j-i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    set.add(s.charAt(j));</span><br><span class="line">                    max = Math.max(max,j-i+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，两层循环遍历。</p>
<p><strong>空间复杂度:</strong> O(n)，用来HashSet来存储每次已经遍历过的字符。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashSet中，同时更新最大子串长度。</p>
<p>若检测到HashSet中已经存在该字符，则从HashSet删除窗口左侧元素并移动左侧位置，直到不包含重复字符为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(right)))&#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">                max = Math.max(max,right-left+<span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(2n)=O(n)，一层循环，主要是右侧窗口移动。</p>
<p><strong>空间复杂度:</strong> O(n)，用来HashSet来存储已经遍历过的字符。</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><p>同样使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashMap中，同时更新最大子串长度。</p>
<p>若检测到HashMap中已经存在该字符，则判断已存在字符到位置是否小于窗口左侧，若小于则忽略，否则直接移动窗口左侧到此位置到右侧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;right&lt;s.length();right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right)) &amp;&amp; map.get(s.charAt(right))&gt;=left)&#123;</span><br><span class="line">                left=map.get(s.charAt(right))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(right),right);</span><br><span class="line">            max = Math.max(max,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，一层循环遍历，HashMap操作耗时O(1)。</p>
<p><strong>空间复杂度:</strong> O(n)，用来HashMap来存储已经遍历过的字符。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 002 Add Two Numbers</title>
    <url>/posts/4084/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Medium</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个非空链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。假定两个数不包含任何前置0，除非这个数本身就是0。</p>
<p>这其实就是两个非负整数的加法运算，先从最后一位相加，有进位则保留在下一位中计算进去。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>就是建立一个新链表，然后把输入的两个链表从头往后撸，每两个相加，添加一个新节点到新链表后面。在新链表的头增加一个哨兵节点是非常重要的一个方法，这样就可以解放头结点的作用，方便进行处理。这样遍历时结果链表就可以从哨兵节点作为起始当前节点，返回结果时返回哨兵节点的下一个节点。</p>
<p>While循环条件是只要两个链表当前节点有一个不为空，当其中一个链表当前节点为空时，其值取0，后续节点取null。两个节点值相加，同时还要加上进位，以和对10求余作为新节点对值，添加到结果节点到下一位，并且更新进位。而后更新两个节点，若存在则指向其下一个节点。While退出后若进位不为0则新建节点添加到结果链表的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = l1!=<span class="keyword">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> v2 = l2!=<span class="keyword">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = v1 + v2 + carry;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            l1 = l1!=<span class="keyword">null</span> ? l1.next : <span class="keyword">null</span>;</span><br><span class="line">            l2 = l2!=<span class="keyword">null</span> ? l2.next : <span class="keyword">null</span>;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(max(m,n))，遍历到步长取决于两个链表的最大长度。</p>
<p><strong>空间复杂度:</strong> O(max(m,n))，和的位数取决于最大数的位数。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 001 Two Sum</title>
    <url>/posts/45823/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<p><strong>Difficulty: Easy</strong></p>
<p><strong>Code:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个整数数组，从中找出两个数的下标，使得它们的和等于一个特定的数字。假定每个输入肯定会有一个唯一解，同一个元素不可以使用两次。</p>
<a id="more"></a>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>可以使用两层循环去遍历数组，外层从下标0开始，内层从外层下标+1开始。若外层和内层之和等于目标值则返回外层和内层的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n2)，两层循环的遍历。</p>
<p><strong>空间复杂度:</strong> O(1)，没有使用额外的空间储存。</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>遍历一遍数组，将数字放入以数字为Key以数组下标为Value的HashMap中，在放入前检查HashMap中是否已经存在另外一个数满足两数之和等于目标值。若存在则返回HashMap中数字的下标和当前数字的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度:</strong> O(n)，只对数组遍历来一次，HashMap的操作耗时是O(1)。</p>
<p><strong>空间复杂度:</strong> O(n)，使用HashMap储存数组中的数字。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown扩展语法</title>
    <url>/posts/38514/</url>
    <content><![CDATA[<p>Markdown扩展语法的由来是基本语法不太够用，一些个人和组织添加来额外的元素来扩展基本语法。主要包括表格、代码块、语法高亮、URL自动链接、脚注。</p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>扩展语法并不是在所有的Markdown应用中都能使用，你需要去检查自己的应用使用的轻量级Markdown语言是否支持。</p>
<h2 id="轻量级Markdown语言"><a href="#轻量级Markdown语言" class="headerlink" title="轻量级Markdown语言"></a>轻量级Markdown语言</h2><p>这里列举集中轻量级Markdown语言，很多流行的Markdown应用都使用其中一种。</p>
<ul>
<li><a href="http://commonmark.org/" target="_blank" rel="noopener">CommonMark</a></li>
<li><a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GitHub Flavored Markdown (GFM)</a></li>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" target="_blank" rel="noopener">Markdown Extra</a></li>
<li><a href="http://fletcherpenney.net/multimarkdown/" target="_blank" rel="noopener">MultiMarkdown</a></li>
</ul>
<h3 id="Markdown处理器"><a href="#Markdown处理器" class="headerlink" title="Markdown处理器"></a>Markdown处理器</h3><p>有很多可用的Markdown处理器，都能够允许你增加扩展去使用扩展语法。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用3个或者更多的连字符<code>---</code>去创建每一列的表头，使用竖线<code>|</code>去分割每一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br><span class="line"></span><br><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>可以在表头连字符的左边、右边、两边添加<code>:</code>来达到列文字居左、居右、居中对齐的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&apos;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">Syntax</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Test Text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Header</td>
<td style="text-align:center">Title</td>
<td style="text-align:right">Here’s this</td>
</tr>
<tr>
<td style="text-align:left">Paragraph</td>
<td style="text-align:center">Text</td>
<td style="text-align:right">And more</td>
</tr>
</tbody>
</table>
<h3 id="表格中文字的格式化"><a href="#表格中文字的格式化" class="headerlink" title="表格中文字的格式化"></a>表格中文字的格式化</h3><p>在表格中，可以加入链接、代码、加粗、斜体。</p>
<h3 id="表格中竖线的转义"><a href="#表格中竖线的转义" class="headerlink" title="表格中竖线的转义"></a>表格中竖线的转义</h3><p>可以使用竖线对应的HTML字符编码<code>&amp;#124;</code>来表示<code>|</code>。</p>
<h2 id="带栅栏的代码块"><a href="#带栅栏的代码块" class="headerlink" title="带栅栏的代码块"></a>带栅栏的代码块</h2><p>Markdown基本语法允许使用缩进4个空格或者1个tab来创建代码块。另外你也可以使用3个反引号```或者3个波浪号~~~在代码块的前后来创建带栅栏的代码块，不需要缩进任何行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>很多Markdown处理器支持在带栅栏的代码块中语法高亮，这将使你用任何语言写的代码增加色彩高亮。只需要在反引号后紧接着指定语言，即可实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"firstName"</span>: <span class="string">"John"</span>,</span><br><span class="line">  <span class="attr">"lastName"</span>: <span class="string">"Smith"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注允许你增加笔记和参考在不截断文章内容的前提下。当你创建一个脚注，一个带链接上标数字就会出现在你加脚注的地方。点击链接就可以跳转到页面底部脚注的内容。</p>
<p>在<code>[]</code>中添加异或符号<code>^</code>和标识即可创建脚注引用。标识即可是数字也可是字符，但不能包含空格或者制表符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Here&apos;s a simple footnote,[^1] and here&apos;s a longer one.[^bignote]</span><br><span class="line"></span><br><span class="line">[^1]: This is the first footnote.</span><br><span class="line"></span><br><span class="line">[^bignote]: Here&apos;s one with multiple paragraphs and code.</span><br><span class="line"></span><br><span class="line">    Indent paragraphs to include them in the footnote.</span><br><span class="line"></span><br><span class="line">    `&#123; my code &#125;`</span><br><span class="line"></span><br><span class="line">    Add as many paragraphs as you like.</span><br></pre></td></tr></table></figure>
<h2 id="标题IDs"><a href="#标题IDs" class="headerlink" title="标题IDs"></a>标题IDs</h2><p>可以给标题加自定义ID，这样能链接到标题并且可以通过CSS样式进行修改。在标题后把自定义ID用<code>{}</code>包裹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### My Great Heading &#123;#custom-id&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指向标题到链接"><a href="#指向标题到链接" class="headerlink" title="指向标题到链接"></a>指向标题到链接</h3><p>创建一个标准到链接，链接地址使用<code>#</code>再跟上标题ID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Heading IDs](#heading-ids)</span><br></pre></td></tr></table></figure>
<p><a href="#轻量级Markdown语言">轻量级Markdown语言</a></p>
<h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><p>创建术语到定义列表，把术语放在第一行，下一行用<code>:</code>接一个空格开头，后面写定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>删除线能够在文字到中间加一条水平线，以表示文字是错误的。使用两个波浪线在文字的前后即可创建删除线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~The world is flat.~~ We now know that the world is round.</span><br></pre></td></tr></table></figure>
<p><del>The world is flat.</del> We now know that the world is round.</p>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表可以创建一系列带复选框的事项，使用连字符<code>-</code>加空格，再加<code>[ ]</code>，而后跟事项。选中复选框，使用<code>[x]</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox" checked> Write the press release</li>
<li style="list-style: none"><input type="checkbox"> Update the website</li>
<li style="list-style: none"><input type="checkbox"> Contact the media</li>
</ul>
<h2 id="URL自动生成链接"><a href="#URL自动生成链接" class="headerlink" title="URL自动生成链接"></a>URL自动生成链接</h2><p>很多Markdown处理器能自动将URL转成链接，不用加<code>&lt;&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.example.com</span><br></pre></td></tr></table></figure>
<p><a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a></p>
<h2 id="禁止URL自动生成链接"><a href="#禁止URL自动生成链接" class="headerlink" title="禁止URL自动生成链接"></a>禁止URL自动生成链接</h2><p>如果你不想将URL自动转成链接，你可以将URL当成代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`http://www.example.com`</span><br></pre></td></tr></table></figure>
<p><code>http://www.example.com</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/posts/48840/</url>
    <content><![CDATA[<p>Markdown基本语法，几乎所有Markdown应用程序都支持<code>John Gruber</code>原始设计文档中概述的基本语法。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在标题前插入1到6个#，表示6个不同级别的标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Heading level 1</span><br><span class="line">## Heading level 2</span><br><span class="line">### Heading level 3</span><br><span class="line">#### Heading level 4</span><br><span class="line">##### Heading level 5</span><br><span class="line">###### Heading level 6</span><br></pre></td></tr></table></figure>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落之间用空行隔开，不能使用空格或者缩进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I really like using Markdown.</span><br><span class="line"></span><br><span class="line">I think I&apos;ll use it to format all of my documents from now on.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>在文字中间插入<code>&lt;br&gt;</code>可以进行换行，或者两个空格再回车。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is the first line. &lt;br&gt; And this is the second line.</span><br></pre></td></tr></table></figure>
<p>This is the first line. <br> And this is the second line.</p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>在文字的前后用两个<code>*</code>或者<code>_</code>可以加粗字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I just love **bold text**.</span><br><span class="line">I just love __bold text__.</span><br><span class="line">Love**is**bold</span><br></pre></td></tr></table></figure>
<p>I just love <strong>bold text</strong>.<br>I just love <strong>bold text</strong>.<br>Love<strong>is</strong>bold</p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>在文字的前后用一个<code>*</code>或者<code>_</code>可以变成斜体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Italicized text is the *cat&apos;s meow*.</span><br><span class="line">Italicized text is the _cat&apos;s meow_.</span><br><span class="line">A*cat*meow</span><br></pre></td></tr></table></figure>
<p>Italicized text is the <em>cat’s meow</em>.<br>Italicized text is the <em>cat’s meow</em>.<br>A<em>cat</em>meow</p>
<h3 id="同时加粗和斜体"><a href="#同时加粗和斜体" class="headerlink" title="同时加粗和斜体"></a>同时加粗和斜体</h3><p>在文字的前后用三个<code>*</code>或者<code>_</code>可以同时加粗和变成斜体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This text is ***really important***.</span><br><span class="line">This text is ___really important___.</span><br></pre></td></tr></table></figure>
<p>This text is <strong><em>really important</em></strong>.<br>This text is <strong><em>really important</em></strong>.</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在一段文字中的开头加上 <code>&gt;</code> 来表示一段引用文字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<h3 id="引用多个段落"><a href="#引用多个段落" class="headerlink" title="引用多个段落"></a>引用多个段落</h3><p>在每个段落及空行开头加上 <code>&gt;</code> 来表示引用多段文字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt; The Witch bade her clean the pots and kettles and sweep the floor.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<p>The Witch bade her clean the pots and kettles and sweep the floor.</p>
</blockquote>
<h3 id="引用嵌套"><a href="#引用嵌套" class="headerlink" title="引用嵌套"></a>引用嵌套</h3><p>引用可以嵌套，在段落的开头加上<code>&gt;&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor.</p>
</blockquote>
</blockquote>
<h3 id="引用中使用其他元素"><a href="#引用中使用其他元素" class="headerlink" title="引用中使用其他元素"></a>引用中使用其他元素</h3><p>引用中可以包含其他Markdown的元素，但并不是所有但元素都可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; #### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul>
<li>Revenue was off the chart.</li>
<li><p>Profits were higher than ever.</p>
<p><em>Everything</em> is going according to <strong>plan</strong>.</p>
</li>
</ul>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表可以分为有序列表和无序列表</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表在文字开头加上数字和点，数字并不要求按照顺序，但是起始应该是1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. First item</span><br><span class="line">2. Second item</span><br><span class="line">3. Third item</span><br><span class="line">4. Fourth item</span><br><span class="line"></span><br><span class="line">1. First item</span><br><span class="line">8. Second item</span><br><span class="line">3. Third item</span><br><span class="line">5. Fourth item</span><br><span class="line"></span><br><span class="line">1. First item</span><br><span class="line">2. Second item</span><br><span class="line">3. Third item</span><br><span class="line">    1. Indented item</span><br><span class="line">    2. Indented item</span><br><span class="line">4. Fourth item</span><br></pre></td></tr></table></figure>
<ol>
<li>First item</li>
<li>Second item</li>
<li>Third item<ol>
<li>Indented item</li>
<li>Indented item</li>
</ol>
</li>
<li>Fourth item</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表在每一行开头加上<code>-</code>、<code>+</code>、<code>*</code>，缩进去创建嵌套列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- First item</span><br><span class="line">- Second item</span><br><span class="line">- Third item</span><br><span class="line">- Fourth item</span><br><span class="line"></span><br><span class="line">* First item</span><br><span class="line">* Second item</span><br><span class="line">* Third item</span><br><span class="line">* Fourth item</span><br><span class="line"></span><br><span class="line">+ First item</span><br><span class="line">* Second item</span><br><span class="line">- Third item</span><br><span class="line">+ Fourth item</span><br><span class="line"></span><br><span class="line">- First item</span><br><span class="line">- Second item</span><br><span class="line">- Third item</span><br><span class="line">    - Indented item</span><br><span class="line">    - Indented item</span><br><span class="line">- Fourth item</span><br></pre></td></tr></table></figure>
<ul>
<li>First item</li>
<li>Second item</li>
<li>Third item<ul>
<li>Indented item</li>
<li>Indented item</li>
</ul>
</li>
<li>Fourth item</li>
</ul>
<h3 id="在列表中添加其他元素"><a href="#在列表中添加其他元素" class="headerlink" title="在列表中添加其他元素"></a>在列表中添加其他元素</h3><p>在列表中添加其他元素，要缩进4个空格或者1个tab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   This is the first list item.</span><br><span class="line">*   Here&apos;s the second list item.</span><br><span class="line"></span><br><span class="line">    I need to add another paragraph below the second list item.</span><br><span class="line"></span><br><span class="line">*   And here&apos;s the third list item.</span><br></pre></td></tr></table></figure>
<ul>
<li>This is the first list item.</li>
<li><p>Here’s the second list item.</p>
<p>I need to add another paragraph below the second list item.</p>
</li>
<li><p>And here’s the third list item.</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要表示一行代码，使用<code>`</code>来包裹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">At the command prompt, type `nano`.</span><br></pre></td></tr></table></figure>
<p>At the command prompt, type <code>nano</code>.</p>
<h3 id="反引号转义"><a href="#反引号转义" class="headerlink" title="反引号转义"></a>反引号转义</h3><p>在一行代码中如果代码本身也含有反引号，可以把最外层用两个反引号包裹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">``Use `code` in your Markdown file.``</span><br></pre></td></tr></table></figure>
<p><code>Use `code` in your Markdown file.</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块的每行代码必须最少缩进4个空格或者1个tab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure>
<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
&lt;/html&gt;
</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用三个及以上的<code>*</code>、<code>-</code>、<code>_</code>表示分割线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">_________________</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>用<code>[]</code>包裹链接文字，随后用<code>()</code>包裹URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">My favorite search engine is [Duck Duck Go](https://duckduckgo.com).</span><br></pre></td></tr></table></figure>
<p>My favorite search engine is <a href="https://duckduckgo.com" target="_blank" rel="noopener">Duck Duck Go</a>.</p>
<h3 id="链接添加提示"><a href="#链接添加提示" class="headerlink" title="链接添加提示"></a>链接添加提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best one&quot;).</span><br></pre></td></tr></table></figure>
<p>My favorite search engine is <a href="https://duckduckgo.com" title="The best one" target="_blank" rel="noopener">Duck Duck Go</a>.</p>
<h3 id="网页和邮箱"><a href="#网页和邮箱" class="headerlink" title="网页和邮箱"></a>网页和邮箱</h3><p>为了快速将网页和邮箱转为链接，可以用<code>&lt;&gt;</code>包裹起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;https://www.markdownguide.org&gt;</span><br><span class="line">&lt;fake@example.com&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.markdownguide.org" target="_blank" rel="noopener">https://www.markdownguide.org</a><br><a href="mailto:&#x66;&#x61;&#107;&#101;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x66;&#x61;&#107;&#101;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></p>
<h3 id="格式化链接"><a href="#格式化链接" class="headerlink" title="格式化链接"></a>格式化链接</h3><p>为了强调链接，可以在链接的前后加星号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I love supporting **[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.markdownguide.org)*.</span><br></pre></td></tr></table></figure>
<p>I love supporting <strong><a href="https://eff.org" target="_blank" rel="noopener">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org" target="_blank" rel="noopener">Markdown Guide</a></em>.</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的插入方式是在最开始插入<code>!</code>，然后用<code>[]</code>包裹图片无法加载的描述，再把图片的地址用<code>()</code>包裹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="http://pngimg.com/uploads/google/google_PNG19631.png" alt="Google" title="Google Search"></p>
<h3 id="带链接的图片"><a href="#带链接的图片" class="headerlink" title="带链接的图片"></a>带链接的图片</h3><p>给图片加链接的方式是，把图片的Markdown用<code>[]</code>包裹，再在后面把链接地址用<code>()</code>包裹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;)](https://www.google.com)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.google.com" target="_blank" rel="noopener"><img src="http://pngimg.com/uploads/google/google_PNG19631.png" alt="Google" title="Google Search"></a></p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>如果有些符号是Markdown使用的，但是又想显示，可以在字符前加<code>\</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure>
<h2 id="转义字符列表"><a href="#转义字符列表" class="headerlink" title="转义字符列表"></a>转义字符列表</h2><table>
<thead>
<tr>
<th>Character</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>backslash</td>
</tr>
<tr>
<td>`</td>
<td>tick mark</td>
</tr>
<tr>
<td>*</td>
<td>asterisk</td>
</tr>
<tr>
<td>_</td>
<td>underscore</td>
</tr>
<tr>
<td>{}</td>
<td>curly braces</td>
</tr>
<tr>
<td>[]</td>
<td>brackets</td>
</tr>
<tr>
<td>()</td>
<td>parentheses</td>
</tr>
<tr>
<td>#</td>
<td>pound sign</td>
</tr>
<tr>
<td>+</td>
<td>plus sign</td>
</tr>
<tr>
<td>-</td>
<td>minus sign (hyphen)</td>
</tr>
<tr>
<td>.</td>
<td>dot</td>
</tr>
<tr>
<td>!</td>
<td>exclamation mark</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
