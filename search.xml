<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[访问图片出现403的解决办法]]></title>
    <url>%2Fposts%2F19298%2F</url>
    <content type="text"><![CDATA[访问图片出现403的解决办法有时候在页面里用img标签访问页面图片返回403 forbidden，而浏览器可以直接打开。 是因为图片服务器加了防盗链，会检测访问图片的referer。 总结了一下,有两种方法是可以解决这个问题的: 使用images.weserv.nl方案 使用no-referrer方案 第一种:使用images.weserv.nl方案1234567getImage(url)&#123; console.log(url); // 把现在的图片连接传进来，返回一个不受限制的路径 if(url !== undefined)&#123; return url.replace(/^(http)[s]*(\:\/\/)/,'https://images.weserv.nl/?url='); &#125;&#125; 把图片路径直接传进去,替换一下原来url的http/https.或者直接在图片url前加上https://images.weserv.nl/?url=如: 1https://images.weserv.nl/?url=http://img.zcool.cn/community/01d881579dc3620000018c1b430c4b.JPG@3000w_1l_2o_100sh.jpg 原图片的http://是可以省略的(与上面的getImage函数是一样的结果) 1https://images.weserv.nl/?url=mg.zcool.cn/community/01d881579dc3620000018c1b430c4b.JPG@3000w_1l_2o_100sh.jpg 第二种:使用no-referrer方案http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。 这种方案不仅针对图片的防盗链,还可以是其他标签。 在前端页面头部添加一个meta 1&lt;meta name="referrer" content="no-referrer" /&gt; referrer的几种状态 a标签的referrer 1&lt;a href="http://example.com" referrer="no-referrer|origin|unsafe-url"&gt;xxx&lt;/a&gt; img/image标签的referrer 12&lt;img referrer="no-referrer|origin|unsafe-url" src="&#123;&#123;item.src&#125;&#125;"/&gt;&lt;image referrer="no-referrer|origin|unsafe-url" src="&#123;&#123;item.src&#125;&#125;"&gt;&lt;/image&gt; 说明如果访问gif图片，使用第一种方案是没有gif效果的，只能显示静态图片，这个时候推荐大家使用第二种。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑组装之硬件选择]]></title>
    <url>%2Fposts%2F13466%2F</url>
    <content type="text"><![CDATA[目录 主板 Intel芯片组主板 AMD芯片组主板 主板尺寸 关于品牌CPU 关键参数 Intel CPU后面的数字 Intel CPU后面的字母 AMD CPU后面的数字 CPU天梯图 CPU的主要厂商显卡 显卡品牌：N卡和A卡 关于品牌 核心显卡、主板集成显卡和独立显卡的区别内存条 单通道与双通道硬盘 机械硬盘 固态硬盘电源 功率的选择 80Plus认证 模组选择 电源尺寸 关于品牌散热器 散热器的工作原理 影响散热效果的因素（风冷） 热量传递的效率 风冷散热器的类型 关于品牌显示器 显示器接口 液晶面板 带鱼屏机箱搭配选择如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？参考 硬件知识 组装电脑 电脑主要配件：主板、CPU、显卡、显示器、电源、机箱、内存条、硬盘。CPU、显卡、内存条、硬盘是插在主板上的，电源用来给主板上的部件进行供电，CPU，主板，显卡，内存条、硬盘、电源这几个放在机箱中就构成了我们通常所说的主机。摩尔定律，硬件的性能每隔18～20个月就会提升一倍。 主板主板主要接口：CPU插槽；内存条插槽；SATA硬盘接口；M.2接口(用于M.2接口的固态硬盘)；背板I/O接口；PCLE-X16插槽(用来接显卡)；PCLE-X1插槽(用来接声卡、网卡等)；供电插槽 主板性能指标：芯片组、供电项数目（供电项越多，平分下来每一路的电流就会减小了，减少主板发热 超频时更加稳定）、做工、扩展能力（是否支持USB3.0或者USB3.1，是否支持超频）。 对于主板最重要的就是其稳定能力，其次才是芯片组 因为芯片组有Intel和AMD，所以主板可以根据芯片组分类，英特尔和AMD这两家公司每次发布新的CPU的时候，都会先各大主板厂家发布适配自己CPU的芯片组，意思就是说：“我这边CPU已经做出来了，你们主板厂得按照我的这个标准，做出来的主板才能用我的这个CPU” 如何区分intel主板和AMD主板： intel主板会有亮闪闪的金属扣，且主板的安装位置是一个一个针脚，均匀分布，因为intel处理器是触点式接口 AMD主板没有金属扣，且主板的安装位置是一个一个小凹槽，因为AMD处理器是针脚式接口 Intel芯片组主板芯片组是主板的核心芯片，选对芯片组，主板和CPU才能兼容。 型号字母目前英特尔的芯片组有4个等级，H、B、Z、X分别适配不同的用户，下面只是一个大概的规律，不能以偏概全，比如：H370&gt;B360 H：中低端、入门，不支持超频。价格在300元左右。 B：**中低端、主流，这类主板几乎不能超频（有特殊几个主板能通过人工破解来进行超频），而且仅支持最高DDR4 2666GHz的内存条频率，所以如果你买的CPU是不带K的如 i3-8100；i5-8500这类不支持超频的CPU，或者本身没有超频需求，B系主板是非常划算和有性价比**的选择。价格在500元左右。 Z：**高端，这类主板天生支持超频功能（需要CPU支持，英特尔CPU后面带K的都支持超频**，如i3-8350K;I5-8600K;I7-8700K），同时芯片组支持更多原生的扩展卡槽的接口，而且这类主板通常也支持非常高的内存频率，价格也会贵一些，一般在1000元以上。 X：**特殊、顶级**，这类主板有2066个针脚，也就是只能用英特尔后面带X的CPU。如i9-7960X、i7-7800X。当然这类主板和CPU价格都高的吓人，市场很小众。 H、B、Z芯片组的主板/CPU接口都是 LGA 1151的，X系列的主板/CPU接口是 LGA 2066 字母后面的数字100系列支持英特尔6代CPU，如B150芯片组支持i3-6100、i5-6500、i7 6700等。（intel的100系列主板刷新bios是可以上7代cpu的） **200系列支持英特尔6、7代CPU**，如：B250芯片组支持i3-7100、i5-7500、i7-7700k等。 300系列支持英特尔8、9代CPU，如：B360芯片组支持i3-8100、i5-8500、i7-8700k、i7-9700k、i9-9900k等。 至于后面个位和十位数上的数字，越高代表主板在同等级中越高端。 AMD芯片组主板芯片组是主板的核心芯片，选对芯片组，主板和CPU才能兼容。 型号字母AMD平台的主板芯片组，有A、B、X三个档次 A：低端，这类芯片组的主板不能超频，普通用户使用也足够了。价格大多在500元以下。 B：中端，这类芯片组的主板也能超频，高性能的接口数量要少一些，价格在500元左右，是普通装机用户的性价比选择。 X：高端，芯片组支持更多可以扩展的接口，可以超频。 AMD芯片组的主板CPU接口大都是AM4的，像高端的X399CPU接口是TR4的。 字母后面的数字**300系列支持 一代锐龙，需要更新BIOS才能支持二代锐龙** **400系列支持 一代、二代锐龙** 锐龙二代或一代的用户买300 400系列芯片组的主板都可以 主板尺寸常见的主板板型分为：E-ATX(加强型)、ATX(标准型)、M-ATX(紧凑型)、MINI-ITX(迷你型)。 常见的主板板型对比 E-ATX型主板：高性能主板，一般会有8跟内存插槽，芯片组也多为X等级的，也就是说适用于英特尔以X结尾的CPU，如i9-7960X。价格非常高 ATX型主板：用的最多的主板，俗称“大板”。这类主板由于体型稍大，需要搭配中塔以上大机箱，做工用料较好，扩展接口比较丰富，不过价位略贵 M-ATX型主板：比ATX要短了一些，俗称“小板”，也叫紧凑型主板，其结构为方形。M-ATX主板主要用于小机箱电脑中，如今装机非常主流的主板板型。 MINI-ITX型主板：俗称迷你型主板，结构是方形，主板尺寸小，适合一些迷你小机箱电脑，这种主板通常作为小巧的HTPC电脑，因此这类主板大部分都内置了Wifi模块。 主板小板和大板的区别是什么？主板小板和大板优缺点分析：1、同芯片的主板大板和小板性能没有任何提升，主板尺寸并不会影响到电脑的整体性能； 2、大板相比小板的扩展接口也许会更加丰富，比如大板标配4个内存插槽，而小板有可能是2个或则4个，大板的PCI-E显卡插槽拥有两个，而小板只有一个。此外，PCI插槽方面，大板也更丰富一些，USB方面，大板通常也多出两个； 3、大主板做工用料相对充足，不过价位上也会更加贵一些； 4、大板需要中塔以上大机箱支持，而小主板既能够兼容大机箱，还能够兼容一些迷你机箱，价位上也相对可能实惠一些； 对于买主板是选择小板还是大板，关于这个问题，关键看个人需求。通常来说，组装入门级电脑，选用小巧的M-ATX机箱，那么肯定需要选用M-ATX主板或者迷你主板，对于注重散热并定位中高端或者高端，选用大机箱的装机用户，建议搭配ATX大主板，其扩展、做工更加有优势，一般用户，建议选择M-ATX小主板，价格相对实惠一些，扩展接口也基本足够使用了，属于大众型主板。 关于品牌华硕：三大板厂之一，主板的BIOS界面做的超一流，简单易懂，好用，而且功能很多。高端主板非常强，中低端主板与其他牌子拉不开差距。ROG玩家国度系列主板用料豪华，超频能力非常强，是最高端主板的象征。 技嘉：三大板厂之一，技嘉的主板一般比较耐用。AROUS系列主板定位高端，类ROG玩家国度。 微星：三大板厂之一，微星的板子跟华硕技嘉都差不多，BIOS比华硕稍差一些，价格也低一点点。 华擎：华擎是华硕的子公司，是华硕面对中低端市场与二三线品牌竞争的品牌，在低价位中用料算是不错的，性价比高，价格比三大厂要低一两百块，被称为价格屠夫。 映泰：映泰也是台湾的主板大厂，主板相对来说稍微低端一些，稳定性可以，价格也很低。 七彩虹：七彩虹的品牌宣传做的好，线下电脑城卖的好，但线上销量有点凄惨，不建议购买。 高端板子最好选择华硕的，低中端主板最好选择技嘉、华擎的。 CPUCPU有几个重要的参数：架构、主频(频率)、核心数、线程数、缓存、最大睿频。 关键参数主频：CPU的工作频率，我们可以直接理解为运算速度，主频越高，计算能力越强，现在CPU主频都以GHz为单位。 最大睿频：睿频是指当启动一个运行程序后，处理器会自动加速到合适的频率，而原来的运行速度会提升 10%~20% 以保证程序流畅运行的一种技术。 核心数与线程数：核心数就相当于有多少只手，线程数就相当于你能同时干几样活，核心数*线程数=马路宽度，频率等于车速 架构：架构对性能的影响最大。一般来说，每一代CPU的架构都是一样的， 缓存：位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。有一级缓存和二级缓存，一级缓存的容量基本在4KB~64KB，二级缓存的容量则分为128KB/256KB/512KB/1MB/2MB等，一级缓冲容量相差不大，二级缓存容量则是提高CPU内存的关键。 如果玩游戏，就需要选主频高的，简单粗暴的进行计算。如果做图形渲染，建议多核心多线程的 CPU有两家厂商在做Intel和AMD，处理器有两种接口接口类型，AMD的CPU是针脚式，Intel的CPU是触点式，由于intelCPU采用了触点式所以intel主板就必须有针脚，而AMD则是与之相反，CPU使用针脚，主板采用触点式。虽然方式不同，但是从性能上完全没有区别，主要AMD的处理器针脚特别怕弯，弯了或者断了处理器基本就要凉凉了。而intel处理器就不会这样，不过intel主板的针脚也极易容易弯折。现在AMD也推出了自己的触点式处理器——线程撕裂者，以后AMD处理器也会朝着触点式发展。 Intel CPU：稳定性强，功耗低（发热量少，常规散热系统），兼容性强 AMD CPU：爆发力强，多线程（适合画图）、功耗高（发热量大，散热系统需要规划） Intel CPU和AMD CPU在相同性能下，价格往往AMD会更加实惠，换句话说相同价位的CPU，AMD的性能普遍更强，说虽然这么说，但是还是要看个人需求，毕竟这两款CPU的针对性不同，当然对于AMD的高端CPU散热量和Intel差不多，不用很担心AMD处理器散热问题。 Intel CPU后面的数字 以i5 3450U为例 第一位**数字 **是i 后面的数字代表的是家族名称。 第二位**数字 **“3”代表它是第几代架构的产品，后面的三位数字是CPU型号，一般越高越好， 第三位数字 “4”代表的是处理器等级。 第四位和第五位数字 “50”代表处理器的频率。如果后面还有@ 3.0GHz @ 3.0GHz，前一个是主频后一个是睿频 Intel CPU后面的字母K代表不锁倍频的处理器；也就是可以超频； M代表标准电压cpu，可以拆卸的； U代表低电压节能的，可以拆卸的； X代表高性能，可拆卸的； Q代表至高性能级别； H是高电压的，是焊接的，不能拆卸； Y代表超低电压的，除了省电，没别的优点的了，是不能拆卸的； F代表不带内置显卡(核显) 两个字母的，属于上面这些特性的组合 相同性能的CPU，Intel的CPU价格要比AMD贵，且Intel的CPU功耗比AMD处理器功耗低。如果手头预算不多，建议选择AMD的CPU，而手头宽裕的话，建议选择Intel的CPU。相比而言AMD 的CPU性价比较高。 AMD CPU后面的数字 以R5 1500X为例 第一位数字 是R 后面的数字代表的是家族名称。 第二位数字 “1”代表它是第几代架构的产品， 后面的三位数字是CPU型号，一般越高越好， X代表支持完整的XFR技术（带X的超频能力更强，而且超频是全自动智能的）。 CPU天梯图 想要看更详细的CPU性能天梯图请移步：http://www.mydrivers.com/zhuanti/tianti/cpu/index.html 中关村CPU性能天梯图：https://cpu.zol.com.cn/soc/ 注意事项：选购CPU、主板的时候要特别注意接口时候匹配 CPU的主要厂商 Intel：主要有赛扬（Celeron）、奔腾（Pentinum）、酷睿2（Core2）、酷睿i（Core i）这三个系列，赛扬系列以低端产品为主，奔腾系列以低端和低中端产品为主，Core2以低端和中低端产品为主，Core i系列以中端和高端产品为主，酷睿i3 i5 i7 是英特尔主流的处理器家族。总的来说，性能强弱为赛扬&lt;奔腾&lt;酷睿2&lt;酷睿 i。但是不是绝对的，还要看该系列的产品是第几代的，比如酷睿2系列的CPU不一定就绝对地比奔腾系列的CPU性能强，从天梯排行中就可以看出来，Pentinum E5700&gt;Core2 duo E4300. AMD：主要有锐龙(Ryzen，性价比)、AMD FX(推土机，高端)、APU(以四核为主)、速龙（Athlon，性价比）、闪龙（Sempron），这几个系列，闪龙系列主要以低端产品为主，速龙以低端和低中端产品为主，弈龙主要以中端和高端产品为主，A系列（A系列集成了显卡芯片）主要以低中端和中低端产品为主，FX系列以中高端和高端产品为主。总的来说，性能强弱为：闪龙&lt;速龙&lt;A系列&lt;弈龙&lt;FX。但是这个也不是绝对的。比如弈龙1代的很多产品性能就比不上速龙2代的产品。AMD现在只有锐龙系列的CPU值得买 显卡 显卡的性能指标：架构、流处理器个数、GPU频率、核心频率、显存带宽、显存大小（按重要程度排序） 架构：越新越好 流处理器：简称SP，也叫渲染管，是显卡最重要的参数，流处理器的数量直接影响显卡的性能，流处理器越多，显卡画图能力越强，速度越快(同一代的显卡比较流处理器才有意义)。 GPU频率：GPU频率越高，性能越强，发热也越大，功耗越高；频率低，性能弱，发热也越小。 显存带宽：显存带宽=显存位宽×显存频率，显存位宽就相当于公路路宽，显存频率就像汽车的速度，所以，显卡位宽和显存频率对显卡的性能影响很大。 显存容量：显存能提供临时的存储功能。很多奸商会把显存当做显卡的卖点来忽悠小白，这里要说的是，大显存有用，但不是那么的重要。举个例子：显存是停车场，如果停车场的马路不够宽（位宽 bit），汽车的速度也不够快（显存频率MHz)，那么这个停车场的吞吐量就很小，修一个超大的停车场纯属浪费资源。 显卡品牌：N卡和A卡 Nvida Geforce——N卡N卡有GT、GTS、GTX这几个系列。 GT是普通系列，而GTS和GTX是中高端系列的，如果后面跟了 Ti 表示是该型号的的加强版。 在选择N卡来说，一般看第一位数字和第二位数字， 第一位数字 第几代显卡 第二位数字 表示是该系列的低端、中端还是高端。1，2，3的话表示是该系列的低端产品；4，5，6表示是中端产品，7，8，9表示是高端产品，比如GT610就是第六代的低端显卡，还有一点就是产品低一代的话，而第二个数字高一点的话，两个显卡的性能基本很接近的，比如GT640和GT550，GT640是第六代的显卡，GT550是第五代的显卡，而GT550第二位数字是5，GT640第二位数字是4，通常来说，像这样的情况下，两个显卡的性能是很接近的。 第三位数字 “0”表示常规显卡，“5”表示升级版 N卡优缺点 设计侧重点：3D性能和速度， 性能运算：执行效率高，但运行能力较低 视频处理：色彩稍淡，需要手动调节分辨率 ATI——A卡ATI(已经被AMD收购)，A卡；N卡有镭、HD、R、X系列。 第一位数字 表示是第几代， 第二位数字 表示该系列的低端、中端还是高端。4，5的话表示是低端；6，7表示是中端；8，9表示是高端。 第三位数字 “0”表示常规显卡，“5”表示升级版 A卡优缺点 设计侧重点：2D平面画质 性能运算：运算能力强大，但执行效率不高，对于复杂的任务适应性不强，需要软件的支持 视频处理：自动调节分辨率，色彩还原度高 娱乐一下 相同性能情况下N卡价格比A卡贵，A卡的性价比相对来说要高一点。现在来说，N卡和A卡区别不大，普通用户根本用不出来区别。但是A卡较N卡性价比高是真的。有时候我们看到一个显卡相同的型号，但是却买不同的价格，其主要原因是因为显卡的核心频率、散热设计等不同。 关于品牌目前较大的显卡品牌有：华硕、技嘉、微星、蓝宝石、索泰、映众、七彩虹、影驰等。 华硕：三大显卡厂之一，显卡用料好、散热猛、售后好、价格高。ROG玩家国度系列在性能、散热、外观等各个方面都几乎完美，但是就是贵。 技嘉：三大显卡厂之一，显卡做工用料都很好。旗下有AORUS系列，定位类似ROG玩家国度，价格和玩家国度也差不多。 微星：三大显卡厂之一，是三大厂中性价比最高的。微星红龙系列显卡性能和用料还是很强的，而且价格要便宜一些。 蓝宝石：是AMD最忠实的合作伙伴，A卡最强厂家。 索泰：索泰和映众都是香港柏能旗下的品牌，索泰被称为“堆料狂魔”，显卡性能极强，核心频率调的很高，性能甚至超越三大厂，价格还便宜，但是高频带来的散热问题较大，可能会比较吵。 映众：映众跟索泰的做法刚好相反，映众在显卡的核心频率上没索泰那么激进，为了散热和静音将显卡频率调低了一点点，牺牲了小部分性能。映众冰龙系列散热极佳，风扇非常静音，价格也较低。 影驰：影驰的显卡其实也是非常不错的，名人堂系列显卡用料足，外观也很好看，但是价格非常非常高，性价比很低，感觉不如买三大厂的旗舰型号。 七彩虹：七彩虹也被称为“凄惨红”，七彩虹在十年前的名声并不好，但是现在七彩虹的igame系列显卡做的还可以，价格和性能都中规中矩。如果遇上打折力度较大，也是可以选择的。 核心显卡、主板集成显卡和独立显卡的区别核心显卡：处理器集成显卡就是指集成在cpu内部的显卡 集成显卡：集成在主板北桥中的显卡，目前处理器核心显卡性能已经领先于主板集成的显卡，并且将显卡集成在CPU中比集成在主板中更有优势。新的主板厂商已经不会在主板上集成显卡了。 独立显卡：我们自己加的独立的显示芯片，采用PCI接口插槽。 注意：下图左边NVIDIA卡的支持光追改成RTX了，不支持光追的还是GTX 想要看更详细的显卡性能天梯图请移步：https://www.mydrivers.com/zhuanti/tianti/gpu/index.html 中关村显卡性能天梯图：http://vga.zol.com.cn/soc/ 内存条 DDR内存，目前分为4代。每到新一代的内存的开发，都是为了解决上一代内存速度极限的问题，DDR2到了1066就不能再高了，而DDR3是从1066起步的，DDR3内存条基本上到了2400的频率，就上不去了。而DDR4代，从2400起步，同之前的内存是一样的。所以，这个其实是根本区别。再高的频率，意味着更大的带宽，就可以更好的适应新的CPU的要求。 DDR3 支持频率有6种：800Mhz(DDR2和DDR3换代时候的产品)、1066Mhz(DDR2和DDR3换代时候的产品)、1333Mhz(常见)、1600Mhz(常见)、1866Mhz(高端电脑配备)、2400Mhz(高端电脑配备) DDR4 支持频率有6种：2133MHZ(常见)、2400MHz(常见)、2666MHz、2800MHz、3000MHz、3200MHZ、3300MHZ， 内存最高频率 &lt; 主板最大支持频率 内存是CPU与硬盘之间的传输的中间设备，以DDR4为例，内存条的读写速度相比于硬盘快很多很多很多。 内存的主要参数：频率、时延、颗粒、容量、下行速度（按重要程度排序） 频率和时序：我们经常看到的2133MHz、2400MHz、3200MHz就是内存条的频率，它可以看成是内存条数据的传输速度，超高频率的内存条固然能给游戏带来一点性能提升，但是需要更高端的主板和CPU的支持，普通用户选择2400MHz的也已经足够用了，频率是内存条最重要的参数。 还有一个重要参数就是时延，一般用CL表示，时延就是寻址所需的时钟周期。同一频率的内存条时延越低越好。 现在普通的DDR4代内存条一般为频率2400MHz，时序CL15-17左右。但是一些使用极品颗粒的超频内存条如三星的B-die颗粒就可以轻松做到频率3200MHz，而且时序只有CL12。这类极品内存条可以做到保证时序不超标的情况下，超频上4000MHz以上。 几乎所有的DDR4代的内存条默认的频率只有2133MHz，所以即使你买的是高频内存条，也需要在主板BIOS设置中打开XMP（自动超频）或手动设置超频后才能达到商家所给出的频率，而且，很多主板并不支持超过2666MHz以上的频率，所以即使你的内存条是4000MHz的神条，也会自动降频到2666MHz使用，这个需要用户去看主板上的说明。 内存条颗粒：颗粒就是内存条的存储数据的东西，现在主流的颗粒生产商就是 三星、海力士、镁光这三家。由于颗粒在生产时候会有质量参差不齐的情况，所以一些成色极品的颗粒会被挑选出来做成高端超频内存条，而一些成色普通但合格的颗粒会被拿去做成普通内存条。至于怎么看颗粒的好坏，我们可以从内存条的频率和时序来做一个购买前的初步判断。 内存条容量：容量越大，存储的数据越多。每打开一个软件，这些软件的数据都会被保存到内存条中，如果内存条被塞满，我们继续打开其他软件的时候，CPU就只能从速度超慢的硬盘调取数据了 单通道与双通道CPU与内存条之间需要交换数据，就有上行数据(内存条数据传入CPU)和下行数据(CPU数据传入内存条) ，如果只有一根内存条，那么上行数据和下行数据的传输就需要占用一条通道，争抢通道的使用权限和带宽。如果有两根内存条组双通道，那么上行数据和下行数据的传输就可以分别在两根内存条之间分别传输，互不影响。 一般来说，两根相同规格的内存条插在主板对应的位置上就可以组成双通道了（看B站斜耳朵UP主说的）。 双通道能够给计算机带来5%左右的性能提升，双通道最大受益者是集显/核显，因为CPU要同时负责程序数据和显示数据的处理，需要的数据流量更大，所以双通道带来的双倍带宽才能满足这么大的数据流量的需求。英特核显可以提高20％性能，amd核显可以提升30％-50％。 内存条选择注意事项： 对于普通用户，选择内存条的时候，一般来说4g就可以了，最多8g，16g的内存条看需求，如果自己也不知道自己需要多少容量的，可以先买一根8GB的使用，发现不够可以再买一根8GB组双通道。 如果有两根或多根不同频率的内存条同时使用，会以频率最低的来统一频率。比如有一根2133MHz、一根2400MHz、一根3200MHz的内存条同时使用的话，所有内存条都是按照2133MHz来使用。所以一般组双通道建议购买两根相同规格的内存条插在主板对应的位置上。所以如果是升级内存条的用户，一定要看看已有的是多少频率的，不要盲目购买高频内存条。 有4根内存插槽的主板，你把内存条插满它依然是双通道的 关于内存条PCB板的层数，层数越多，电路板内部的电路走线层数增加，每一层的电路走线就不会那么拥挤了，这样会有更好的电气性能，使得超频更加稳定。 AMD锐龙平台用户可以选择芝奇、英睿达等牌子的内存条，可以兼容。 关于品牌：各个主流品牌之间内存条价格差距不大，普通用户建议在 芝奇、英睿达、海盗船、影驰、金士顿、威刚、阿斯加特、十铨、宇瞻等这几个品牌中对比挑选一款频率、时序、价格都不错的内存条，然后认准官方自营旗舰店、官方旗舰店，因为内存条官方都会终身质保。 硬盘 我们都知道木桶的短板效应，就电脑的速度来说，CPU缓存、显卡缓存、甚至是内存条都是以至少十倍百倍以上的速度差距远远的超过了所有的机械硬盘的，这就一定会给电脑的性能带来一些瓶颈。固态硬盘的存储速度是机械硬盘的5-10倍左右，多少能弥补一些硬盘在速度上的短板，所以如果你觉得你的旧电脑有些卡，反应慢，换一块固态硬盘绝对能给你的旧电脑带来新的生命。 机械硬盘 机械硬盘是利用磁性来记录信息数据，原理类似与小时候听歌用的磁带，如果我们需要找到某个数据，磁盘就会转动到记录这个信息的部位，然后由磁头感应磁性来读取数据。 注意事项：硬盘建议选择西部数据和希捷的，我个人倾向于西部数据，相比而言稳定一点，硬盘的转速有7200转和5400转的，最好选择7200转的，西部数据硬盘有三种：黑盘，蓝盘和绿盘，在买硬盘的时候注意千万不要买绿盘，最好选择蓝盘或者黑盘（价格有点贵）。好像现在又出了红盘，具体不是很清楚。 固态硬盘 固态硬盘（SSD）是利用电流来记录信息数据，原理类似与MP3，如果我们要找到某个数据，直接去找到存放数据的区域，就可以直接读取了。 固态硬盘的性能参数：固态硬盘的颗粒、主控、缓存、3D NAND堆栈技术、接口\总线\协议、（按重要程度排序） 颗粒闪存颗粒是固态硬盘用来存储数据的东西，分为SLC、MLC、TLC三种，是挑选固态最重要的参数。 SLC：每个存储单元存储1bit的数据。这种存储方式稳定性最强，读写速度很快，而且不会出错，寿命长，但是成本高。 MLC：每个存储单元存储2bit的数据，速度会比SLC慢一点，稳定性较强，寿命还好，但是价格贵。 TLC：每个存储单元存储3bit的数据，效率低、速度慢、还容易出错、寿命相对于上面两种短一些,，说虽这么说，但是现在使用最多的还是TLC，重度使用5年是没有问题的，且价格相对便宜。 现在世界上能自主生产颗粒的厂家有：intel、三星、闪迪、东芝、镁光（英睿达）、海力士。所有正规的固态硬盘使用的都是这几家的检验合格的原厂颗粒。如使用自家颗粒的intel、三星、闪迪、镁光（英睿达）、东芝等；还有虽然自己不会生产颗粒，但是使用从原厂购买颗粒的浦科特、海盗船、建兴等。 主控 主控很重要，就相当于颗粒的管理员。比较好的主控品牌有：马牌（Marvell）、SandForce、三星、intel、东芝等 缓存 和前面一样，缓存就是CPU和固态硬盘之间的缓冲区，方便传输，缓存越大越好 总线 总线有SATA总线、PCI-E总线(PCIE×1、PCIE×2、PCIE×4、PCIE×8、PCIE×16 数字越大，速度越快)目前固态硬盘用的都是PCIEx2和PCIEx4的总线，显卡是PCIEx16总线 传输协议 传输协议有：IDE(老的机械硬盘)、AHCI(机械硬盘)、SATA(目前主流硬盘协议)和NVMe(高速度低延迟)。越后面传输速度越快，拥有NVME协议的固态硬盘速度比无NVME协议的固态硬盘快很多。 接口目前固态硬盘接口有：SATA、mSATA、M.2、PCI-E SATA接口：属于老式的接口，分SATA 3GB和SATA6 GB，我们的机械硬盘使用的也是这种接口。这种接口速度稍慢，延迟稍高，最大速度不会超过600MB/s， mSATA接口：这种接口不多，一般用在笔记本上 M.2接口有两种：B key和M key。 B key M.2接口：又称“SOCKET 2”，豁口在左边，比较老，支持PCI-Ex2总线和SATA总线，速度比较慢 M key M.2接口：又称“SOCKET 3”，豁口在右边，目前主流，支持PCI-Ex4总线，速度比较快 B&amp;M型接口的固态硬盘兼容性好，两种M.2的插槽都能用，性能和B key差不多。 PCI-E接口：一般这个插槽是给显卡用的，但也可以用它来插固态硬盘，这个长得跟显卡一样的固态硬盘也是 PCI-E ×4的接口，支持PCI-E ×4的总线。但是现在的主板大多数是没有PCIE-4的插槽的。所以一般都是接在显卡的插槽里使用的。 4KB随机读写：固态硬盘虽然顺序读写速度超快，但是那是只有在读写一整个大文件（如一部电影）时才能体会到它的优势，而影响我们日常使用的是硬盘的4KB 随机读写速度 排名 固态硬盘推荐： 120GB装个系统，装几个日常软件、装一个大型游戏就差不多满了，建议首选240GB容量。 新配电脑的用户建议选择M.2接口的硬盘，因为这是未来的主流。老电脑升级的用户要检查主板是否有M.2插槽。 4k读写性能才是影响日常体验的重中之重，购买前需要重点关注。 电源 电源的选择是最容易被我们忽略，又非常重要的一项，我们的核心部件如：CPU、固态硬盘、内存条都是由额定电压的。如果如果供电不稳定忽高忽低，很容易造成元器件的损坏与老化。理想情况下，供电12V就是12V，但是市面上几乎没有一款真正能做到0偏差，intel CPU对电压的要求是偏差不超过±5±5\pm5%，电源的好坏和品牌没有绝对的关系，即便是品牌好的牌子如海盗船，也依然有差的电源，如：VS系列。 功率的选择直流输出中+12V的，是给CPU和显卡供电的电压和电流。最好买单路12V的，因为双路12V的会限制CPU和显卡的使用功率，单路的直接给他们，谁需求多谁就取得多。买电源的时候，+12V的直流电源功率大于显卡和CPU的额定功率就不会出问题。 80Plus认证 80Plus认证是一个电源转换率标准，转化率越高，也就越省电。就是说，如果你的电源额定功率是500W的白牌电源（满载转化率为80%），那么当你的电源满载时，你家电表实际用电为：500÷80%=625W 注意：80plus认证仅仅是转化率标准，不能直接反应电源的好坏，所以这个指标在购买时仅作为参考就行了。 电源用料：日系电容&gt;台系电容&gt;国产电容（大概排名，不绝对） 模组选择 非模组：非模组电源价格便宜，但是全部线材固定，多余线头不能拆卸，理线稍微麻烦一些。 半模组：比非模组贵一点，重要线材固定，部分线材可拆卸，可以去除多余线材。 全模组：价格最贵，全部线材可拆卸，美观，方便理线。 电源尺寸 一般来说选择ATX的电源就够了，SFX尺寸的电源一般用在MINI型机箱上面。 关于品牌振华（super flower）：台企，振华电源有战碟、金蝶、金蝶GX、Leadex这几个系列，建议从金蝶开始买起， 海韵：台企，海韵的电源清一色日系电容，用料很不错。 酷冷至尊：台企，全日系电容，全模组，性价比高，稳定性很好。 美商海盗船：美企，海盗船的电源一定要买高端的，也就是800元起步，低端的VS系列价格高，配置低，臭名在外； EVGA：美企，EVGA的电源500元以下的都不建议买，性价比太低了。高端的如G、P、T系列都是全日系电容，主流的LLC半桥+ DC-DC 结构。质保7-10年，性价比稍低。 讯景（XFX）：讯景低端的XT2电源（价格在300左右）不建议买，因为虽然价格不低，但是电源方案很落后，高端点的XTR、XTS系列价格在500元以上，方案主流，可以购买，但性价比稍低。 台达：台企，台达是世界最大的电源生产商，主要是做服务器电源和高端专业的电源解决方案，在零售商做的不是很多。有几款在售的电源如NX系列和VX静音王系列价格便宜，全日系电容用料很不错，很耐用。 航嘉：深圳企业，国内老牌电源厂商，型号多，价格从100-1000都有。航嘉的电源是国内做工非常好的，低端电源也比国内杂牌好的很多，安全有保障，300元以内还是推荐买的，超过300的还是建议去买酷妈和振华。 鑫谷：东莞企业，国内老牌电源厂商，比较推荐的是GP 白金版，使用日系和台系电容，而且是白金牌认证，电压波形很稳，价格也很便宜，性价比很高。 注意事项： 不要不舍得为电源花钱，多花100块钱有时就能拯救你好几块儿机械硬盘。 功率选择不要看厂家标多少瓦，主要看+12V，把显卡和CPU满载功耗加起来还有几十瓦余量就够了。 80PLUS金银铜牌认证仅代表电源转化效率，高转化率更加省电，但是不能完全评判电源的好坏。 建议购买使用 LLC半桥+ DC-DC方案，使用日系、台系电容的电源。 尽量购买大品牌的电源，虽然贵一点点，安全有保障，不至于翻车烧坏主板。 航嘉电源功率计算器：航嘉电源功率计算器 输入你要买的主板、CPU、显卡型号 它就会自动计算出你电源的待机功率和最大功耗，然后推荐出适合你的电源型号 散热器 如果电脑散热不良，CPU的温度过高，CPU为了保护自己不被烧坏，首先会自动降低频率来减少发热，这会导致电脑性能下降，其次降频之后如果温度还是过高，CPU就会自动触发电脑死机来保护自己。所以保证良好的散热还是很有必要的。 散热器的工作原理传热底座与CPU紧密接触，通过导热装置，将CPU产生的热量传导至散热鳍片，然后由风扇吹走鳍片上的热量。 导热装置有三种 ①纯铜（纯铝）导热：这种方式导热效率比较低，但是结构简单，价格便宜，很多原装散热器都是这种方式。 ②导热铜管：这是现在最常用的方式，它的铜管是中空的，里面注有一种导热液，温度升高时铜管底部的液体蒸发吸收热量，将热量传递给散热鳍片后温度降低凝结成液体，流回铜管底部，如此循环，导热效率很高。所以现在的大部分散热器都是这种方式。 ③水冷散热：严格来说它并不是水，是一种导热率很高的液体。它是通过水将CPU的热量带走，然后高温的水在通过曲曲折折的冷排（结构跟家里的暖气片差不多）的时候被风扇吹走热量，变为凉水再次循环。 影响散热效果的因素（风冷） 热量传递的效率热量的传递效率是散热的关键，影响热量传递效率的因素有以下4点。 热管的数量以及粗细热管根数越多越好，一般2根凑合，4根够用，6根及以上就是高端散热器了；热管越粗越好（大部分为6mm,也有8mm的）。 传热底座的工艺： ①热管直触：这种方案的底座非常普遍，一般的百元及以下散热器都是这种的。这种方案为了保证与CPU接触面的平整，会把铜管拍扁、打磨，这使得本来就很薄的铜管更薄了，时间久了就会出现凹凸不平的现象，影响导热效率。正规大厂都会把铜管打磨的非常平整，这样就与CPU的接触面积更大，导热效率高。一些山寨厂家的铜管凹凸不平，导致有些铜管工作时根本接触不到CPU，所以再多铜管也只是花架子。 ②铜底焊接（镜面打磨）：这种方案的底座价格稍微贵一些，因为把传热底座直接做成镜面，接触面积更高，导热效果也更好。所以中高端的风冷散热器都是用这种方案。 ③均热板：这是一种很少很少见到的方案，原理类似于热管，也是通过液体遇热蒸发，然后遇冷液化来传递热量，这种方案导热均匀效率高，但是成本很高，所以很少见。 导热硅脂 由于制造工艺问题，散热器底座与CPU之间不可能有完全平整的接触面（即使你看上去很平整，但是在放大镜下是能看到凹凸不平的），所以就需要涂一层导热系数较高的硅脂来填补这些凹凸不平的地方帮助导热。硅脂的导热系数比铜低很多，所以只要均匀的涂上薄薄的一层就好了，如果涂太厚，反倒影响散热了。一般好的硅脂的导热系数在5-8之间，也有非常昂贵的导热系数在10-15。 散热鳍片与热管交接处的工艺热管是穿插在鳍片之间的，要把热量传递到鳍片上，所以他们交接地方的处理工艺也会影响导热性，目前的处理工艺有两种 ①回流焊：顾名思义就是将两者焊接到一起。这种方案成本较高，但是导热性能好，而且很牢固，不容易出现鳍片松动的现象。 ②穿fin：也叫“穿片”工艺。顾名思义就是在鳍片上开孔，然后借助外力将导热铜管插进鳍片里。这种工艺成本较低，虽然简单，但是要想做好却并不容易，因为要考虑接触不良、鳍片松动等问题（如果你随手一拨，鳍片就在热管上滑动，导热效果可想而知了）。 鳍片与空气的接触面积大小鳍片承担着散热的重任，它的任务是将热管送来的热量散发到空气中，所以鳍片必须尽可能多的与空气进行接触，有些厂家会细心的设计一些凸点来尽可能大的增加鳍片的表面积。 风量风量表示每分钟风扇能送出风的总体积，一般用CFM表示。风量越大，散热也就越好。关于风扇的参数还有：转速、风压、扇叶尺寸、噪音等。现在大多数风扇都支持PWM智能调速，我们需要关注的也就是风量、噪音等。 风冷散热器的类型风冷散热器有三种类型：被动式散热（无风扇设计）、塔式、下压式。 1、被动式散热：它其实就是一个无风扇版的散热器，全靠空气流通带走鳍片上的热量。 优点：完全没有噪音。 缺点：散热性能差，适合发热量特别小的平台（我们的手机几乎都是被动式散热，甚至不如被动式散热）。 2、下压式散热：这种散热器风扇是朝下吹的，所以在兼顾CPU散热的同时也可以惠顾到主板和内存条散热。但是散热效果稍差，而且会扰乱机箱风道，所以适合发热小的平台，同时由于体积小不占空间，所以是小机箱的福音。 3、塔式散热：这种散热器高高耸立如高塔一般，故名塔式散热。这种散热器单向吹风，不会扰乱风道，而且鳍片和风扇可以做的比较大，因此散热性能最好。但是不能兼顾主板和内存散热，因此需要机箱上的风扇辅助才行。 关于品牌猫头鹰：来自奥地利的品牌，猫头鹰主要以静音风扇久负盛名。猫头鹰的散热器最主要的特点是静音，而且设计绝对没有光污染，坚持使用回流焊工艺，但是价格昂贵。如果只是追求静音，可以买稍微便宜的型号，但如果还想要一个不错的散热效果，那就只能放血了。 大镰刀：日本品牌，镰刀的散热器做工优秀，设计很人性化，扭曲式铜管设计可以避开内存条，所以不挡内存条。 利民：中国台湾品牌，利民的散热器主要还是面对高端的超频用户， 九州风神：国内品牌，九州风神最出名的就是玄冰400和大塔霜了。但是99元的玄冰400不推荐，因为特别难安装。229元的6热管的大塔霜性价比非常高，但是可能会出现挡一根内存的情况。 酷冷至尊：台湾品牌，129元的T400，4热管，安装方便，比玄冰400要好，适合绝大多数人的装机需求。 ID-COOLING：深圳品牌，产品设计很棒，而且性价比高。主力产品是下压式散热器，ITX机箱用户可以选择199元的IS-VC45，采用均热板设计，厚度仅为45mm；159元的is-60，采用6热管设计，也是一款性价比很高的产品。 超频三：深圳品牌，超频三的散热器性价比很高，最出名的就是红海mini了，不到40元的售价，2热管设计，不玩游戏的话足够了。东海X5和东海X6也都是很有性价比的选择。 总结： 虽然热管数量很重要，但是吸热底座做工必须要足够好才行，如果做工不平整，再多的热管都没用，因此散热器拼的更多是做工。 普通的i3、i5后面不带K的CPU和锐龙不带X的CPU，如i3 8100、i5 8500、锐龙1500 1600等选择4热管的散热器就足够了，比如99元的大镰刀STB120或双风扇的STB120 plus都能轻松应对。 i3 i5 i7后面带K的CPU和锐龙带X的CPU，如i3-8350k、i5 8600k、i7 8700K、锐龙1600X等选择6热管就可以了，如大镰刀的千石船、九州风神的大塔霜、利民的TS140P等。 选择散热器的时候一定要注意:①机箱限高和散热器的大小；②挡不挡内存条；③支不支持你的主板平台（大部分散热器都支持英特尔和AMD多平台）。 硅脂也很重要，尽量选择导热系数在5以上的硅脂。这东西很便宜，确是散热很重要的一环，均匀的涂上薄薄的一层就可以了。 不要迷信水冷。风冷才是最安全，最具性价比的选择。 显示器不要以为显示器不重要，显示器总结影响用户体验呀， 主要参数：色域(能显示的色彩范围)、色深(bit)(色彩的精细程度)、色差(色彩还原的准确性)、对比度(对比度越高，越清晰)、分辨率(表示图像的清晰程度)、刷新率Hz(表示显示器1秒能刷新多少帧)、灰阶响应时间(画面延迟) 显示器接口DVI：只支持视频 DVI接口有两个标准，25针和29针，如下图所示。直观来说，这两种接口没有区别。DVI接口传输的是数字信号，可以传输大分辨率的视频信号。DVI连接计算机显卡和显示器时不用发生转换，所以信号没有损失。 VGA：只支持视频 针数为15的视频接口，主要用于老式的电脑输出。VGA输出和传递的是模拟信号。大家都知道计算机显卡产生的是数字信号，显示器使用的也是数字信号。所以使用VGA的视频接口相当于是经历了一个数模转换和一次模数转换。信号损失，显示较为模糊 HDMI接口 支持音视频 HDMI既能传输高清图形画面信号，也能够传输音频信号，一般来说家里会接电视，而且抗干扰强。如数码相机的体积小，需要小的接口，可以使用micro HDMI。 DP接口 支持音视频 DP即DisplayPort，是一种高清数字显示接口标准，可以连接电脑和显示器，也可以连接连接电脑和家庭影院。DP接口可以理解是HDMI的加强版，在音频和视频传输方面更加强悍。目前情况下，DP与HDMI在性能上没有多大区别。如果你使用3840*2160分辨率（4K），HDMI由于带宽不足，最大只能传送30帧，DP就没有问题。 VGA和DVI互转：模拟信号和数字信号的转换，视频信号损失，造成失真。最好不要这样转换。 DVI和HDMI互转：都是数字信号，转换不会发生是真。可以转换。但是从HDMI转换成DVI时会自动舍去音频信号。 液晶面板TN面板TN面板的优点是：液晶分子偏转速度非常快，所以灰阶响应时间很短。缺点是：色域窄，色彩差，画面色彩苍白，可视角度很小，有条件的可以用手机屏幕对比一下老式的便宜的笔记本电脑屏幕。这种屏幕本来快被市场淘汰了，但是随着电竞的火热，TN面板借着刷新率高，灰阶响应时间短的优点又重新回到市场，散发第二春。 IPS面板IPS面板的优点：色彩显示效果好，可视角度大，色彩准。缺点是：容易漏光，黑色不够纯正。这类显示器由于色彩好，可视角度大，所以也是现在应用最广的显示器面板。 VA面板VA面板有两种：MVA面板和PVA面板，PVA是三星改良的MVA面板。这类面板算是TN面板和IPS的折中方案，优点是色彩准确，对比度高，可视角度较大，漏光少，黑色纯正。缺点是响应时间比IPS还要长。 PLS面板PLS面板是三星独家研制的面板，类似IPS面板。 带鱼屏带鱼屏指屏幕比列为21：9或以上的显示器，特点是非常的长，跟带鱼一样，所以被调侃为“带鱼屏”。这种屏幕由于较长，所以一屏能显示更多的内容。 优点： 1.多开网页或者软件、游戏时，同屏能显示更多的内容，因此很适合用来工作。 2.如果能找到21：9的电影片源，看电影会非常爽。（这种片源很少） 3.支持市面主流网络和单机游戏。LOL和绝地求生、cs go等都能有效扩宽左右视野。 缺点： 1.由于直播、电视剧、综艺节目等片源大多是传统的16：9的，所以看这些内容，屏幕两边会有很宽的黑边。 2.由于分辨率高，所以玩游戏时对显卡要求更高。 3.虽然视野变宽了，但是左右看时需要左右扭头，累脖子，适合单机游戏娱乐，不适合电竞。 所以，对于有多开需求的用户来说，带鱼屏或许是个能提高效率的选择。 总结： 144hz/1ms的电竞显示器对CF、CS GO、绝地求生、守望先锋等PFS射击游戏来说，效果区别非常大，是那种用了之后眼睛就再也受不了60hz显示器的那种，当然前提是你的显卡得支持这么高的帧数。 一两千块钱的144hz/1ms电竞显示器都是TN面板的屏幕，色彩会很差，四五千的会好一些，但色彩依然比不过2千块的IPS。 IPS屏幕色彩很好，可视角度也很大，但漏光是IPS的通病，你买到的显示器漏光严重与否，很大程度看运气。而且轻微漏光日常使用看不出区别，所以不用太纠结。 普通玩家选择IPS或者三星VA面板的显示器就够了，不是PFS射击类游戏玩家不用盲目追求144hz/1ms，效果不明显。 带鱼屏细长，能同时显示多个窗口，对于多开多任务需求的用户来说帮助很大。游戏时虽然能提供更宽的视野，但是需要左右扭头，累脖子，适合单机游戏娱乐，不适合电竞。 机箱散热器的选择也应该挑有品牌保障的产品，切勿贪图便宜，品牌产品不仅有售后保障，而且在设计时为了品牌发展也会下较大的成本，而非品牌产品则更加注重于散热器的外观，实际的散热性能会因为压缩成本而大打折扣。 搭配选择家用：对配置要求不高，看电影、上上网之类的，选择入门级CPU和显卡即可 打游戏：看游戏此配置情况选择显卡，游戏对显卡要求特别高，同时对CPU也有一定的要求。 办公：办公时常需要多线程切换，因此选择一款多线程处理能力好的CPU， 特殊领域：比如工程绘图或者图形渲染，深度学习等等，建议CPU和显卡都买比较好的 参考来自中关村：http://www.zol.com.cn/ 推荐两个个自助装机的网站http://www.pc028.com/diy.php和http://mydiy.pconline.com.cn/，用户可以根据自己需要选择配置，而且会标出价格，配完之后可以在线咨询客服，更方面用户进行选择。 https://www.cnblogs.com/fjfsu/p/10945866.html 如果因为资金原因，那么哪些电脑配件可以选择二手的，哪些不能呢？可以买二手的电脑硬件部分 处理器(CPU)：处理器做工非常精细，一般都是在机箱内部，多层维护，轻易是不会损坏的，除非是人为把针脚搞坏或者是其它损坏，如果CPU正常点亮的话，买二手的话，是可以的。 内存条：内存条也是如此，做工都是非常精细的，也是在机箱内部，不是人为损坏的话，除非你用力掰扯损坏或者是其它损坏。一般情况下正常用，买二手的都是没有问题的。 机箱：机箱对电脑的整体性能不大，只要能保证完整，可以用，那么机箱可以考虑买二手的。 显示器：显示器新的和旧的差别不太大，显示器保证正常，买二手的对于使用者来说完全没有问题。 不可以买二手的电脑硬件部分 显卡(GPU)：显卡的性能和使用的程度是密切相关的，尤其是别人挖矿的显卡，长时间负载，元器件极易容易老化，影响较大，所以显卡最好买新的。 主板：主板上的电容 ，接口，线路较多，很容易损坏，旧的很容易老化有问题，建议买新的。 硬盘：无论是机械硬盘还是固态硬盘，它们都有一定的使用寿命与做擦写次数的问题，建议大家硬盘要买新的。 电源：电源是维持电脑稳定工作的必备之一，二手电源会有一定的老化损耗，电压容易不稳定，建议买新的而且要买额定功率大的电源，用来保证电脑正常工作。 散热器：二手的很多都是没有经过保养的，二手散热器经过长时间的使用会有磨损，使用时有明显的噪音，散热对电脑散热方面也是一个不可忽视的部分，所以建议大家散热，也要买新的。散热器的选择也应该挑有品牌保障的产品，切勿贪图便宜，品牌产品不仅有售后保障，而且在设计时为了品牌发展也会下较大的成本，而非品牌产品则更加注重于散热器的外观，实际的散热性能会因为压缩成本而大打折扣。 参考硬件知识哔哩哔哩 古宇胡：https://www.bilibili.com/video/av65451124/?spm_id_from=trigger_reload 哔哩哔哩 显卡吧DIY电脑团：https://www.bilibili.com/video/av68260293 B站UP主“斜耳朵”的专栏（强烈建议大家可以关注他，很多内容转载他的文章，对本文帮助很大） J.Feng 博客园博客——电脑组装知识 组装电脑Matrix海 子的博客园——如何组装配置属于自己的台式机 CSDN博客——组装电脑的超详细步骤超级多图 CSDN博客——组装深度学习电脑 量子位的公众号文章——深度学习装机指南 原作者：凌逆战 转载地址：https://www.cnblogs.com/LXP-Never/p/11607551.html]]></content>
      <categories>
        <category>知识百科</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 054 Spiral Matrix]]></title>
    <url>%2Fposts%2F57431%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: 1234567Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5] Example 2: 1234567Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; &#125;&#125; 题意给定m x n的矩阵，按照螺旋的顺序返回所有元素。 Solution 1cc表示螺旋总的环数，i表示当前的环数，p为当前环的宽度，q为当前环的高度。 对每个环按顺序遍历四条边，当p或q为1时，表示最后一环只有一行或者一列，可以跳出循环。 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(matrix.length==0||matrix[0].length==0) return res; int m = matrix.length, n = matrix[0].length; int c = Math.min((m+1)/2,(n+1)/2); int p = m, q = n; for(int i=0;i&lt;c;i++,p-=2,q-=2)&#123; for(int col=i;col&lt;i+q;col++)&#123; res.add(matrix[i][col]); &#125; for(int row=i+1;row&lt;i+p;row++)&#123; res.add(matrix[row][i+q-1]); &#125; if(p==1||q==1) break; for(int col=i+q-2;col&gt;=i;col--)&#123; res.add(matrix[i+p-1][col]); &#125; for(int row=i+p-2;row&gt;i;row--)&#123; res.add(matrix[row][i]); &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2注意四条边对变化，上边是up初始化0，下边down初始化m-1，左边left初始化0，右边right初始化n-1。 进行while循环，先遍历上边，结束后将上边加1，若上边大于下边说明遍历结束。其他边同理。 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(matrix.length==0||matrix[0].length==0) return res; int m = matrix.length, n = matrix[0].length; int up = 0, down = m-1, left = 0, right = n-1; while(true)&#123; for(int i=left;i&lt;=right;i++) res.add(matrix[up][i]); if(++up&gt;down) break; for(int i=up;i&lt;=down;i++) res.add(matrix[i][right]); if(--right&lt;left) break; for(int i=right;i&gt;=left;i--) res.add(matrix[down][i]); if(--down&lt;up) break; for(int i=down;i&gt;=up;i--) res.add(matrix[i][left]); if(++left&gt;right) break; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 053 Maximum Subarray]]></title>
    <url>%2Fposts%2F54807%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow Up: 1If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Difficulty: Easy Code: 12345class Solution &#123; public int maxSubArray(int[] nums) &#123; &#125;&#125; 题意给定一个数字数组，找出一个连续都子数组，其所有数之和最大，并返回这个和。 如果已经找到来复杂度为O(n)的解法，可以试试分治的思路。 Solution 1定义两个变量res、curr，res表示最大子数组的和，curr表示当前子数组的和并初始化为0。 遍历数组，若curr+num比num大，说明当前curr是正数，那么肯定是新子数组肯定是要继续在之前大基础上往后扩展。 一旦curr是负数或者0，那么之前的都可以抛弃因为不能使新子数组之和变大。 所以curr取curr+num和num中大的数，再用curr去更新保存起来的最大和res。 1234567891011class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = Integer.MIN_VALUE; int curr = 0; for(int num:nums)&#123; curr = Math.max(curr+num,num); res = Math.max(res,curr); &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上道解法的另一种写法，通俗易懂。 123456789101112class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = Integer.MIN_VALUE; int curr = 0; for(int num:nums)&#123; curr+=num; if(curr&gt;res) res=curr; if(curr&lt;0) curr=0; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-divide-and-conquer</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 052 N-Queens II]]></title>
    <url>%2Fposts%2F23032%2F</url>
    <content type="text"><![CDATA[DescriptionThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: 1234567891011121314Input: 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] Difficulty: Hard Code: 12345class Solution &#123; public int totalNQueens(int n) &#123; &#125;&#125; 题意N皇后问题，将n个皇后放在nxn的棋盘上，保证任意两个皇后不能相互攻击。 给定正整数n，求不重复的N皇后问题答案的个数。 Solution 1这道题和上一题一样，只需要返回结果数量更加简单，可以用上一题的解法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int totalNQueens(int n) &#123; char[][] board = new char[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; board[i][j]='.'; &#125; &#125; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); helper(res,board,0); return res.size(); &#125; public void helper(List&lt;List&lt;String&gt;&gt; res,char[][] board,int row)&#123; if(row==board.length)&#123; res.add(convert(board)); return; &#125; for(int col=0;col&lt;board.length;col++)&#123; if(valid(board, row, col))&#123; board[row][col]='Q'; helper(res,board,row+1); board[row][col]='.'; &#125; &#125; &#125; public boolean valid(char[][] board, int row, int col)&#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board.length;j++)&#123; if(board[i][j]=='Q')&#123; if(i==row||j==col||i-row==j-col||i-row==col-j)&#123; return false; &#125; &#125; &#125; &#125; return true; &#125; public List&lt;String&gt; convert(char[][] board)&#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;board.length;i++)&#123; String row = new String(board[i]); res.add(row); &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2我们并不需要知道每一行皇后的具体位置，而只需要知道会不会产生冲突即可。 对于每行要新加的位置，需要看跟之前的列，对角线，及逆对角线之间是否有冲突。 同一条对角线上的点，其横坐标减纵坐标都相等（要保证数组边界）。同一条逆对角线，其横坐标加纵坐标都相等。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int res = 0; boolean[] cols; boolean[] posDiag; boolean[] negDiag; public int totalNQueens(int n) &#123; cols = new boolean[n]; posDiag = new boolean[2*n-1]; negDiag = new boolean[2*n-1]; dfs(0,n); return res; &#125; private void dfs(int row, int n)&#123; if(row==n)&#123; res++; return; &#125; for(int col=0;col&lt;n;col++)&#123; if(valid(row,col,n))&#123; update(row,col,n,true); dfs(row+1,n); update(row,col,n,false); &#125; &#125; &#125; private void update(int row, int col, int n, boolean used)&#123; cols[col]=used; posDiag[row+col]=used; negDiag[row-col+n-1]=used; &#125; private boolean valid(int row, int col, int n)&#123; return !cols[col] &amp;&amp; !posDiag[row+col] &amp;&amp; !negDiag[row-col+n-1]; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 051 N-Queens]]></title>
    <url>%2Fposts%2F55521%2F</url>
    <content type="text"><![CDATA[DescriptionThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. Example: 12345678910111213Input: 4Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. Difficulty: Hard Code: 12345class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; &#125;&#125; 题意N皇后问题，将n个皇后放在nxn的棋盘上，保证任意两个皇后不能相互攻击。 国际象棋中，皇后不仅能横竖走，还能走两个斜线。诞生八皇后问题，在一个8x8的棋盘上才能放8个皇后，保证不能相互攻击，即不能处于同一横线、竖线、斜线上。 给定正整数n，求不重复的N皇后问题答案。’Q’,’.’分别表示棋盘上的皇后和空格。 Solution 1使用递归列出所有符合条件的棋盘，从第0列开始，每列最多只能放一个皇后。 在第colIndex列，从每一行选择一个点进行检查，看如果在这一行及colIndex列的位置上放入皇后，棋盘是否还是有效。 若有效，则将这一点先置成’Q’，然后往下一列进行递归，递归后再将这一点还原便于其他行判断。直到检查超出棋盘最后一列，则说明已经全部放置完毕，将棋盘格式化后加入结果集。 对棋盘是否有效对判断方法是，因为用列递归，所以只用判断棋盘已有对皇后是否和新对皇后处于同一行或同一对角线上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = new char[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; board[i][j]='.'; &#125; &#125; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(board,0,res); return res; &#125; private void dfs(char[][] board, int colIndex, List&lt;List&lt;String&gt;&gt; res)&#123; if(colIndex==board.length)&#123; res.add(construct(board)); return; &#125; for(int i=0;i&lt;board.length;i++)&#123; if(validate(board,i,colIndex))&#123; board[i][colIndex]='Q'; dfs(board,colIndex+1,res); board[i][colIndex]='.'; &#125; &#125; &#125; private boolean validate(char[][] board,int row,int col)&#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(board[i][j]=='Q'&amp;&amp;(i==row||row-i==col-j||i-row==col-j))&#123; return false; &#125; &#125; &#125; return true; &#125; private List&lt;String&gt; construct(char[][] board)&#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;board.length;i++)&#123; res.add(new String(board[i])); &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 212 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 050 Pow(x, n)]]></title>
    <url>%2Fposts%2F46336%2F</url>
    <content type="text"><![CDATA[DescriptionImplement pow(x, n), which calculates x raised to the power n (xn). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] Difficulty: Medium Code: 12345class Solution &#123; public double myPow(double x, int n) &#123; &#125;&#125; 题意求x的n次方，x范围是(-100.0, 100.0)，n是32位有符号整数其范围是[−231, 231 − 1] Solution 1采用递归来折半计算，每次把n除2来计算myPow(x,n/2)，最终第二个参数指数会变成0。 若n为0，则返回1 若n为偶数，那么直接返回折半的结果的平方 若n为正的奇数，那么在折半结果平方的基础上再乘以x 若n为负的负数，那么在折半结果平方的基础上再除以x 123456789class Solution &#123; public double myPow(double x, int n) &#123; if(n==0) return 1; double half=myPow(x,n/2); if(n%2==0) return half*half; if(n&gt;0) return half*half*x; return half*half/x; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2使用迭代去完成，在n折半时将x进行平方。i初始化为n，当i时2当倍数时，将x平方；否则res先乘以x，x再平方，然后i折半。 最后若n为整数，则直接返回结果res，若n为负数，则用返回1/res。 12345678910class Solution &#123; public double myPow(double x, int n) &#123; double res=1.0; for(int i=n;i!=0;i/=2)&#123; if(i%2!=0) res*=x; x*=x; &#125; return n&gt;0?res:1/res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3也可以将n先转成正数再折半，但是要注意n为Integer.MIN_VALUE的情况。 1234567891011121314class Solution &#123; public double myPow(double x, int n) &#123; if(n==0) return 1; if(n==Integer.MIN_VALUE)&#123; x=x*x; n=n/2; &#125; if(n&lt;0)&#123; n=-n; x=1/x; &#125; return (n%2==0)?myPow(x*x,n/2):x*myPow(x*x,n/2); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 049 Group Anagrams]]></title>
    <url>%2Fposts%2F4255%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of strings, group anagrams together. Example: 1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase. The order of your output does not matter. Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; &#125;&#125; 题意给定一组字符串，按字谜（颠倒字母而成的字）分组。所有输入为小写，结果顺序不要求。 Solution 1对每个字符串统计其每个字母出现对次数，用int[26]表示，下标对应字母，值对应出现对个数，并将统计信息转化成字符串。 保存一个HashMap，key是统计信息字符串，value是一组的字符串，用上述结果去更新Map，最终返回Map中所有Value。 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String,List&lt;String&gt;&gt; res = new HashMap&lt;String,List&lt;String&gt;&gt;(); for(String str:strs)&#123; int[] count = new int[26]; for(char c:str.toCharArray())&#123; count[c-'a']+=1; &#125; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;count.length;i++)&#123; sb.append('a'+i).append(count[i]); &#125; if(res.containsKey(sb.toString()))&#123; res.get(sb.toString()).add(str); &#125;else&#123; List&lt;String&gt; group = new ArrayList&lt;String&gt;(); group.add(str); res.put(sb.toString(),group); &#125; &#125; return new ArrayList(res.values()); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2对每个字符串对应对char[]进行排序，然后再将char[]转成String。 建立一个Map，其key是上述新生成对String，value是一组字谜对字符串数组，最后返回Map中所有value。 12345678910111213class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String,List&lt;String&gt;&gt; res = new HashMap&lt;String,List&lt;String&gt;&gt;(); for(String str:strs)&#123; char[] chars = str.toCharArray(); Arrays.sort(chars); String key = new String(chars); if(!res.containsKey(key)) res.put(key,new ArrayList&lt;String&gt;()); res.get(key).add(str); &#125; return new ArrayList(res.values()); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 048 Rotate Image]]></title>
    <url>%2Fposts%2F41135%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: 12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2: 123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Difficulty: Medium Code: 12345class Solution &#123; public void rotate(int[][] matrix) &#123; &#125;&#125; 题意给定一个n x n的二维矩阵表示一张图片，将图片顺时针旋转90度。要求直接修改二维矩阵，不允许使用额外的二维矩阵去做旋转。 Solution 1可以一层层从最外层到最内层进行旋转，递归调用直到到达最内层。 例如在最外层level为0，则要调整的起始位置为matrix[level][level]到matrix[level][len-level-1]。 从这几个点出发，旋转一周即调整4条边上的值即可。针对当前点matrix[row][col]，其应该调整到matrix[col][len-row-1]。 1234567891011121314151617181920212223class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix.length; helper(matrix,n,0); &#125; public void helper(int[][] matrix, int len, int level)&#123; if(level&gt;=len/2) return; for(int i=level;i&lt;len-level-1;i++)&#123; int curr=matrix[level][i]; int nextRow=i, nextCol=len-level-1; for(int j=0;j&lt;4;j++)&#123; int next = matrix[nextRow][nextCol]; matrix[nextRow][nextCol]=curr; curr=next; int tmp=nextRow; nextRow=nextCol; nextCol=len-tmp-1; &#125; &#125; helper(matrix,len,level+1); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2不用递归，直接在一个方法中完成，i为行数，j为列数。 123451 2 3 7 2 1 7 4 14 5 6 --&gt; 4 5 6 --&gt; 8 5 2 7 8 9 9 8 3 9 6 3 1234567891011121314class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix.length; for(int i=0;i&lt;n/2;i++)&#123; for(int j=i;j&lt;n-i-1;j++)&#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][i]; matrix[n-j-1][i]=matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1]=matrix[j][n-i-1]; matrix[j][n-i-1]=tmp; &#125; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3先将矩阵以对角线为轴翻转，在以x轴中线上下翻转即可。 123451 2 3 9 6 3 7 4 14 5 6 --&gt; 8 5 2 --&gt; 8 5 27 8 9 7 4 1 9 6 3 12345678910111213141516171819class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix.length; for(int i=0;i&lt;n-1;i++)&#123; for(int j=0;j&lt;n-i;j++)&#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][n-i-1]; matrix[n-j-1][n-i-1]=tmp; &#125; &#125; for(int i=0;i&lt;n/2;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int tmp = matrix[i][j]; matrix[i][j]=matrix[n-i-1][j]; matrix[n-i-1][j]=tmp; &#125; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 4先将矩阵转置，再对每一行进行翻转。 123451 2 3 1 4 7 7 4 14 5 6 --&gt; 2 5 8 --&gt; 8 5 2 7 8 9 3 6 9 9 6 3 12345678910111213141516171819class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix.length; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[j][i]; matrix[j][i]=tmp; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; int tmp = matrix[i][j]; matrix[i][j]=matrix[i][n-j-1]; matrix[i][n-j-1]=tmp; &#125; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 047 Permutations II]]></title>
    <url>%2Fposts%2F30253%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a collection of numbers that might contain duplicates, return all possible unique permutations. Example: 1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; &#125;&#125; 题意给定一组可能包含重复数字的集合，返回所以不重复的全排列。 Solution 1笨办法，用Set对结果进行去重。把nums中的数字一个一个添加进结果集，注意当添加一个数字时有多个地方可以插入。 如已有[1,2]，那么3可以放在[3,1,2],[1,3,2],[1,2,3]。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; start = new ArrayList&lt;Integer&gt;(); start.add(nums[0]); res.add(start); for(int i=1;i&lt;nums.length;i++)&#123; Set&lt;List&lt;Integer&gt;&gt; tmp = new HashSet&lt;List&lt;Integer&gt;&gt;(); for(int j=0;j&lt;=i;j++)&#123; for(List&lt;Integer&gt; curr:res)&#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(curr); copy.add(j,nums[i]); tmp.add(copy); &#125; &#125; res=tmp; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2递归，用boolean[]保存某个位置上对数字是否被使用过。 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); helper(res,nums,new ArrayList&lt;Integer&gt;(),new boolean[nums.length]); return res; &#125; public void helper(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, List&lt;Integer&gt; curr, boolean[] used)&#123; if(curr.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(curr)); &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]||(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!used[i-1])) continue; curr.add(nums[i]); used[i]=true; helper(res,nums,curr,used); curr.remove(curr.size()-1); used[i]=false; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 046 Permutations]]></title>
    <url>%2Fposts%2F6792%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a collection of distinct integers, return all possible permutations. Example: 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; &#125;&#125; 题意给定一系列非重复数字，返回全排列。 Solution 1使用递归，代码如下。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); helper(res,new ArrayList&lt;Integer&gt;(),nums); return res; &#125; public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, int[] nums)&#123; if(curr.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(curr)); &#125; for(int i=0;i&lt;nums.length;i++)&#123; int num = nums[i]; if(curr.contains(num)) continue; curr.add(num); helper(res,curr,nums); curr.remove(curr.size()-1); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2笨办法，把nums中的数字一个一个添加进结果集，注意当添加一个数字时有多个地方可以插入。 如已有[1,2]，那么3可以放在[3,1,2],[1,3,2],[1,2,3]。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; start = new ArrayList&lt;Integer&gt;(); start.add(nums[0]); res.add(start); for(int i=1;i&lt;nums.length;i++)&#123; List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int j=0;j&lt;=i;j++)&#123; for(List&lt;Integer&gt; curr:res)&#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(curr); copy.add(j,nums[i]); tmp.add(copy); &#125; &#125; res=tmp; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 045 Jump Game II]]></title>
    <url>%2Fposts%2F28112%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: 1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. Difficulty: Hard Code: 12345class Solution &#123; public int jump(int[] nums) &#123; &#125;&#125; 题意给定一个正数数组，初始化时指向数组的第一个元素，每个元素的值表示在这个位置上能向前跳的最大长度。 目标是跳动到最后一个元素，并且用到步数最少，并返回最少步数。假定一定能够到达最后一个元素。 Solution 1使用动态规划，令len表示nums第长度，有dp[len]，dp[i]表示从数组第i位跳到数组最后一位所需第最少步数。dp[len-1]=0，因为数组最后一位不需要跳。 从数组第倒数第二位开始往前遍历，取出当前位置i上的数字steps，初始化当前位置i用的最少步数min为int最大值。在位置i上最多有steps中跳法，但同时要保证不会跳出数组边界。 假定从位置i跳j步到位置i+j上，若dp[i+j]不能到达数组末尾即dp[i+j]为int最大值，则j加1。否则此时所用步数为1+dp[i+j]，更新min到值。 所有可能到步数遍历完后，确定位置i对应所需到步数dp[i]。最终结果返回dp[0]。 123456789101112131415161718class Solution &#123; public int jump(int[] nums) &#123; int len = nums.length; int[] dp = new int[len]; dp[len-1]=0; for(int i=len-2;i&gt;=0;i--)&#123; int steps=nums[i]; int min=Integer.MAX_VALUE; for(int j=1;j&lt;=steps&amp;&amp;i+j&lt;=len-1;j++)&#123; if(dp[i+j]==Integer.MAX_VALUE) continue; int curr = 1 + dp[i+j]; min = Math.min(min,curr); &#125; dp[i]=min; &#125; return dp[0]; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2贪婪算法，jumps代表跳到步数，curEnd表示当前能跳到点的范围是[curBegin, curEnd]，curFarthest表示在[curBegin, curEnd]下一次跳所能到达的最远的点。 遍历数组，i为数组当前所在点，则该点能最远到达的点为i+nums[i]，并据此更新curFarthest。 当i到达curEnd，表示[curBegin, curEnd]所能到达的点都已检查完毕，下次跳最远能跳到curFarthest。 那么将跳一次jumps++，同时此时能跳的最远位置curEnd更新为curFarthest，继续循环。 12345678910111213class Solution &#123; public int jump(int[] nums) &#123; int jumps=0, curEnd=0, curFarthest=0; for(int i=0;i&lt;nums.length-1;i++)&#123; curFarthest=Math.max(curFarthest,i+nums[i]); if(i==curEnd)&#123; jumps++; curEnd=curFarthest; &#125; &#125; return jumps; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 044 Wildcard Matching]]></title>
    <url>%2Fposts%2F9565%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’. 12&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;*&quot;Output: trueExplanation: &apos;*&apos; matches any sequence. Example 3: 12345Input:s = &quot;cb&quot;p = &quot;?a&quot;Output: falseExplanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;. Example 4: 12345Input:s = &quot;adceb&quot;p = &quot;*a*b&quot;Output: trueExplanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;. Example 5: 1234Input:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;Output: false Difficulty: Hard Code: 12345class Solution &#123; public boolean isMatch(String s, String p) &#123; &#125;&#125; 题意给定一个字符串s和模式p，实现通配符匹配，支持？和。？表示任意一个字符，表示任何字符串。 匹配是完全匹配，s可能为空或者只包含a-z，p可能为空或者包含a-z和？或*。 Solution 1进行下列判断： p和s相等或者p为”*”，则直接返回true p是否为空，若p为空，则直接返回s是否为空 s是否为空，若s为空，则p必须必须全部是* 若p[0]==’?’，则返回递归调用isMatch(s[1:],p[1:]) 若p[0]==’*’，则要么星号没匹配上s中任何字符，通过递归调用isMatch(s,p[1:])；否则递归说明星号匹配上了递归调用isMatch(s[1:],p) 若p[0]不为’?’或’*’，比较p[0]==s[0]&amp;&amp;isMatch(s[1:],p[1:]) 但是这段代码提交时发现超过时间限制。 123456789101112131415161718192021222324class Solution &#123; public boolean isMatch(String s, String p) &#123; if(p.equals(s)||p.equals("*")) return true; if(p.isEmpty()) return s.isEmpty(); if(s.isEmpty())&#123; if(p.charAt(0)=='*')&#123; return isMatch(s,p.substring(1)); &#125;else&#123; return false; &#125; &#125; if(p.charAt(0)=='?') return isMatch(s.substring(1),p.substring(1)); if(p.charAt(0)=='*')&#123; int n=1; while(n&lt;p.length()&amp;&amp;p.charAt(n)=='*')&#123; n++; &#125; p=p.substring(n-1); if(isMatch(s,p.substring(1))) return true; return isMatch(s.substring(1),p); &#125; return p.charAt(0)==s.charAt(0) &amp;&amp; isMatch(s.substring(1),p.substring(1)); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2定义i、j为s和p当前遍历对位置，iStar、jStar为星号出现时在s和p中匹配的最新位置。 进行while循环，条件时i小于s的长度。进行下列判断： 若s[i]==p[j]或者p[j]==’?’，则i和j分别加1 若p[j]==’*’，则iStar=i，jStart=j，j++ 若当前星号出现即iStar&gt;=0时，p[jStar]可以在s中多向前匹配一位，则i回退到iStart++，j回退到jStar+1 若星号没出现则返回false 最后若s已经匹配完，但p还有剩余字符，则要判断p中剩余字符是否都是* 12345678910111213141516171819202122class Solution &#123; public boolean isMatch(String s, String p) &#123; int i=0, j=0, iStar=-1, jStar=-1; while(i&lt;s.length())&#123; if(j&lt;p.length()&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?'))&#123; i++; j++; &#125;else if(j&lt;p.length()&amp;&amp;p.charAt(j)=='*')&#123; iStar=i; jStar=j; j++; &#125;else if(iStar&gt;=0)&#123; i=++iStar; j=jStar+1; &#125;else&#123; return false; &#125; &#125; while(j&lt;p.length()&amp;&amp;p.charAt(j)=='*') j++; return j==p.length(); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3使用动态规划，定义dp[m+1][n+1]，dp[i][j]表示s中的前i个字符组成的字符串和p中的前j个字符组成的字符串是否匹配。 初始化dp[0][0]为true，因为s和p都为空时应返回true。还有当s为空，p中都是星号时也返回true。 若p中第j个字符为星号，若星号匹配空串即dp[i][j-1]为true，则d[i][j]也为true；有dp[i-1][j]为true时星号也可再多匹配一个，则dp[i][j]也为true。 若p中第j个字符不为星号，则在直到dp[i-1][j-1]的情况下，看s[i-1]和p[j-1]是否匹配。 1234567891011121314151617181920class Solution &#123; public boolean isMatch(String s, String p) &#123; int m=s.length(), n=p.length(); boolean[][] dp = new boolean[m+1][n+1]; dp[0][0] = true; for(int i=1;i&lt;=n;i++)&#123; if(p.charAt(i-1)=='*') dp[0][i]=dp[0][i-1]; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(p.charAt(j-1)=='*')&#123; dp[i][j]=dp[i][j-1]||dp[i-1][j]; &#125;else&#123; dp[i][j]=dp[i-1][j-1]&amp;&amp;(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='?'); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 4同解法1使用递归调用，但同时采用剪枝。递归方法返回但不是boolean而是int，有三种状态。0表示匹配到s到末尾，但是未匹配成功。1表示未匹配到s到末尾就失败了。2表示匹配成功。 若s和p都完成匹配则返回2。若s匹配完成，但p当前字符不是星号则返回0。若s未匹配完而p匹配完，返回1。 若s和p都匹配完成则对下一位字符递归调用。否则若p当前字符为星号，那么先跳过连续的星号，然后分别让星号匹配空串、1个字符、2个字符… 剪枝条件：当返回值为0或者2时，则返回，否则继续遍历。 123456789101112131415161718192021222324class Solution &#123; public boolean isMatch(String s, String p) &#123; return helper(s, p, 0, 0) &gt; 1; &#125; public int helper(String s, String p, int i, int j)&#123; if(i==s.length() &amp;&amp; j==p.length()) return 2; if(i==s.length() &amp;&amp; p.charAt(j)!='*') return 0; if(j==p.length()) return 1; if(i&lt;s.length()&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?'))&#123; return helper(s, p, i+1, j+1); &#125; if(p.charAt(j)=='*')&#123; if(j+1&lt;p.length()&amp;&amp;p.charAt(j+1)=='*')&#123; return helper(s,p,i,j+1); &#125; for(int k=0;k&lt;=s.length()-i;k++)&#123; int res=helper(s,p,i+k,j+1); if(res==0||res==2) return res; &#125; &#125; return 1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-backtracking</tag>
        <tag>leetcode-greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 043 Multiply Strings]]></title>
    <url>%2Fposts%2F15075%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: 12Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot; Example 2: 12Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. Difficulty: Medium Code: 12345class Solution &#123; public String multiply(String num1, String num2) &#123; &#125;&#125; 题意给定两个代表非负num1和num2的字符串，用字符串表示它们的乘积。字符串的长度小于110，只包含0-9。不能将输入转成int进行计算。 Solution 1用一个数组pos保存m+n长度的数字，代表每一位上的数字，最后一个数字表示结果的个位。 从字符串num1和num2的右侧开始，提取对应位置上的数字并计算乘积，确定相乘后所影响的pos位置上的数字。 num1[i] * num2[j]将会影响pos[i+j]和pos[i+j+1]上的数字，对其进行更新。 最后遍历pos返回结果字符串。 12345678910111213141516171819202122class Solution &#123; public String multiply(String num1, String num2) &#123; if(num1.equals("0")||num2.equals("0")) return "0"; int m=num1.length(), n=num2.length(); if(m&gt;n) return multiply(num2,num1); int[] pos=new int[m+n]; for(int i=m-1;i&gt;=0;i--)&#123; for(int j=n-1;j&gt;=0;j--)&#123; int tmp = (num1.charAt(i)-'0')*(num2.charAt(j)-'0'); int p1=i+j, p2=i+j+1, sum=tmp+pos[p2]; pos[p1]+=sum/10; pos[p2]=sum%10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;pos.length;i++)&#123; if(i==0&amp;&amp;pos[i]==0) continue; sb.append(pos[i]); &#125; return sb.length()==0?"0":sb.toString(); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 042 Trapping Rain Water]]></title>
    <url>%2Fposts%2F37397%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 Difficulty: Hard Code: 12345class Solution &#123; public int trap(int[] height) &#123; &#125;&#125; 题意收集雨水，给定n个非负整数代表宽为1不同高度柱子的容器，求它能收集多少雨水。 Solution 1双指针left和right分别指向最左端和最右端，同时维护maxLeft和maxRight表示左侧和右侧遍历时最大高度。 若当前left的高度较小，则固定住right侧，填充左侧的格子。 1234567891011121314151617181920212223class Solution &#123; public int trap(int[] height) &#123; int left=0,right=height.length-1,maxLeft=0,maxRight=0,res=0; while(left&lt;=right)&#123; if(height[left]&lt;=height[right])&#123; if(height[left]&gt;=maxLeft)&#123; maxLeft=height[left]; &#125;else&#123; res+=maxLeft-height[left]; &#125; left++; &#125;else&#123; if(height[right]&gt;maxRight)&#123; maxRight=height[right]; &#125;else&#123; res+=maxRight-height[right]; &#125; right--; &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2从左侧及右侧更新两边的最大高度maxLeft和maxRight，当maxLeft比maxRight小时，意味着左侧可以存水，值为maxLeft-height[left]。 1234567891011121314151617class Solution &#123; public int trap(int[] height) &#123; int left=0,right=height.length-1,maxLeft=0,maxRight=0,res=0; while(left&lt;=right)&#123; maxLeft=Math.max(maxLeft,height[left]); maxRight=Math.max(maxRight,height[right]); if(maxLeft&lt;=maxRight)&#123; res+=maxLeft-height[left]; left++; &#125;else&#123; res+=maxRight-height[right]; right--; &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3每次只处理最左侧left和最右侧right高度较小的一侧，拿出较小的高度去更新当前安全深度level，取其中较大的值。 然后用此level减去当前格子的高度，累加至结果res，同时更新left和right。 1234567891011class Solution &#123; public int trap(int[] height) &#123; int left=0,right=height.length-1,level=0,res=0; while(left&lt;right)&#123; int lower = height[height[left]&lt;height[right]?left++:right--]; level = Math.max(level,lower); res+=level-lower; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 4使用栈，从左到右遍历数组，保存递减的高度到下标。若找到当前格子比栈中最上面的下标对应的高度高，则栈中最顶上的格子就是一个洼地，可以存水。 从栈中弹出这块洼地的下标，用洼地格子的右方和左方的高度较小的一个减去当前格子的高度，累加进结果。相当于这一小块洼地被填平，并不断重复此判断。 123456789101112131415161718class Solution &#123; public int trap(int[] height) &#123; int i=0,res=0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); while(i&lt;height.length)&#123; if(!stack.isEmpty()&amp;&amp;height[i]&gt;height[stack.peek()])&#123; int bar = stack.pop(); if(!stack.isEmpty())&#123; int h = Math.min(height[i],height[stack.peek()]); res+=(i-stack.peek()-1)*(h-height[bar]); &#125; &#125;else&#123; stack.push(i++); &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 041 First Missing Positive]]></title>
    <url>%2Fposts%2F25277%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an unsorted integer array, find the smallest missing positive integer. Example 1: 12Input: [1,2,0]Output: 3 Example 2: 12Input: [3,4,-1,1]Output: 2 Example 3: 12Input: [7,8,9,11,12]Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Difficulty: Hard Code: 12345class Solution &#123; public int firstMissingPositive(int[] nums) &#123; &#125;&#125; 题意给定一个未排序的整数数组，找出首个缺失的正数。时间复杂度要求O(n)，空间复杂度为O(1)。 Solution 1不能建立新的数组，只能在原有的数组上修改。当读到第i个元素当值是n时，应该把n放在nums[n-1]上，即应该把nums[i]放到nums[nums[i]-1]上。 遍历整个数组，若不满足nums[i]==nums[nums[i]-1]，则将两者调换位置。例如当发现5，则将其与nums[4]上的数字交换。 最后再次遍历数组，若nums[i]!=i+1，则返回i+1，否则说明现有数组都不缺，返回最后一个数都下一位。 123456789101112131415161718class Solution &#123; public int firstMissingPositive(int[] nums) &#123; int len = nums.length; for(int i=0;i&lt;len;i++)&#123; while(nums[i]&gt;0&amp;&amp;nums[i]&lt;=len&amp;&amp;nums[nums[i]-1]!=nums[i])&#123; int tmp=nums[nums[i]-1]; nums[nums[i]-1]=nums[i]; nums[i]=tmp; &#125; &#125; for(int i=0;i&lt;len;i++)&#123; if(nums[i]!=i+1)&#123; return i+1; &#125; &#125; return len+1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 040 Combination Sum II]]></title>
    <url>%2Fposts%2F55336%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: 12345678Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Example 2: 123456Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; &#125;&#125; 题意给定一系列候选数字candidates和目标值target，找出所有的不重复组合使得候选数字组合的和等于目标值。 一个组合中每个候选数字元素只能使用一次，所有数字均为正整数，不能包含重复的组合。 Solution 1与第39题类似，多了一个要求是候选元素只能使用一次，但候选元素之间可以重复。 同样使用递归，在递归中，遍历候选元素添加时，判断在选择当前位上数时，若从候选数字中后一个元素和前一个元素相同则跳过，因为之前已经在当前位上添加过该元素，完成去重。 并且已经递归调用时，候选元素但起始位置在当前元素上加1，同一个元素不会使用多次。 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); resolve(res,new ArrayList&lt;Integer&gt;(),candidates,target,0); return res; &#125; public void resolve(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, int[] candidates, int remain, int start)&#123; if(remain==0)&#123; res.add(new ArrayList&lt;Integer&gt;(curr)); return; &#125;else if(remain&lt;0)&#123; return; &#125; for(int i=start;i&lt;candidates.length;i++)&#123; if(candidates[i]&gt;remain) return; if(i&gt;start&amp;&amp;candidates[i]==candidates[i-1]) continue; curr.add(candidates[i]); resolve(res,curr,candidates,remain-candidates[i],i+1); curr.remove(curr.size()-1); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 039 Combination Sum]]></title>
    <url>%2Fposts%2F19748%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: 123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2: 1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; &#125;&#125; 题意给定几个不重复的候选正整数和一个目标数，求所有不重复组合使得候选数相加等于目标值，候选数可以多次选择。 Solution 1使用递归，用Set去重，当前已有的数字放入curr的list中，将curr中所有数求和sum，若sum和target一样则加入结果集并返回。 若sum比target大，则不符合条件直接返回。否则遍历候选集，尝试将每个候选数加入当前curr，再去递归判断。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); checkAll(candidates,target,res,curr); return new ArrayList&lt;List&lt;Integer&gt;&gt;(res); &#125; public void checkAll(int[] candidates, int target, Set&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr)&#123; int sum = 0; for(int num:curr)&#123; sum+=num; &#125; if(sum==target)&#123; Collections.sort(curr); res.add(curr); return; &#125;else if(sum&gt;target)&#123; return; &#125; for(int num:candidates)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); tmp.addAll(curr); tmp.add(num); checkAll(candidates,target,res,tmp); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2解法1的优化，先把候选数组排序，然后增加从候选数组选择数字起始位置start，这样可以避免重复添加。 另外，直接传入target和当前数组的差值，这样不用每次都将当前数组的和算一遍，只保留最新的差值。 最后，为了减少临时数组的创建，递归调用后可以将当前数组删除末尾元素来进行恢复。 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); checkAll(candidates,res,new ArrayList&lt;Integer&gt;(),target,0); return res; &#125; public void checkAll(int[] candidates, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, int remain, int start)&#123; if(remain==0)&#123; res.add(new ArrayList&lt;Integer&gt;(curr)); return; &#125;else if(remain&lt;0)&#123; return; &#125; for(int i=start;i&lt;candidates.length;i++)&#123; curr.add(candidates[i]); checkAll(candidates,res,curr,remain-candidates[i],i); curr.remove(curr.size()-1); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 038 Count and Say]]></title>
    <url>%2Fposts%2F40563%2F</url>
    <content type="text"><![CDATA[DescriptionThe count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as “one 1” or 11. 11 is read off as “two 1s” or 21. 21 is read off as “one 2, then one 1” or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; Difficulty: Easy Code: 12345class Solution &#123; public String countAndSay(int n) &#123; &#125;&#125; 题意对于前一个数，找出其对应字符串中相同数字都个数，并将其个数和数字一起存到新都字符串中作为当前数字的对应结果。 Solution 1递归调用，当n等于1时直接返回”1”，否则利用该方法求得前一个数对应的字符串。再按照题意理解生成新的字符串。 1234567891011121314151617181920class Solution &#123; public String countAndSay(int n) &#123; if(n==1)&#123; return "1"; &#125; String pre = countAndSay(n-1); StringBuilder sb = new StringBuilder(); int count = 1; for(int i=1;i&lt;pre.length();i++)&#123; if(pre.charAt(i)!=pre.charAt(i-1))&#123; sb.append(count).append(pre.charAt(i-1)); count=1; &#125;else&#123; count++; &#125; &#125; sb.append(count).append(pre.charAt(pre.length()-1)); return sb.toString(); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2也可以对字符串”1”进行n-1次更新，更新规则与上述解法相同。 12345678910111213141516171819class Solution &#123; public String countAndSay(int n) &#123; if(n==1) return "1"; String res = "1"; while(--n&gt;0)&#123; String curr = ""; for(int i=0;i&lt;res.length();i++)&#123; int count=1; while(i+1&lt;res.length()&amp;&amp;res.charAt(i)==res.charAt(i+1))&#123; count++; i++; &#125; curr=curr+count+res.charAt(i); &#125; res=curr; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 037 Sudoku Solver]]></title>
    <url>%2Fposts%2F21287%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character ‘.’. A sudoku puzzle… …and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character ‘.’. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. Difficulty: Hard Code: 12345class Solution &#123; public void solveSudoku(char[][] board) &#123; &#125;&#125; 题意将数独中的空白按规则正确填充，假设有且仅有唯一解。 Solution 1对每个空格子都带入1-9，每带入一个数字判定其是否合法，若合法则将其放入棋盘并递归调用。 若其递归调用都仍然合法，说明棋盘已经填充正确，直接返回；若不合法，说明这个数字不适合，将棋盘此位置重新放入.。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board==null||board.length==0)&#123; return; &#125; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(board[i][j]=='.')&#123; for(char curr='1';curr&lt;='9';curr++)&#123; if(isValid(board,i,j,curr))&#123; board[i][j]=curr; if(solve(board))&#123; return true; &#125;else&#123; board[i][j]='.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int row, int column, char curr)&#123; for(int i=0;i&lt;9;i++)&#123; if(board[row][i]!='.'&amp;&amp;board[row][i]==curr) return false; if(board[i][column]!='.'&amp;&amp;board[i][column]==curr) return false; if(board[3*(row/3)+i/3][3*(column/3)+i%3]!='.'&amp;&amp;board[3*(row/3)+i/3][3*(column/3)+i%3]==curr) return false; &#125; return true; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 036 Valid Sudoku]]></title>
    <url>%2Fposts%2F43501%2F</url>
    <content type="text"><![CDATA[DescriptionDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Example 1: 12345678910111213Input:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true Example 2: 123456789101112131415Input:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. Difficulty: Medium Code: 12345class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; &#125;&#125; 题意判断9x9的数独棋盘是否有效，要求满足以下条件： 每一行必须包含1-9，不能重复 每一列必须包含1-9，不能重复 每个3x3的格子必须包含1-9，不能重复 另外请注意 数独棋盘已经填充的部分要求有效但不要求能解出来 只有已经填充的格子才需要验证是否符合上述条件 棋盘只包含1-9和字符. 棋盘大小是9x9 Solution 1准备三个set，分别记录各行、各列、各小方阵是否出现某个数字，下标需要转换。 1234567891011121314151617181920212223class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i=0;i&lt;9;i++)&#123; Set&lt;Character&gt; row = new HashSet&lt;Character&gt;(); Set&lt;Character&gt; column = new HashSet&lt;Character&gt;(); Set&lt;Character&gt; block = new HashSet&lt;Character&gt;(); for(int j=0;j&lt;9;j++)&#123; if(board[i][j]!='.'&amp;&amp;!row.add(board[i][j]))&#123; return false; &#125; if(board[j][i]!='.'&amp;&amp;!column.add(board[j][i]))&#123; return false; &#125; int rowIndex = 3*(i/3); int colIndex = 3*(i%3); if(board[rowIndex+j/3][colIndex+j%3]!='.'&amp;&amp;!block.add(board[rowIndex+j/3][colIndex+j%3]))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2用一个set保存数字分别在行row、列column、块block中的值的字符串形式，若相同的数在同一行、同一列、同一块再次出现，则添加到set中会返回false，依次来判断是否有效。 1234567891011121314151617class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; char num = board[i][j]; if(num=='.') continue; if(!set.add(num+" in row "+i)|| !set.add(num+" in column "+j)|| !set.add(num+" in block "+i/3+"-"+j/3))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 035 Search Insert Position]]></title>
    <url>%2Fposts%2F10372%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 Difficulty: Easy Code: 12345class Solution &#123; public int searchInsert(int[] nums, int target) &#123; &#125;&#125; 题意给定一个有序数组nums和一个目标值target，若数组中nums能找到target则返回下标，否则返回它应该放入的位置。数组中没有重复元素。 Solution 1先把target大于或者小于nums所有数的情况解决掉，剩下就是在nums中进行二分查找。 若能找到则返回下标，若不能，则退出循环时left的位置即为应插入的位置。 1234567891011121314151617181920class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if(nums==null||nums.length==0) return 0; int len=nums.length; if(target&lt;nums[0]) return 0; if(target&gt;nums[len-1]) return len; int left=0,right=len-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(nums[mid]==target)&#123; return mid; &#125;else if(nums[mid]&gt;target)&#123; right=mid-1; &#125;else&#123; left=mid+1; &#125; &#125; return left; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 034 Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2Fposts%2F53326%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: 12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2: 12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] Difficulty: Medium Code: 12345class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; &#125;&#125; 题意给定一个整数数组nums，按升序排列，元素可以重复，找出目标数target出现的起始和结束位置。时间复杂度要求O(log n)，若没找到，返回[-1, -1]。 Solution 1和二分查找一样，当找到mid的值等于target时，从mid分别往左和往右去找和target相等的数。 1234567891011121314151617181920class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums==null||nums.length==0) return new int[]&#123;-1,-1&#125;; int left=0, right=nums.length-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(nums[mid]==target)&#123; int start=mid,end=mid; while(--start&gt;=0&amp;&amp;nums[start]==target)&#123;&#125;; while(++end&lt;=nums.length-1&amp;&amp;nums[end]==target)&#123;&#125;; return new int[]&#123;start+1,end-1&#125;; &#125;else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; right=mid-1; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上述解法1有个问题是在mid处找到target后，起点和终点点查找并不是二分的。下述是改进版。 12345678910111213141516171819202122232425class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums==null||nums.length==0) return new int[]&#123;-1,-1&#125;; int left=0, right=nums.length-1; while(nums[left]&lt;nums[right])&#123; int mid=(left+right)/2; if(nums[mid]==target)&#123; if(nums[left]==target)&#123; right--; &#125;else&#123; left++; &#125; &#125;else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; right=mid-1; &#125; &#125; if(nums[left]==nums[right]&amp;&amp;nums[left]==target)&#123; return new int[]&#123;left,right&#125;; &#125;else&#123; return new int[]&#123;-1,-1&#125;; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 033 Search in Rotated Sorted Array]]></title>
    <url>%2Fposts%2F61834%2F</url>
    <content type="text"><![CDATA[DescriptionSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 Difficulty: Medium Code: 12345class Solution &#123; public int search(int[] nums, int target) &#123; &#125;&#125; 题意有一个数组，其原本按升序排列，但后来在某个轴被旋转。给定一个目标数字，在数组中查找其下标，若不存在则返回-1。 数组中的元素不重复，算法时间复杂度必须是O(log n)。 Solution 1从时间复杂度看，必须要使用二分查找，问题的难点在于数组不是全部有序的。其先是升序，在某个点突然变小，后面接着升序。 对于数组[0,1,2,3,4,5,6,7]共有以下旋转后排列，若中间的数字小于最右边的数字，说明右半段是有序的，否则说明左半段是有序的。 利用有序半段的首尾两个数来判断目标数字应该落在哪半边。 123456789101112130 1 2 4 5 6 77 0 1 2 4 5 66 7 0 1 2 4 55 6 7 0 1 2 44 5 6 7 0 1 22 4 5 6 7 0 11 2 4 5 6 7 0 12345678910111213141516171819202122232425262728class Solution &#123; public int search(int[] nums, int target) &#123; if(nums==null||nums.length==0) return -1; if(target==nums[0]) return 0; if(nums.length==1) return -1; int left=0, right=nums.length-1; while(left&lt;=right)&#123; int mid = (left+right)/2; if(nums[mid]==target)&#123; return mid; &#125; if(nums[mid]&lt;nums[right])&#123; if(nums[mid]&lt;target&amp;&amp;nums[right]&gt;=target)&#123; left=mid+1; &#125;else&#123; right=mid-1; &#125; &#125;else&#123; if(nums[left]&lt;=target&amp;&amp;nums[mid]&gt;target)&#123; right=mid-1; &#125;else&#123; left=mid+1; &#125; &#125; &#125; return -1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上述解法1的优化算法，若mid和target在num[0]的同一侧，则取nums[mid]，否则按需取最大最小值。 1234567891011121314151617class Solution &#123; public int search(int[] nums, int target) &#123; int left=0, right=nums.length-1; while(left&lt;=right)&#123; int mid = (left+right)/2; int value = (nums[mid]&lt;nums[0])==(target&lt;nums[0]) ? nums[mid] : (target&lt;nums[0]?Integer.MIN_VALUE:Integer.MAX_VALUE); if(value==target)&#123; return mid; &#125;else if(value&lt;target)&#123; left=mid+1; &#125;else&#123; right=mid-1; &#125; &#125; return -1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 032 Longest Valid Parentheses]]></title>
    <url>%2Fposts%2F65225%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example 1: 123Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: 123Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; Difficulty: Hard Code: 12345class Solution &#123; public int longestValidParentheses(String s) &#123; &#125;&#125; 题意给定一个只包含(及)的字符串，求最长有效括号的子串的长度。 Solution 1遍历字符串，以当前字符为(，则开始检查以当前字符为起始位置到末尾，最大有效子串到长度。 检查最大有效子串长度到方法为借助栈，碰到左括号则压栈，碰到有括号则检查栈是否为空，若为空则返回，若不为空则弹出，更新匹配到到对数，并且再次判断栈是否为空。 此时栈为空表明，从起始位置到当前位置都是有效，并更新最大有效子串长度。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int longestValidParentheses(String s) &#123; if(s==null||s.length()&lt;=1||s.indexOf("(")==-1||s.indexOf(")")==-1) return 0; int res=0; for(int i=0;i&lt;s.length()-1;i++)&#123; if(s.charAt(i)=='(')&#123; int max = checkLongest(s,i); res = Math.max(res,max); &#125; &#125; return res; &#125; public int checkLongest(String s, int start)&#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); int matched=0, max = 0; for(int i=start;i&lt;s.length();i++)&#123; char curr = s.charAt(i); if(curr=='(')&#123; stack.push('('); continue; &#125; if(stack.isEmpty())&#123; return max; &#125; stack.pop(); matched++; if(stack.isEmpty())&#123; max=2*matched; &#125; &#125; return max; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2在上诉解法1的基础上进行优化，只遍历一次数组。 定义res为最长子串长度，start为有效子串的起始位置。遍历字符串当前位置i，若遇到左括号，则将其下标压入栈中。若遇到右括号，如果栈为空，则说明从start到当前位置有效子串截止，start后移到当前位置后一位；若栈不为空，则弹出栈顶元素，再判断栈是否为空。 此时，若栈为空，则说明从start到当前位置都是有效，比较当前res和i-start+1并更新；若不为空，则说明前面有左括号并没有匹配，比较res和i-栈顶元素到值，即从最后一个没有匹配到左括号到当前位置到有效子串长度。 12345678910111213141516171819202122232425class Solution &#123; public int longestValidParentheses(String s) &#123; if(s==null||s.length()&lt;=1||s.indexOf("(")==-1||s.indexOf(")")==-1) return 0; int res=0, start=0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char curr = s.charAt(i); if(curr=='(')&#123; stack.push(i); continue; &#125; if(stack.isEmpty())&#123; start=i+1; continue; &#125; stack.pop(); if(stack.isEmpty())&#123; res=Math.max(res,i-start+1); &#125;else&#123; res=Math.max(res,i-stack.peek()); &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3使用动态规划，dp[i]表示从字符串开始位置到i下标到有效子串最大长度。若字符串当前位置为左括号，则跳过，因为并不能影响当前最长子串到长度值。 若当前字符串为右括号，则进行以下判断： 若s[i]==’)’且s[i-1]==’(‘，则dp[i]=dp[i-2]+2; 若s[i]==’)’且s[i-1]==’)’，则判断s[i-dp[i-1]-1]==’(‘，则dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2 12345678910111213141516171819class Solution &#123; public int longestValidParentheses(String s) &#123; if(s==null||s.length()&lt;=1||s.indexOf("(")==-1||s.indexOf(")")==-1) return 0; int res=0; int[] dp = new int[s.length()]; for(int i=1;i&lt;s.length();i++)&#123; if(s.charAt(i)=='(')&#123; continue; &#125; if(s.charAt(i-1)=='(')&#123; dp[i] = i&gt;=2?dp[i-2]+2:2; &#125;else if(i-dp[i-1]-1&gt;=0 &amp;&amp; s.charAt(i-dp[i-1]-1)=='(')&#123; dp[i] = dp[i-1] + ((i-dp[i-1]-2)&gt;=0?dp[i-dp[i-1]-2]+2:2); &#125; res = Math.max(res,dp[i]); &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 031 Next Permutation]]></title>
    <url>%2Fposts%2F12241%2F</url>
    <content type="text"><![CDATA[DescriptionImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Difficulty: Medium Code: 12345class Solution &#123; public void nextPermutation(int[] nums) &#123; &#125;&#125; 题意求全排列下一个排列顺序，参考如下。 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Solution 1若给定数组是降序，则说明是全排列到最后一组，下一个排列顺序就是最开始到一组。 例如又一个数组1 2 7 4 3 1，则下一个排列为1 3 1 2 4 7。 从末尾往前看，数字逐渐变大，到来2开始减小，在从后往前找到第一个比2大的数3，将3与2进行交换，再将3后面的数字反转。 1234567891011121314151617181920212223242526272829class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length, i=0, j=0; for(i=len-2;i&gt;=0;i--)&#123; if(nums[i]&lt;nums[i+1])&#123; break; &#125; &#125; if(i!=-1)&#123; for(j=len-1;j&gt;=0;j--)&#123; if(nums[j]&gt;nums[i])&#123; break; &#125; &#125; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; &#125; i=i+1; j=len-1; while(i&lt;j)&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; i++; j--; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 030 Substring with Concatenation of All Words]]></title>
    <url>%2Fposts%2F6607%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: 123456Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too. Example 2: 1234Input: s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]Output: [] Difficulty: Hard Code: 12345class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; &#125;&#125; 题意给定字符串s和一系列单词words，单词的长度都相等。找出所有匹配的子串的起始位置，匹配的字符子串需是由所有这些单词串联一次而成。 Solution 1首先若字符串s的长度m小于所有单词长度之和n，则返回空。同时令单词长度为l。 然后对字符串s从第0位到m-n位进行遍历，若从当前i到i+l，若单词列表中含有，则开始进行判断。 判读是重新copy一份单词列表到wordCopy，对从i开始的每一长度为l的子串，若在wordCopy中，则将其从wordCopy删除，并移动l重新查找，直到wordCopy不包含或者为空。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s==null||words==null||s.length()==0||words.length==0||words[0]==null||words[0].length()==0) return res; int m = s.length(), n = words.length*words[0].length(), l=words[0].length(); if(n&gt;m) return res; List&lt;String&gt; wordList = Arrays.asList(words); for(int i=0;i&lt;=m-n;i++)&#123; if(wordList.contains(s.substring(i,i+l)))&#123; List&lt;String&gt; wordCopy = new ArrayList&lt;String&gt;(); wordCopy.addAll(wordList); int start = i; while(wordCopy.size()&gt;0)&#123; if(wordCopy.contains(s.substring(start,start+l)))&#123; wordCopy.remove(s.substring(start,start+l)); start+=l; &#125;else&#123; break; &#125; &#125; if(wordCopy.size()==0)&#123; res.add(i); &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上述解法1有个缺陷是单词不能重复，为了针对单词有重复到情况，要使用HashMap代替List。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s==null||words==null||s.length()==0||words.length==0||words[0]==null||words[0].length()==0) return res; int m = s.length(), n = words.length, l=words[0].length(); if(n*l&gt;m) return res; Map&lt;String,Integer&gt; wordMap = new HashMap&lt;String,Integer&gt;(); for(String word:words)&#123; if(wordMap.containsKey(word))&#123; wordMap.put(word,wordMap.get(word)+1); &#125;else&#123; wordMap.put(word,1); &#125; &#125; for(int i=0;i&lt;=m-n*l;i++)&#123; int j=0; Map&lt;String,Integer&gt; wordTmpMap = new HashMap&lt;String,Integer&gt;(); for(;j&lt;n;j++)&#123; String word = s.substring(i+j*l,i+j*l+l); if(wordMap.containsKey(word))&#123; if(wordTmpMap.containsKey(word))&#123; if(wordTmpMap.get(word)==wordMap.get(word)) break; wordTmpMap.put(word,wordTmpMap.get(word)+1); &#125;else&#123; wordTmpMap.put(word,1); &#125; &#125;else&#123; break; &#125; &#125; if(j==n&amp;&amp;wordTmpMap.size()==wordMap.size()) res.add(i); &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3上述解法2到优化版，使用了Map.getOrDefault()来优化Map到操作。 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; final Map&lt;String, Integer&gt; counts = new HashMap&lt;&gt;(); for (final String word : words) &#123; counts.put(word, counts.getOrDefault(word, 0) + 1); &#125; final List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;(); final int n = s.length(), num = words.length, len = words[0].length(); for (int i = 0; i &lt; n - num * len + 1; i++) &#123; final Map&lt;String, Integer&gt; seen = new HashMap&lt;&gt;(); int j = 0; while (j &lt; num) &#123; final String word = s.substring(i + j * len, i + (j + 1) * len); if (counts.containsKey(word)) &#123; seen.put(word, seen.getOrDefault(word, 0) + 1); if (seen.get(word) &gt; counts.getOrDefault(word, 0)) &#123; break; &#125; &#125; else &#123; break; &#125; j++; &#125; if (j == num) &#123; indexes.add(i); &#125; &#125; return indexes; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 029 Divide Two Integers]]></title>
    <url>%2Fposts%2F4645%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: 12Input: dividend = 10, divisor = 3Output: 3 Example 2: 12Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. Difficulty: Medium Code: 12345class Solution &#123; public int divide(int dividend, int divisor) &#123; &#125;&#125; 题意实现整数的除法，禁止使用乘法、除法、取余。整数范围为有符号int，除数不会是0，结果溢出后返回231 − 1。 Solution 1思路是把数转成正数long，再按位移动的操作。若被除数m比除数n大，将n往左移一位成t再比较，这样可以快速定位到例如1、2、4、8倍的倍数p。 然后将m减去t，倍数结果res加上p，不断循环，最后根据符号返回结果。 1234567891011121314151617181920class Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend==0) return 0; if(divisor==1) return dividend; if(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-1) return Integer.MAX_VALUE; if(divisor==-1) return -dividend; long m = Math.abs(Long.valueOf(dividend)), n = Math.abs(Long.valueOf(divisor)); int res = 0, sign = (dividend&lt;0)^(divisor&lt;0)?-1:1; while(m&gt;=n)&#123; long t=n,p=1; while(m&gt;=(t&lt;&lt;1))&#123; t&lt;&lt;=1; p&lt;&lt;=1; &#125; res+=p; m-=t; &#125; return sign==1?res:-res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2在解法1的基础上使用递归。 123456789101112131415161718class Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend==0) return 0; if(divisor==1) return dividend; if(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-1) return Integer.MAX_VALUE; if(divisor==-1) return -dividend; long m = Math.abs(Long.valueOf(dividend)), n = Math.abs(Long.valueOf(divisor)); if(m&lt;n) return 0; int res = 0, sign = (dividend&lt;0)^(divisor&lt;0)?-1:1; long t=n,p=1; while(m&gt;=(t&lt;&lt;1))&#123; t&lt;&lt;=1; p&lt;&lt;=1; &#125; res+=p+divide(Long.valueOf(m-t).intValue(),Long.valueOf(n).intValue()); return sign==1?res:-res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 028 Implement strStr()]]></title>
    <url>%2Fposts%2F18258%2F</url>
    <content type="text"><![CDATA[DescriptionImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: 12Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Difficulty: Easy Code: 12345class Solution &#123; public int strStr(String haystack, String needle) &#123; &#125;&#125; 题意实现String.indexOf()的功能，返回needle在haystack第一次出现的下标，若不存在则返回-1。若needle是空字符串，则返回0。 Solution 1遍历haystack直到其当前字符等于needle的首字符，然后基于needle比较后续字符是否相等。 若有不想等或者到达haystack末尾，则说明不匹配，haystack往后移动一位。 12345678910111213141516171819class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle==null||needle.isEmpty()) return 0; if(haystack==null||haystack.isEmpty()) return -1; for(int i=0;i&lt;haystack.length();i++)&#123; if(haystack.charAt(i)==needle.charAt(0))&#123; boolean flag = true; for(int j=0;j&lt;needle.length();j++)&#123; if(i+j&gt;=haystack.length() || haystack.charAt(i+j)!=needle.charAt(j))&#123; flag = false; break; &#125; &#125; if(flag) return i; &#125; &#125; return -1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2解法1的优化版本，遍历haystack时，直接比较needle的所有字符。 1234567891011121314class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle==null||needle.isEmpty()) return 0; if(haystack==null||haystack.length()&lt;needle.length()) return -1; for(int i=0;i&lt;=haystack.length()-needle.length();i++)&#123; int j = 0; for(;j&lt;needle.length();j++)&#123; if(haystack.charAt(i+j)!=needle.charAt(j)) break; &#125; if(j==needle.length()) return i; &#125; return -1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 027 Remove Element]]></title>
    <url>%2Fposts%2F39064%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: 12345Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 1234567Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Difficulty: Easy Code: 12345class Solution &#123; public int removeElement(int[] nums, int val) &#123; &#125;&#125; 题意给定一个整数数组nums，将所有等于val的元素移除，并且返回新数组的长度。 不允许分配额外的空间同创建新数组，必须直接修改当前数组以达到空间复杂度为O(1)。 Solution 1使用双指针，left指向最终去掉目前元素数组掉最新位置，right指向当前遍历掉位置。 若right的值不等于目标值val，则nums在left的值更新为right的值，left及right加1。 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int left = 0, right = 0; while(right&lt;nums.length)&#123; if(nums[right]!=val)&#123; nums[left++]=nums[right]; &#125; right++; &#125; return left; &#125;&#125; 时间复杂度: O(n)。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 026 Remove Duplicates from Sorted Array]]></title>
    <url>%2Fposts%2F12484%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Difficulty: Easy Code: 12345class Solution &#123; public int removeDuplicates(int[] nums) &#123; &#125;&#125; 题意给定一个有序的数字数组，移除重复的元素，并且返回新的长度。不允许分配额外的空间给另外一个数组，要直接修改输入数组达到O(1)的空间复杂度。 Solution 1使用双指针，left指向该数字出现的第一个位置，right初始指向left的下一位，len表示最终的长度。 遍历数组，若right位置上的数字和left相同，则right往后移动一位，直到发现不同的数字或者达到末尾。 当发现不同数字时，更新len，并将数组len-1上的值更新为最新发现的数字，同时left移动到right位置，right后移一位。 1234567891011121314151617181920class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length&lt;=1) return nums.length; int left = 0, right = 1; int len = 1; while(right&lt;nums.length)&#123; while(nums[right]==nums[left])&#123; right++; if(right&gt;=nums.length)&#123; return len; &#125; &#125; len++; nums[len-1]=nums[right]; left=right; right++; &#125; return len; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2对解法1进行优化，left指向最终去重后对当前位置，right指向当前遍历对位置。 当right位置上到元素和left不相等时，left后移一位，同时给left位置赋right的值，然后继续right后移一位。 123456789101112class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length&lt;=1) return nums.length; int left = 0, right = 0; while(++right &lt; nums.length)&#123; if(nums[right]!=nums[left])&#123; nums[++left]=nums[right]; &#125; &#125; return left+1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3也可以如解法2，只使用左侧指针，右侧依靠for循环来取出当前位置的值。 1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int n = 0; for(int num:nums)&#123; if(n==0 || num!=nums[n-1])&#123; nums[n++]=num; &#125; &#125; return n; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 025 Reverse Nodes in k-Group]]></title>
    <url>%2Fposts%2F34575%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. Difficulty: Hard Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; &#125;&#125; 题意给定一个链表，将其每k个节点反转，并返回修改后的链表。k是小于等于链表长度的正整数，不足k个时保持原样。不允许修改节点的值，只允许修改整个节点。 Solution 1把每k个节点为一组进行反转，那样需要两个函数，一个用来分段，一个用来反转。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), curr= head, start = curr , lastDone = dummy; int count = 0; while(curr!=null)&#123; count++; ListNode nextOne = curr.next; if(count==k)&#123; lastDone.next=reverse(start,k); lastDone=start; start=nextOne; count=0; &#125; curr=nextOne; &#125; lastDone.next=start; return dummy.next; &#125; public ListNode reverse(ListNode node, int k)&#123; ListNode dummy = new ListNode(0), curr = node; for(int i=0;i&lt;k;i++)&#123; ListNode tmp = dummy.next; dummy.next = curr; curr = curr.next; dummy.next.next=tmp; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上述解法，是以k为步进来生成最终的结果链表，保存了很多状态。也可以很平滑地进行反转，在反转是带上k个节点为一组的前置和后置节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), pre = dummy, curr = head; dummy.next = head; for(int i=1;curr!=null;i++)&#123; if(i%k==0)&#123; pre = reverse(pre,curr.next); curr = pre.next; &#125;else&#123; curr = curr.next; &#125; &#125; return dummy.next; &#125; public ListNode reverse(ListNode pre, ListNode next)&#123; ListNode last = pre.next, curr = last.next; while(curr!=next)&#123; last.next = curr.next; curr.next = pre.next; pre.next = curr; curr = last.next; &#125; return last; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3上述过程也可以在一个方法中完成，先遍历整个链表计算出链表长度，然后每次对k个节点进行反转。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), pre = dummy, curr = head; dummy.next = head; int num = 0; while(curr!=null)&#123; num++; curr = curr.next; &#125; while(num&gt;k)&#123; curr = pre.next; for(int i=1;i&lt;k;i++)&#123; ListNode tmp = curr.next; curr.next=tmp.next; tmp.next=pre.next; pre.next=tmp; &#125; pre = curr; num -= k; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 4递归调用，我们用pre记录每段的开始位置的前一个节点，cur记录结束位置的下一个节点，然后我们调用reverse函数来将这段翻转，然后得到一个new_head，原来的head就变成了末尾，这时候后面接上递归调用下一段得到的新节点，返回new_head即可。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), pre = dummy, curr = head; dummy.next = head; for(int i=0;i&lt;k;i++)&#123; if(curr==null) return head; curr = curr.next; &#125; ListNode newHead = reverse(pre,curr); head.next = reverseKGroup(curr,k); return newHead; &#125; public ListNode reverse(ListNode pre, ListNode next)&#123; ListNode last = pre.next, curr = last.next; while(curr!=next)&#123; last.next = curr.next; curr.next = pre.next; pre.next = curr; curr = last.next; &#125; return pre.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 024 Swap Nodes in Pairs]]></title>
    <url>%2Fposts%2F65154%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; &#125;&#125; 题意给定一个链表，按顺序将每两个节点交换，并返回链表头部。不能修改节点的值，只能改变整个节点。 Solution 1若链表为空或只有一个节点则返回头节点。循环遍历，条件是当前节点和当前节点的下一个节点都存在，在循环体中把这两个交换位置放入结果链表中。 当退出循环体后，只有一个节点没有遍历或者都遍历过，只需要在将其添加到结果链表中去。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), curr = dummy; while(head!=null&amp;&amp;head.next!=null)&#123; ListNode tmp = head.next.next; curr.next=head.next; curr.next.next=head; curr=curr.next.next; head=tmp; &#125; curr.next=head; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2递归调用，先把链表的前两个节点交换，再对除去这两个节点对链表进行递归调用，并将其赋给第二个节点的下一位，返回第一个节点。 1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode res = head.next; head.next=swapPairs(head.next.next); res.next=head; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 023 Merge k Sorted Lists]]></title>
    <url>%2Fposts%2F44312%2F</url>
    <content type="text"><![CDATA[DescriptionMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Difficulty: Hard Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; &#125;&#125; 题意把K个有序链表合并成一个有序链表。 Solution 1和合并两个链表类似，建立哨兵节点，结果返回哨兵节点下一位。进循环，循环中每次遍历所有链表的首个节点，并比较各个节点，找出值最小的节点。 将结果链接的当前节点指向这个最小节点，并将链表数组中最小节点所在的链表移动到最小节点到下一节点。 若碰到某个链表当前节点为空则跳过，若所有链表当前节点都为空则退出循环。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode dummy=new ListNode(0), curr=dummy; while(true)&#123; int num = lists.length; int minVal = Integer.MAX_VALUE; int minIndex = -1; ListNode minNode = null; for(int i=0;i&lt;lists.length;i++)&#123; ListNode node = lists[i]; if(node==null)&#123; num--; continue; &#125; if(node.val&lt;minVal)&#123; minVal=node.val; minIndex = i; minNode=node; &#125; &#125; if(minNode!=null)&#123; curr.next=minNode; curr=curr.next; lists[minIndex]=minNode.next; &#125; if(num==0)&#123; break; &#125; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2使用PriorityQueue来维持一个最小堆，把k个链表到首节点放入优先队列中，它们会自动根据值val排序好。 每次取出最小的节点加入到结果链表中，并把该最小节点的下一位放入队列中。依此类推，直到队列中没有元素。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists==null||lists.length==0) return null; ListNode dummy=new ListNode(0), curr=dummy; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(lists.length, new Comparator&lt;ListNode&gt;()&#123; public int compare(ListNode o1, ListNode o2)&#123; if(o1.val&lt;o2.val)&#123; return -1; &#125;else if(o1.val==o2.val)&#123; return 0; &#125;else&#123; return 1; &#125; &#125; &#125;); for(ListNode node:lists)&#123; if(node!=null)&#123; queue.add(node); &#125; &#125; while(!queue.isEmpty())&#123; curr.next=queue.poll(); curr=curr.next; if(curr.next!=null)&#123; queue.add(curr.next); &#125; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3不管几个链表，都可以两两合并，最终合并成一个链表。利用分治思想，将链表数组从中划分为两部分，分别顺序合并两部分每一个链表并赋给前半部分。 不停地对半划分并合并更新，直到应该合并的链表数量为1，即已经合并完成所有链表。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists==null||lists.length==0) return null; int n = lists.length; while(n&gt;1)&#123; int steps = (n+1)/2; for(int i=0;i&lt;n/2;i++)&#123; lists[i]=mergeTwoLists(lists[i],lists[i+steps]); &#125; n=steps; &#125; return lists[0]; &#125; public ListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; ListNode dummy=new ListNode(0), curr=dummy; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; curr.next=l1; curr=curr.next; l1=l1.next; &#125;else&#123; curr.next=l2; curr=curr.next; l2=l2.next; &#125; &#125; if(l1==null) curr.next=l2; if(l2==null) curr.next=l1; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-divide-and-conquer</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 022 Generate Parentheses]]></title>
    <url>%2Fposts%2F28316%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; &#125;&#125; 题意给定n对括弧，生成所有正确形式组合的字符串。 Solution 1对于这种列出所有结果的题目优先考虑递归Recursion求解。对于n，则有n个左括号和n个右括号，定义两个变量open、close表示左右括号还剩下的个数。因为总是先出现左括号，所有open应该不大于close。 若出现open大于close则直接返回。若open和close都为0则将当前字符串放入结果中。若open或者close不为0，则递归调用并更新open或close的值。 12345678910111213141516171819class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(n&lt;=0) return res; generate(n,n,res,""); return res; &#125; public void generate(int open, int close, List&lt;String&gt; res, String out)&#123; if(close&lt;open) return; if(open==0&amp;&amp;close==0) res.add(out); if(open&gt;0)&#123; generate(open-1,close,res,out+"("); &#125; if(close&gt;0)&#123; generate(open,close-1,res,out+")"); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2没当N加1时，找现有N的所有结果，在结果字符串中如果遇见左括号，则直接在其后加入()或者在该字符串末尾加上()，然后返回。使用Set去重，变化如下所示。 12345n＝1: ()n=2: (()) ()()n=3: (()()) ((())) ()(()) (())() ()()() 1234567891011121314151617181920class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; if(n&lt;=0) return new ArrayList&lt;String&gt;(); Set&lt;String&gt; res = new HashSet&lt;String&gt;(); res.add("()"); for(int i=1;i&lt;n;i++)&#123; Set&lt;String&gt; tmp = new HashSet&lt;String&gt;(); for(String str:res)&#123; for(int j=0;j&lt;str.length();j++)&#123; if(str.charAt(j)=='(')&#123; tmp.add(str.substring(0,j+1)+"()"+str.substring(j+1)); tmp.add(str+"()"); &#125; &#125; &#125; res = tmp; &#125; return new ArrayList&lt;String&gt;(res); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 021 Merge Two Sorted Lists]]></title>
    <url>%2Fposts%2F13700%2F</url>
    <content type="text"><![CDATA[DescriptionMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Difficulty: Easy Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; &#125;&#125; 题意把K个有序链表合并成一个有序链表。 Solution 1建立哨兵节点，当前节点指向哨兵节点。开始While循环，条件是l1和l2都不为空。在循环体中，比较l1和l2到值找出较小的节点，到将其放在结果链表当前位置之后，并将该节点及结果链接都往后移一位，继续循环。 由于遍历到最后，肯定有一个链表先遍历到末尾退出循环，则结果链表的后面接上未完成的链表，最终返回哨兵节点的后一位。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy=new ListNode(0), curr=dummy; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; curr.next=l1; l1=l1.next; &#125;else&#123; curr.next=l2; l2=l2.next; &#125; curr=curr.next; &#125; curr.next=l1!=null?l1:l2; return dummy.next; &#125;&#125; 时间复杂度: O(M+N)，两个链表的长度。 空间复杂度: O(M+N)，两个链表的长度。 Solution 2使用递归，比较两个链表当前节点的大小找出较小的节点，则对剩余对节点进行递归调用，将返回对结果赋给此节点对下一位，同时返回该节点作为结果。 相当于每次递归只找出一个合适的节点，递归结束的条件是有个链表为空，则直接返回另一个链表未完成的部分。 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;=l2.val)&#123; l1.next=mergeTwoLists(l1.next,l2); return l1; &#125;else&#123; l2.next=mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125; 时间复杂度: O(M+N)，两个链表的长度。 空间复杂度: O(M+N)，两个链表的长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 020 Valid Parentheses]]></title>
    <url>%2Fposts%2F29601%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]‘, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;&#123;[]&#125;&quot;Output: true Difficulty: Easy Code: 12345class Solution &#123; public boolean isValid(String s) &#123; &#125;&#125; 题意给定一个字符串，只包含”(){}[]”，判断输入到字符串是否有效。开括号和必须以同样到类型到闭括号关闭，开括号必须以正确到顺序关闭。 Solution 1看到开括号必要要以相同到顺序关闭，自然想到栈，读取到开括号则压栈，读取到闭括号则出栈并判断是否配对。读取完栈需为空，否则无效。 12345678910111213141516171819class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); String left = "([&#123;"; String right = ")]&#125;"; for(char curr:s.toCharArray())&#123; if(left.indexOf(curr)!=-1)&#123; stack.push(curr); &#125;else if(right.indexOf(curr)!=-1)&#123; if(stack.isEmpty()) return false; char open = stack.pop(); if(right.charAt(left.indexOf(open))!=curr)&#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 时间复杂度: O(N)，字符串长度。 空间复杂度: O(N)，字符串长度。 Solution 2把所有括号符号依次拼接成字符串，Stack里面存括号在字符串中位置，以简化计算。 12345678910111213public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Integer&gt; p = new Stack&lt;&gt;(); String brackets = "()&#123;&#125;[]"; for(char curr:s.toCharArray()) &#123; int q = brackets.indexOf(curr); if(q % 2 == 1) &#123; if(p.isEmpty() || p.pop() != q - 1) return false; &#125; else p.push(q); &#125; return p.isEmpty(); &#125;&#125; 时间复杂度: O(N)，字符串长度。 空间复杂度: O(N)，字符串长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 019 Remove Nth Node From End of List]]></title>
    <url>%2Fposts%2F58507%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; &#125;&#125; 题意给定一个链表，移除链表的倒数第N个节点，并返回链表的头节点。限定N总是有效的不会超出链表长度，最好遍历一次。 Solution 1在第一个节点的前面建立一个哨兵节点，使用双指针left和right，最初都指向哨兵节点。 然后先把right往后移N位，若right的next为空则表明N和链表的长度相同，要删除第一个节点。 否则开始同时移动left和right，保持right和left间距为N，直至right的next为空即移动到末尾。此时，left到下一个节点即为要删除到节点。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head.next==null) return null; ListNode dummy = new ListNode(0); dummy.next=head; ListNode left = dummy, right = dummy; for(int i=0;i&lt;n;i++)&#123; right=right.next; &#125; if(right.next==null) return dummy.next.next; while(right.next!=null)&#123; right=right.next; left=left.next; &#125; left.next=left.next.next; return dummy.next; &#125;&#125; 时间复杂度: O(N)，遍历一次。 空间复杂度: O(1)，使用恒定到额外空间。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 018 4Sum]]></title>
    <url>%2Fposts%2F52863%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; &#125;&#125; 题意给定n个整数和一个目标整数，从n个整数中找出所有不重复的4个数字组合，使得它们之和等于目标整数。 Solution 1和三数之和一样，把数组从小到大排序，循环固定前两个数字，后两个数组采用双指针，一个从前往后，一个从后往前。 若四数之和等于目标值则加入结果集，若大于，则右侧数字往左移，否则左侧数字往右移。通过Set过滤重复元素。 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Set&lt;List&lt;Integer&gt;&gt; result = new HashSet&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-3;i++)&#123; for(int j=i+1;j&lt;nums.length-2;j++)&#123; int left=j+1,right=nums.length-1; while(left&lt;right)&#123; int sum = nums[i]+nums[j]+nums[left]+nums[right]; if(sum==target)&#123; result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); left++; right--; &#125;else if(sum&gt;target)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(result); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2下面解法不使用Set去重，对于四个数的每一位取值上，若当前数字和前一位一样则跳过。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-3;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; for(int j=i+1;j&lt;nums.length-2;j++)&#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; int left=j+1,right=nums.length-1; while(left&lt;right)&#123; int sum = nums[i]+nums[j]+nums[left]+nums[right]; if(sum==target)&#123; result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left&lt;right&amp;&amp;nums[left+1]==nums[left]) left++; while(left&lt;right&amp;&amp;nums[right-1]==nums[right]) right--; left++; right--; &#125;else if(sum&gt;target)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; &#125; return result; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 017 Letter Combinations of a Phone Number]]></title>
    <url>%2Fposts%2F35100%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Difficulty: Medium Code: 12345class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; &#125;&#125; 题意给定一个包含数字2-9的字符串，返回数字代表的所有可能的字符组合。数字和字母的映射和电话按钮一样。 Solution 1使用递归进行，递归方法没有返回值，只有当递归到输入字符串为空时，才将当前字符组合添加进结果集并返回。 否则，找到当前字符串第一位对应到所有字符，循环调用递归，更新参数。 1234567891011121314151617181920class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if(digits.isEmpty()) return result; String[] mapping = new String[]&#123;"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;; generateAll(digits,result,"",mapping); return result; &#125; public void generateAll(String digits, List&lt;String&gt; result, String out, String[] mapping)&#123; if(digits.isEmpty())&#123; result.add(out); return; &#125;; int index = (digits.charAt(0)-'0')-2; for(char curr:mapping[index].toCharArray())&#123; generateAll(digits.substring(1),result,out+curr,mapping); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2使用迭代，结果集初始化进去一个空字符串。在遍历digits中的所有数字时，先建立一个临时字符串结果列表，通过数字取出其对应字符数组，遍历字符数组并取出结果集中所有字符串，将字符拼接在后面并放入临时列表。 每遍历一个数字，将结果集重新指向临时列表。 12345678910111213141516171819class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if(digits.isEmpty()) return result; String[] mapping = new String[]&#123;"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;; result.add(""); for(int i=0;i&lt;digits.length();i++)&#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); int index = (digits.charAt(i)-'0')-2; for(String s:result)&#123; for(char c:mapping[index].toCharArray())&#123; tmp.add(s+c); &#125; &#125; result=tmp; &#125; return result; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 016 3Sum Closest]]></title>
    <url>%2Fposts%2F38928%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Difficulty: Medium Code: 12345class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; &#125;&#125; 题意给定n个整数和一个目标整数，找出三个整数，其和和目标整数最接近。 Solution 1和求三数之和为0类似，循环固定第一个数，第二个数从第一个数下一位往右取，第三个从末尾往左取。 定义一个变量记录三数之和与给定值差的绝对值，比较差值，若小则更新最小差值并记录和。 123456789101112131415161718192021222324class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int closest = Integer.MAX_VALUE, res = Integer.MAX_VALUE; Arrays.sort(nums); for(int i=0;i&lt;nums.length-2;i++)&#123; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; int sum = nums[i]+nums[j]+nums[k]; if(closest&gt;Math.abs(sum-target))&#123; closest = Math.abs(sum-target); res = sum; &#125; if(sum==target)&#123; return target; &#125;else if(sum&gt;target)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n2)，每个数字最多遍历两遍。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 015 3Sum]]></title>
    <url>%2Fposts%2F42879%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; &#125;&#125; 题意给定n个整数，求所有三个数字组合使得它们之和为0，数字组合不能重复。 Solution 1可以将数字排序，顺序取三个满足条件的数字。循环固定第一个数字，肯定不大于0，否则之和会大于0。第二个数字从第一个数的右边开始往右，第三个从末尾开始往左。 若之和为0，则添加进结果集。若小于0，则第二个数字太小，需要往右侧移动。若大于0，则表明第三个数字过大，需要往左侧移动。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-2&amp;&amp;nums[i]&lt;=0;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123; continue; &#125; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; if(nums[i]+nums[j]+nums[k]==0)&#123; List&lt;Integer&gt; match = new ArrayList&lt;&gt;(); match.add(nums[i]); match.add(nums[j]); match.add(nums[k]); res.add(match); while(j&lt;k&amp;&amp;nums[j+1]==nums[j])&#123; j++; &#125; while(j&lt;k&amp;&amp;nums[k-1]==nums[k])&#123; k--; &#125; j++; k--; &#125;else if(nums[i]+nums[j]+nums[k]&gt;0)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n2)，每个数字最多遍历两遍。 空间复杂度: O(1)，需要保存结果集。 Solution 2可以使用Set来保存结果，这样可以去掉去重部分的代码。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-2&amp;&amp;nums[i]&lt;=0;i++)&#123; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; if(nums[i]+nums[j]+nums[k]==0)&#123; res.add(Arrays.asList(nums[i],nums[j],nums[k])); j++; k--; &#125;else if(nums[i]+nums[j]+nums[k]&gt;0)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return new ArrayList(res); &#125;&#125; 时间复杂度: O(n2)，每个数字最多遍历两遍。 空间复杂度: O(1)，需要保存结果集。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 014 Longest Common Prefix]]></title>
    <url>%2Fposts%2F48879%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Difficulty: Easy Code: 12345class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; &#125;&#125; 题意在字符串数组中找出最长的公共前缀字符串，若没有则返回空字符串。 Solution 1已字符串数组到第一个元素为基础，遍历该字符串取得当前字符，然后遍历其他字符串到当前位置，若其他字符串已经到达末尾或者字符不一致，则返回已经匹配过的。 1234567891011121314class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs==null||strs.length==0||strs[0]==null||strs[0].length()==0) return ""; for(int i=0;i&lt;strs[0].length();i++)&#123; char curr = strs[0].charAt(i); for(int j=1;j&lt;strs.length;j++)&#123; if(strs[j].length()&lt;=i||strs[j].charAt(i)!=curr)&#123; return strs[0].substring(0,i); &#125; &#125; &#125; return strs[0]; &#125;&#125; 时间复杂度: O(S)，S是所有字符串字符的长度，因为所有字符都只遍历一次。 空间复杂度: O(1)。 Solution 2可以将所以字符串排序，那么最前和最后的字符串肯定是差距最大的，此时只需要比较这两个字符串即可。 123456789101112131415class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs==null||strs.length==0) return ""; Arrays.sort(strs); int len = Math.min(strs[0].length(),strs[strs.length-1].length()); int i=0; while(i&lt;len)&#123; if(strs[0].charAt(i)!=strs[strs.length-1].charAt(i))&#123; return strs[0].substring(0,i); &#125; i++; &#125; return strs[0].substring(0,i); &#125;&#125; 时间复杂度: O(S)，S是所有字符串字符的长度，因为所有字符都只遍历一次。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 013 Roman to Integer]]></title>
    <url>%2Fposts%2F19839%2F</url>
    <content type="text"><![CDATA[DescriptionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Difficulty: Easy Code: 12345class Solution &#123; public int romanToInt(String s) &#123; &#125;&#125; 题意将罗马数字转成整数，假定此整数范围在1到3999。 Solution 1将罗马字符和其整数值相对应，遍历罗马数字字符串，若后一位字符所代表到位数比当前位数高，则用后一位到整数值减去当前位到整数值再累加，否则直接累加。 12345678910111213141516class Solution &#123; public int romanToInt(String s) &#123; int result = 0; int[] values = new int[]&#123;1000,500,100,50,10,5,1&#125;; String roman = "MDCLXVI"; for(int i=0;i&lt;s.length();i++)&#123; if(i&lt;s.length()-1&amp;&amp;roman.indexOf(s.charAt(i))&gt;roman.indexOf(s.charAt(i+1)))&#123; result += values[roman.indexOf(s.charAt(i+1))] - values[roman.indexOf(s.charAt(i))]; i++; &#125;else&#123; result += values[roman.indexOf(s.charAt(i))]; &#125; &#125; return result; &#125;&#125; 时间复杂度: O(n)，数字到长度。 空间复杂度: O()。 Solution 2我们需要用到HashMap数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可：第一，如果当前数字不是最后一个数字且之后的数字比它大的话，则减去当前数字。第二，其他情况则加上这个数字。 12345678910111213141516171819202122class Solution &#123; public int romanToInt(String s) &#123; int result = 0; Map&lt;Character,Integer&gt; romans = new HashMap&lt;Character,Integer&gt;(); romans.put('M',1000); romans.put('D',500); romans.put('C',100); romans.put('L',50); romans.put('X',10); romans.put('V',5); romans.put('I',1); for(int i=0;i&lt;s.length();i++)&#123; char curr = s.charAt(i); if(i&lt;s.length()-1&amp;&amp;romans.get(curr)&lt;romans.get(s.charAt(i+1)))&#123; result -= romans.get(curr); &#125;else&#123; result += romans.get(curr); &#125; &#125; return result; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 012 Integer to Roman]]></title>
    <url>%2Fposts%2F56606%2F</url>
    <content type="text"><![CDATA[DescriptionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: 3Output: &quot;III&quot; Example 2: 12Input: 4Output: &quot;IV&quot; Example 3: 12Input: 9Output: &quot;IX&quot; Example 4: 123Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. Example 5: 123Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Difficulty: Medium Code: 12345class Solution &#123; public String intToRoman(int num) &#123; &#125;&#125; 题意给定一个整数，将其转成罗马数字，整数的范围在1到3999。 Solution 1给定的整数范围在1到3999，那么只有千位、百位、十位、个位。例如计算出百位的数字，那么这个百位数字涉及到到罗马字符只有’M’,’D’,’C’，同理其他位。写一个工具方法，可以根据当前位的值及涉及的三个罗马字符得到此位最后的罗马字符。对数不断对位的权重取商，并更新为对位的权重求余结果。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); char[] symbols = new char[]&#123;' ',' ','M','D','C','L','X','V','I'&#125;; int weight = 1000; int index = 0; while(num!=0)&#123; int n = num/weight; appendRoman(sb,n,symbols[index],symbols[index+1],symbols[index+2]); num = num%weight; weight=weight/10; index+=2; &#125; return sb.toString(); &#125; public void appendRoman(StringBuilder sb, int n, char prev, char five, char one)&#123; if(n==4)&#123; sb.append(one).append(five); &#125;else if(n==9)&#123; sb.append(one).append(prev); &#125;else if(n&lt;4)&#123; for(int i=0;i&lt;n;i++)&#123; sb.append(one); &#125; &#125;else&#123; sb.append(five); for(int i=0;i&lt;n-5;i++)&#123; sb.append(one); &#125; &#125; &#125;&#125; 时间复杂度: O(n)，数字的长度。 空间复杂度: O()。 Solution 2上述解法还有另外一种写法，在一个函数即可完成。 12345678910111213141516171819202122class Solution &#123; public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); char[] romans = new char[]&#123;'M','D','C','L','X','V','I'&#125;; int[] values = new int[]&#123;1000,500,100,50,10,5,1&#125;; for(int i=0;i&lt;7;i+=2)&#123; int x = num/values[i]; num=num%values[i]; if(x&lt;4)&#123; for(int j=0;j&lt;x;j++) sb.append(romans[i]); &#125;else if(x==4)&#123; sb.append(romans[i]).append(romans[i-1]); &#125;else if(x&gt;4&amp;&amp;x&lt;9)&#123; sb.append(romans[i-1]); for(int j=0;j&lt;x-5;j++) sb.append(romans[i]); &#125;else if(x==9)&#123; sb.append(romans[i]).append(romans[i-2]); &#125; &#125; return sb.toString(); &#125;&#125; 时间复杂度: O(n)，数字的长度。 空间复杂度: O()。 Solution 3将十进制进一步细分到每次罗马字符变动到数表，如十位划分成90、50、40、10。每次找到当前最大的数，返回结果加上对应的罗马字符并减去。 1234567891011121314class Solution &#123; public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); String[] romans = new String[]&#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; int[] values = new int[]&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; for(int i=0;i&lt;romans.length;i++)&#123; while(num&gt;=values[i])&#123; sb.append(romans[i]); num-=values[i]; &#125; &#125; return sb.toString(); &#125;&#125; 时间复杂度: O(n)，数字的长度。 空间复杂度: O()。 Solution 4建立更加详细的数表，把位上的1-9都给列出来，直接查表。 123456789class Solution &#123; public String intToRoman(int num) &#123; String[] m = new String[]&#123;"", "M", "MM", "MMM"&#125;; String[] c = new String[]&#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String[] x = new String[]&#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String[] i = new String[]&#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return m[num / 1000] + c[(num % 1000) / 100] + x[(num % 100) / 10] + i[num % 10]; &#125;&#125; 时间复杂度: O(1)，直接查表。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 011 Container With Most Water]]></title>
    <url>%2Fposts%2F12616%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 Difficulty: Medium Code: 12345class Solution &#123; public int maxArea(int[] height) &#123; &#125;&#125; 题意给定正整数1, a2, …, an，代表坐标轴横轴上1到n到地方，各有一条垂直到线段，其另一端到高度为正整数到值。两根线及横轴组成了容器，求使容器装最多水到两条线段，并返回装水到面积。 Solution 1使用双指针，定义i和j分别指向数组到左右两端，然后两个指针向中间搜索。搜索到策略是如果左右两端某端的高度要小一些，则将这一端向中间移动，并更新最大面积。因为如果往中间移动高度较高的一端，则面积只会减小，因为最终的面积的高度是由较低的那端决定的，这样高度不变，长度缺减少，面积只能也减小。 123456789101112131415class Solution &#123; public int maxArea(int[] height) &#123; int i=0,j=height.length-1,max=0; while(i&lt;j)&#123; int h = Math.min(height[i],height[j]); max = Math.max(h*(j-i),max); if(height[i]&lt;height[j])&#123; i++; &#125;else&#123; j--; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n)，遍历一遍数组。 空间复杂度: O(1)。 Solution 2也可以在上述解法上小优化，不用每步都计算面积。当确定左侧还是右侧向中间移动后，跳过高度小于上次计算时那侧高度的点。 1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int i=0,j=height.length-1,max=0; while(i&lt;j)&#123; int h = Math.min(height[i],height[j]); max = Math.max(h*(j-i),max); boolean moveRight = height[i]&lt;height[j]?true:false; while(i&lt;j&amp;&amp;moveRight&amp;&amp;h&gt;=height[i])&#123; i++; &#125;; while(i&lt;j&amp;&amp;!moveRight&amp;&amp;h&gt;=height[j])&#123; j--; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n)，遍历一遍数组。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 010 Regular Expression Matching]]></title>
    <url>%2Fposts%2F47345%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false Difficulty: Hard Code: 12345class Solution &#123; public boolean isMatch(String s, String p) &#123; &#125;&#125; 题意这道题关于正则表达式，’.’表示任意字符，’*’表示其之前的字符可以出现0次或者多次。要求返回字符串是否完全匹配正则表达式。 Solution 1使用递归来解，大致思路如下： 当p为空时，若s为空则返回true，否则返回false 当p的长度为1时，若s当长度也为1并且s[0]==p[0]或者p[0]==’.’则返回true，否则返回false 当p的第二个字符不为’*’时，若s为空则返回false，否则判断首字符是否匹配，并且从各自的第二个字符递归调用去匹配 当p的第二个字符为’*’时，进行下列循环，条件时s不为空并且首字符匹配，在循环中递归调用去匹配s和去掉前两个字符的p（假设此时p星号的作用是让前面的字符出现0次） 若匹配则返回true，否则去掉s首字符继续循环（因为首字符已经匹配所以可以去掉s首字符往后面去匹配） 返回递归调用去匹配s和去掉前两个字符的p，因为要处理以下两种情况 若s为空，则表明p的星号表示出现0次 若s不为空，首字符不匹配，也表明p的星号表示出现0次 1234567891011121314151617181920212223242526class Solution &#123; public boolean isMatch(String s, String p) &#123; if(p.length()==0)&#123; return s.length()==0; &#125; if(p.length()==1)&#123; return s.length()==1&amp;&amp;(s.charAt(0)==p.charAt(0)||p.charAt(0)=='.'); &#125; if(p.charAt(1)!='*')&#123; if(s.length()==0)&#123; return false; &#125;else if(s.length()==1)&#123; return (s.charAt(0)==p.charAt(0)||p.charAt(0)=='.')&amp;&amp;isMatch("",p.substring(1)); &#125;else&#123; return (s.charAt(0)==p.charAt(0)||p.charAt(0)=='.')&amp;&amp;isMatch(s.substring(1),p.substring(1)); &#125; &#125; while(s.length()!=0&amp;&amp;(s.charAt(0)==p.charAt(0)||p.charAt(0)=='.'))&#123; if(isMatch(s,p.substring(2)))&#123; return true; &#125; s=s.substring(1); &#125; return isMatch(s,p.substring(2)); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上面的解法可以换一种写法，让代码更简洁 1234567891011121314class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) return s.isEmpty(); boolean first_match = (!s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')); if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '*')&#123; return (isMatch(s, p.substring(2)) || (first_match &amp;&amp; isMatch(s.substring(1), p))); &#125; else &#123; return first_match &amp;&amp; isMatch(s.substring(1), p.substring(1)); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3动态规划解法，dp[i][j]表示s[0:i)和p[0:j)是否匹配，从前往进行匹配。 条件判断： 1231. P[i][j] = P[i - 1][j - 1], if p[j - 1] != &apos;*&apos; &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;);2. P[i][j] = P[i][j - 2], if p[j - 1] == &apos;*&apos; and the pattern repeats for 0 times;3. P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;), if p[j - 1] == &apos;*&apos; and the pattern repeats for at least 1 times. 12345678910111213141516171819class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0 ; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; if(j&gt;1 &amp;&amp; p.charAt(j-1)=='*')&#123; dp[i][j]=dp[i][j-2]||(i&gt;0&amp;&amp;(s.charAt(i-1)==p.charAt(j-2)||p.charAt(j-2)=='.')&amp;&amp;dp[i-1][j]); &#125;else&#123; dp[i][j]=i&gt;0&amp;&amp;(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.')&amp;&amp;dp[i-1][j-1]; &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125;&#125; 时间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。 空间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。 Solution 4使用动态规划，dp[i][j]表示s[i:]和p[j:]是否匹配，从后往前进行匹配。 1234567891011121314151617181920class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[s.length()][p.length()] = true; for (int i = s.length(); i &gt;= 0; i--)&#123; for (int j = p.length() - 1; j &gt;= 0; j--)&#123; boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')); if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*')&#123; dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j]; &#125; else &#123; dp[i][j] = first_match &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125; 时间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。 空间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 009 Palindrome Number]]></title>
    <url>%2Fposts%2F5013%2F</url>
    <content type="text"><![CDATA[DescriptionDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Difficulty: Easy Code: 12345class Solution &#123; public boolean isPalindrome(int x) &#123; &#125;&#125; 题意判断一个int数是否是回文格式，即从前读取和从后开始读取都是一样的。 Solution 1首先负数排除，不是回文数字。而0是回文数字。针对正数，可以从后往前读取并累加来找出其反向数字，并和原始数字进行比较。 若反转时溢出，那么最终的结果肯定不会相等，可以不用判断是否溢出。 12345678910111213141516class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125;else if(x==0)&#123; return true; &#125; int reverseNum = 0; int curr = x; while(curr!=0)&#123; reverseNum = reverseNum*10 + curr%10; curr = curr/10; &#125; return reverseNum==x; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(1)，只使用int来保存结果。 Solution 2首先负数排除，不是回文数字。而0是回文数字。并且如果正数的末尾是0也不是回文。 其他正数只需要验证前后半段是否对称，和解法1相比快了一倍。具体做法是：每次对10取余取出数的末尾，把reverseNum乘以10并加上余数；同时把x除以10。这样当reverseNum大于等于x时停止循环，x即为前半段，reverseNum为后半段。由于回文数的位数可奇可偶，偶数时两者相等，奇数时中间数字在reverseNum最低位需除以10后再比较。 1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125;else if(x==0)&#123; return true; &#125;else if(x%10==0)&#123; return false; &#125; int reverseNum = 0; while(x&gt;reverseNum)&#123; reverseNum = reverseNum*10 + x%10; x = x/10; &#125; return x==reverseNum || x==reverseNum/10; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(1)，只使用int来保存结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 008 String to Integer (atoi)]]></title>
    <url>%2Fposts%2F64402%2F</url>
    <content type="text"><![CDATA[DescriptionImplement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. Difficulty: Medium Code: 12345class Solution &#123; public int myAtoi(String str) &#123; &#125;&#125; 题意实现atoi函数将字符串转换为整数。 函数首先尽可能多的丢弃空白字符，直到发现第一个非空字符位为止。 接着从这个字符开始，读入一个可选的正负号，然后尽可能多的读入数字，最后将它们解析成数值。 字符串中在合法数字后可以包含额外的非法字符，对于这些字符只需丢弃即可。 如果字符串的非空字符不是一个有效的整数，或者，当字符串为空或者只包含空白字符时，不需要执行转换。 如果不能够执行有效的转换则返回0。如果得到的数值超出了整数范围，返回INT_MAX (2147483647) 或者 INT_MIN (-2147483648)。 Solution 1使用StringBuilder保存取出的数字，布尔类型保存是否是正数。开始遍历字符串，有以下情况： 只有最前面的空格可以忽略 第一次遍历到’-‘或则’+’则更新是否是正数 若为数字 如果当前已保存的数字为空，且当前数字为0后一位也为0，则忽略 其他则保存进StringBuilder 其他情况则条件不符，退出遍历 而后判断长度是否超出Integer的限制，并转成Long判断其具体是否超出Integer区间范围。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int myAtoi(String str) &#123; nt len=str.length(); StringBuilder sb = new StringBuilder(); Boolean positive = null; for(int i=0;i&lt;len;i++)&#123; if(sb.length()==0&amp;&amp;positive==null&amp;&amp;str.charAt(i)==' ')&#123; continue; &#125; if(sb.length()==0&amp;&amp;positive==null&amp;&amp;(str.charAt(i)=='-'||str.charAt(i)=='+'))&#123; positive=str.charAt(i)=='-'?false:true; continue; &#125; if(str.charAt(i)&gt;='0'&amp;&amp;str.charAt(i)&lt;='9')&#123; if(sb.length()==0&amp;&amp;str.charAt(i)=='0'&amp;&amp;i&lt;len-1&amp;&amp;str.charAt(i+1)=='0')&#123; continue; &#125;else&#123; sb.append(str.charAt(i)); continue; &#125; &#125; break; &#125; int maxLen = String.valueOf(Integer.MAX_VALUE).length(); if(sb.length()==0)&#123; return 0; &#125; positive=positive==null?true:positive; if(sb.length()&gt;maxLen)&#123; return positive?Integer.MAX_VALUE:Integer.MIN_VALUE; &#125; Long longValue = positive?Long.valueOf(sb.toString()):0L-Long.valueOf(sb.toString()); if(longValue&gt;Integer.MAX_VALUE)&#123; return Integer.MAX_VALUE; &#125;else if(longValue&lt;Integer.MIN_VALUE)&#123; return Integer.MIN_VALUE; &#125;else&#123; return longValue.intValue(); &#125; &#125;&#125; 时间复杂度: O(n)，遍历一次字符串。 空间复杂度: O(n)，使用StringBuilder，取决于字符串长度。 Solution 2使用一个int保存结果，另外一个int保存1或者-1代表正负数。截去字符串前后空格后，开始遍历字符串，有以下情况： 首字符为’-‘或’+’则更新正负数 若为数字 判断当前已保存的结果如果乘以10倍的过程中超出int范围则返回 把当前已保存的结果乘以10并加上当前字符的数值 再次判断是否超出int范围 其他情况则条件不符，退出遍历 其中判断是否超出int范围，可以用保存的数和加上当前数值后的符号是否发生变化来判断，因为超出区间后其正负发生反转。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int myAtoi(String str) &#123; if(str==null||str.length()==0) return 0; str=str.trim(); int num=0; int sign=1; for(int i=0;i&lt;str.length();i++)&#123; char curr = str.charAt(i); if(i==0&amp;&amp;curr=='+')&#123; sign=1; &#125;else if(i==0&amp;&amp;curr=='-')&#123; sign=-1; &#125;else if(curr&gt;='0'&amp;&amp;curr&lt;='9')&#123; int prev = 0; for(int j=0;j&lt;10;j++)&#123; prev+=num; if(num&gt;0&amp;&amp;prev&lt;0)&#123; return Integer.MAX_VALUE; &#125;else if(num&lt;0&amp;&amp;prev&gt;0)&#123; return Integer.MIN_VALUE; &#125; &#125; prev = 10*num + sign*(curr-'0'); if(num&gt;0&amp;&amp;prev&lt;0)&#123; return Integer.MAX_VALUE; &#125;else if(num&lt;0&amp;&amp;prev&gt;0)&#123; return Integer.MIN_VALUE; &#125; num=prev; &#125;else&#123; break; &#125; &#125; return num; &#125;&#125; 时间复杂度: O(n)，遍历一次字符串。 空间复杂度: O(1)，使用int数字保存。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 007 Reverse Integer]]></title>
    <url>%2Fposts%2F8972%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Noted: Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1].For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Difficulty: Easy Code: 12345class Solution &#123; public int reverse(int x) &#123; &#125;&#125; 题意给定一个32位有符号的整数，找出其反转后的整数。反转后的数字如果溢出，则返回0。 Solution 1将数字转成字符串，然后保留符号反转，去除掉最前面多出的0。再将字符串转成Long，比较数字是否在Int的范围，如果不在返回0。 123456789101112131415161718192021222324class Solution &#123; public int reverse(int x) &#123; String s = String.valueOf(x); String result = null; if(s.charAt(0)=='-')&#123; result = new StringBuilder(s.substring(1)).reverse().toString(); if(result.charAt(0)=='0'&amp;&amp;result.length()&gt;1)&#123; result=result.substring(1); &#125; result = '-'+result; &#125;else&#123; result = new StringBuilder(s).reverse().toString(); if(result.charAt(0)=='0'&amp;&amp;result.length()&gt;1)&#123; result=result.substring(1); &#125; &#125; Long out = Long.valueOf(result); if(out&gt;Integer.MAX_VALUE||out&lt;Integer.MIN_VALUE)&#123; return 0; &#125;else&#123; return Integer.valueOf(result); &#125; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(n)，取决于数字的长度。 Solution 2不使用字符串，直接循环取出原始整数的尾数从后往前进行累加。中间注意判断当前结果数是否超出范围。 int的范围是在-2147483648到2147483647之间，边界条件下反转后的最后一位也只能是1或者2，即21474836471和21474836472。再次反转得输入数字1463847412和2463847412，后者超出界限，故输入数字只能是1463847412。所以当反转后数字除以10不需要比较214748364，因为满足条件的只有2147483641。 12345678910111213class Solution &#123; public int reverse(int x) &#123; int result = 0; while(x!=0)&#123; if(Math.abs(result)&gt;Integer.MAX_VALUE/10)&#123; return 0; &#125; result = result*10 + x%10; x=x/10; &#125; return result; &#125;&#125; 时间复杂度: O(log(n))，取决于数字的长度。 空间复杂度: O(1)，只使用一个数字保留结果。 Solution 3跟解法2类似，使用long来保存中间结果。 12345678910111213class Solution &#123; public int reverse(int x) &#123; Long result = 0L; while(x!=0)&#123; result = result*10 + x%10; x=x/10; &#125; if(result&gt;Integer.MAX_VALUE||result&lt;Integer.MIN_VALUE)&#123; return 0; &#125; return result.intValue(); &#125;&#125; 时间复杂度: O(log(n))，取决于数字的长度。 空间复杂度: O(1)，只使用一个数字保留结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建自定义页面的方法]]></title>
    <url>%2Fposts%2F56866%2F</url>
    <content type="text"><![CDATA[自定义页面的问题只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只默认渲染source目录下的文件，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用Hexo添加自定义的web页面呢？ 第一种解决方法第一种方法是使用Hexo提供的跳过渲染配置，针对某个文件或者目录进行排除。具体步骤，打开博客根目录_config.yml，找到其中skip_render项，这个项目用来配置/source/中需要跳过渲染的文件或目录。 假设source目录下的文件如以下目录树所示 123456789101112├─ demo| ├─ js-view-size| | ├─ 1.html| | └┈ 2.html| ├─ other| | ├─ 3.html| | ├─ 4.html| | └┈ 5.md| ├─ 6.html| └┈ 7.md├─ baidu.html└┈ google.html 排除单个文件排除baidu.html 12skip_render: - 'baidu.html' 排除多个文件排除baidu.html，google.html和3.html 1234skip_render: - 'baidu.html' - 'google.html' - 'demo/other/3.html' 或者 123skip_render: - '*.html' - 'demo/other/3.html' 排除source/demo/other目录中的所有文件 1skip_render: 'demo/other/**' 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外修改了配置后为了及时应用新配置，最好在生成之前执行一下hexo clean命令，清除掉旧的生成文件和缓存。 第二种解决方法第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 1layout: false 这样，这个文件就不会经过模板渲染，最终发布到/public/里的文件就是去掉标记后的文件的样子。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 006 ZigZag Conversion]]></title>
    <url>%2Fposts%2F16365%2F</url>
    <content type="text"><![CDATA[DescriptionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I Difficulty: Medium Code: 12345class Solution &#123; public String convert(String s, int numRows) &#123; &#125;&#125; 题意某字符串是基于给定的行数使用锯齿状格式书写，然后逐行读取成字符串。写一段代码完成该转换。 Solution 1可以使用nRows长的字符数组来保存格式转换后放置的所有字符。字符数组下标代表行数，该字符代表这一行的所有字符。遍历字符串并将当前字符放入对应的行，然后在遍历该数组，逐行读取所有字符。 123456789101112131415161718192021222324class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1)&#123; return s; &#125; String[] rows = new String[numRows]; Arrays.fill(rows,""); boolean goDown = false; int currRow =0; for(int i=0;i&lt;s.length();i++)&#123; rows[currRow]+=s.charAt(i); if(currRow==0||currRow==numRows-1)&#123; goDown=!goDown; &#125; currRow=goDown?currRow+1:currRow-1; &#125; String result = ""; for(String row:rows)&#123; result+=row; &#125; return result; &#125;&#125; 时间复杂度: O(n)，只从左到右遍历一次原始字符串。 空间复杂度: O(n)，使用来字符串数组来保存当前转换后到字符。 Solution 2按行直接读取转换后到字符。给定当前第几竖列k，有 第0行到字符在原始字符串的下标是k(2*numRows-2) 第numRows-1行在原始字符串的下标是k(2*numRows-2)+numRows-1 在这之间的第i行在原始字符串的下标是k(2numRows-2)+i和(k+1)(2numRows-2)-i 12345678910111213141516171819class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1)&#123; return s; &#125; StringBuilder result = new StringBuilder(); int cycleLen = 2*numRows -2; for(int i=0;i&lt;numRows;i++)&#123; for(int j=0;i+j&lt;s.length();j+=cycleLen)&#123; result.append(s.charAt(i+j)); if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;j+cycleLen-i&lt;s.length())&#123; result.append(s.charAt(j+cycleLen-i)); &#125; &#125; &#125; return result.toString(); &#125;&#125; 时间复杂度: O(n)，只遍历一次原始字符串。 空间复杂度: O(n)，使用StringBuilder来保存结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 005 Longest Palindromic Substring]]></title>
    <url>%2Fposts%2F26628%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; Difficulty: Medium Code: 12345class Solution &#123; public String longestPalindrome(String s) &#123; &#125;&#125; 题意给定一个字符串，找出最长的回文子串，假定字符串最大长度是1000。 Solution 1暴力遍历，外层作为子串的左侧，内层作为子串右侧，检查子串的左侧和右侧是否相等，若不等，则忽略，否则左侧和右侧往中间不断收缩继续检查。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int max=-1; String res=""; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; int left=i,right=j; boolean flag = true; while(left&lt;=right)&#123; if(s.charAt(left)!=s.charAt(right))&#123; flag=false; break; &#125; left++; right--; &#125; if(!flag)&#123; continue; &#125; if(j-i+1&gt;max)&#123; max=j-i+1; res=j==s.length()-1?s.substring(i):s.substring(i,j+1); &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n3)，双层遍历，内部循环检查是否回文。 空间复杂度: O(1)，没有使用额外空间。 Solution 2遍历字符串，以当前字符为中心去检查最大回文(奇数长度)，另外以当前字符及当前字符下一位检查最大回文长度(偶数长度)。 12345678910111213141516171819202122232425class Solution &#123; int start=0,maxLen=0; public String longestPalindrome(String s) &#123; if(s.length()&lt;2)&#123; return s; &#125; for(int i=0;i&lt;s.length()-1;i++)&#123; searchPalindrome(s,i,i); searchPalindrome(s,i,i+1); &#125; return s.substring(start,start+maxLen); &#125; public void searchPalindrome(String s, int left, int right)&#123; while(left&gt;=0&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; if(right-left-1&gt;maxLen)&#123; maxLen=right-left-1; start=left+1; &#125; &#125;&#125; 时间复杂度: O(n2)，一层遍历，内部循环检查是否回文。 空间复杂度: O(1)，没有使用额外空间。 Solution 3使用动态规划，维护一个二维数组dp，其中dp[i][j]表示字符串区间[i,j]是否为回文串。 当j=i时，因为只有一个字符肯定是回文串，结果为true。 当j=i+1时，说明是相邻字符，只需要比较s[j]==s[i]。 当j&gt;i+1时，则判断s[j]==s[i] &amp;&amp; dp[i+1][j-1]。 123456789101112131415161718192021class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()&lt;=1)&#123; return s; &#125; boolean[][] dp = new boolean[s.length()][s.length()]; int left=0, right=0, maxLen=0; for(int j=0;j&lt;s.length();j++)&#123; dp[j][j]=true; for(int i=0;i&lt;j;i++)&#123; dp[i][j]=s.charAt(i)==s.charAt(j)&amp;&amp;(j&lt;=i+1||dp[i+1][j-1]); if(dp[i][j]&amp;&amp;j-i+1&gt;maxLen)&#123; left=i; right=j; maxLen=j-i+1; &#125; &#125; &#125; return s.substring(left,right+1); &#125;&#125; 时间复杂度: O(n2)，两层遍历。 空间复杂度: O(n2)，使用二维数组存储结果。 Solution 4使用马拉车算法Manacher’s Algorithm，这个算法将时间复杂度提升到了O(n)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 004 Median of Two Sorted Arrays]]></title>
    <url>%2Fposts%2F40546%2F</url>
    <content type="text"><![CDATA[DescriptionThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Difficulty: Hard Code: 12345class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; &#125;&#125; 题意给定两个有序数组，长度分别是m和n。找出这两个数组到中位数，总体到时间复杂度要求O(log (m+n))，假定两个数组都不为空。 Solution 1中位数是把一组有序数分成两个相等长度的部分，一部分比另外一部分都要大。如果是偶数个，则取最中间两个数的平均数。 如果两个有序数组混合起来成为一个有序数组再去找中位数，肯定很简单，但是时间复杂度应该是O(m+n)，不符合要求。O(log (m+n))提示应该是用二分查找，但是两个数组又如何去做，着实很难。 首先将数组A在随机的位置i切成两部分： 12 left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 因为A有m个元素，所以有m+1种切法(i=0~m)。 12len(left_A)=i,len(right_A)=m−i.Note: when i = 0, left_A is empty, and when i = m, right_A is empty. 使用同样的方式，把数组B在随机位置j切成两部分。 12 left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 把left_A和left_B放到一起合并成left_part，把right_A和right_B放到一起合并成right_part。 123 left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们能保证 121. len(left_part)=len(right_part)2. max(left_part)≤min(right_part) 那么我们就成功将数组A和B中所有的元素分成了长度相同的两部分，并且一部分总是比另外一部分大。那么 1median= (max(left_part)+min(right_part))/2 为了达到上述两个条件，只需要保证 1231. i+j=m−i+n−j or i+j=m−i+n−j+1 如果n&gt;=m，只需要设：i=0~m,j=(m+n+1)/2-i;2. B[j−1] ≤ A[i] and A[i−1] ≤ B[j] ps.1 为了简化，假定A[i-1],B[j-1],A[i],B[j]都是有效的即使i=0,i=m,j=0,j=n。后面会介绍这些边界值如何处理。 ps.2 为什么要保证n&gt;=m，因为要保证j是非负数。 所以我们需要做的是 12在[0~m]中查找i，能够满足B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j], j=(m+n+1)/2-i 按照以下的步骤进行二分查找 初始化imin=0 and imax=m，然后在[imin,imax]进行查找 设置i=(imin+imax)/2 and j=(m+n+1)/2-i 已经达成len(left_part)=len(right_part)，只会碰到3种情况 B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j] 意味着我们找到了目标i，停止查找 B[j-1]&gt;A[i] 意味着A[i]太小，必须增大i以达到B[j-1]&lt;=A[i]。当i增大时，j减小，A[i]增大，B[j-1]减小。调整查找范围[i+1,imax]，imin=i+1，跳转到第2步。 A[i-1]&gt;B[j] 意味着A[i-1]太大，必须减小i以达到A[i-1]&lt;=B[j]。调整查找范围[imin,i-1]，imax=i-1，跳转到第2步 当目标i找到时，中位数是 12max(A[i-1],B[j-1])，当m+n是奇数(max(A[i-1],B[j-1)+min(A[i]+B[j])/2，当m+n是偶数 现在考虑边界值，i=0,i=m,j=0,j=m，此时A[i-1],B[j-1],A[i],B[j]可能不存在。 只需要保证max(left_part)&lt;=min(right_part)，但是当A[i-1],B[j-1],A[i],B[j]不存在时，不需要检查所有的那两个条件。 1(j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j])，当j=(m+n+1)/2-i 在循环搜索时，只会碰到以下三种情况 1234561. (j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j]) 意味着i已经找到，可以停止搜索2. j&gt;0 and i&lt;m and B[j-1]&gt;A[i] 意味着i太小，要增大i3. i&gt;0 and j&lt;n and A[j-1]&gt;B[j] 意味着i太大，要减小i 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m=nums1.length; int n=nums2.length; if(m&gt;n)&#123; return findMedianSortedArrays(nums2,nums1); &#125; int imin=0,imax=m,halfLen=(m+n+1)/2; while(imin&lt;=imax)&#123; int i = (imin+imax)/2; int j = halfLen-i; if(i&lt;imax&amp;&amp;nums2[j-1]&gt;nums1[i])&#123; imin=i+1; &#125;else if(i&gt;imin&amp;&amp;nums1[i-1]&gt;nums2[j])&#123; imax=i-1; &#125;else&#123; int maxLeft=0; if(i==0)&#123; maxLeft=nums2[j-1]; &#125;else if(j==0)&#123; maxLeft=nums1[i-1]; &#125;else&#123; maxLeft=Math.max(nums1[i-1],nums2[j-1]); &#125; if((m+n)%2==1)&#123; return maxLeft; &#125; int minRight=0; if(i==m)&#123; minRight=nums2[j]; &#125;else if(j==n)&#123; minRight=nums1[i]; &#125;else&#123; minRight=Math.min(nums1[i],nums2[j]); &#125; return (maxLeft+minRight)/2.0; &#125; &#125; return 0.0; &#125;&#125; 时间复杂度: O(log (m+n))，每次调整i都是将其范围减半。 空间复杂度: O(1)，只使用了固定几个变量保存状态。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-divide-and-conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 003 Longest Substring Without Repeating Characters]]></title>
    <url>%2Fposts%2F33885%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Difficulty: Medium Code: 12345class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; &#125;&#125; 题意给定一个字符串，找出不包含重复字符的最长子串的长度。 Solution 1使用两层遍历，外层是子串起始字符，内层则进行遍历时检查是否包含重复字符，若不包含则继续往后面移动，直到有重复字符或者到达末尾则结束。 将此子串到最大长度和已保存到最大长度进行对比，去其中大的进行更新。 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length() &lt;= 1)&#123; return s.length(); &#125; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for(int j=i;j&lt;s.length();j++)&#123; if(set.contains(s.charAt(j)))&#123; max = Math.max(max,j-i); break; &#125;else&#123; set.add(s.charAt(j)); max = Math.max(max,j-i+1); &#125; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n2)，两层循环遍历。 空间复杂度: O(n)，用来HashSet来存储每次已经遍历过的字符。 Solution 2使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashSet中，同时更新最大子串长度。 若检测到HashSet中已经存在该字符，则从HashSet删除窗口左侧元素并移动左侧位置，直到不包含重复字符为止。 123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()&lt;=1) return s.length(); Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int left=0, right=0, max = 0; while(right&lt;s.length())&#123; if(set.contains(s.charAt(right)))&#123; set.remove(s.charAt(left)); left++; &#125;else&#123; set.add(s.charAt(right)); max = Math.max(max,right-left+1); right++; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(2n)=O(n)，一层循环，主要是右侧窗口移动。 空间复杂度: O(n)，用来HashSet来存储已经遍历过的字符。 Solution 3同样使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashMap中，同时更新最大子串长度。 若检测到HashMap中已经存在该字符，则判断已存在字符到位置是否小于窗口左侧，若小于则忽略，否则直接移动窗口左侧到此位置到右侧。 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()&lt;=1) return s.length(); Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); int max = 0; for(int left=0,right=0;right&lt;s.length();right++)&#123; if(map.containsKey(s.charAt(right)) &amp;&amp; map.get(s.charAt(right))&gt;=left)&#123; left=map.get(s.charAt(right))+1; &#125; map.put(s.charAt(right),right); max = Math.max(max,right-left+1); &#125; return max; &#125;&#125; 时间复杂度: O(n)，一层循环遍历，HashMap操作耗时O(1)。 空间复杂度: O(n)，用来HashMap来存储已经遍历过的字符。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 002 Add Two Numbers]]></title>
    <url>%2Fposts%2F4084%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; &#125;&#125; 题意给定两个非空链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。假定两个数不包含任何前置0，除非这个数本身就是0。 这其实就是两个非负整数的加法运算，先从最后一位相加，有进位则保留在下一位中计算进去。 Solution 1就是建立一个新链表，然后把输入的两个链表从头往后撸，每两个相加，添加一个新节点到新链表后面。在新链表的头增加一个哨兵节点是非常重要的一个方法，这样就可以解放头结点的作用，方便进行处理。这样遍历时结果链表就可以从哨兵节点作为起始当前节点，返回结果时返回哨兵节点的下一个节点。 While循环条件是只要两个链表当前节点有一个不为空，当其中一个链表当前节点为空时，其值取0，后续节点取null。两个节点值相加，同时还要加上进位，以和对10求余作为新节点对值，添加到结果节点到下一位，并且更新进位。而后更新两个节点，若存在则指向其下一个节点。While退出后若进位不为0则新建节点添加到结果链表的末尾。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode curr = dummy; int carry = 0; while(l1 != null || l2 != null)&#123; int v1 = l1!=null ? l1.val : 0; int v2 = l2!=null ? l2.val : 0; int sum = v1 + v2 + carry; curr.next = new ListNode(sum%10); carry = sum/10; l1 = l1!=null ? l1.next : null; l2 = l2!=null ? l2.next : null; curr = curr.next; &#125; if(carry!=0)&#123; curr.next = new ListNode(carry); &#125; return dummy.next; &#125;&#125; 时间复杂度: O(max(m,n))，遍历到步长取决于两个链表的最大长度。 空间复杂度: O(max(m,n))，和的位数取决于最大数的位数。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 001 Two Sum]]></title>
    <url>%2Fposts%2F45823%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Difficulty: Easy Code: 12345class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; &#125;&#125; 题意给定一个整数数组，从中找出两个数的下标，使得它们的和等于一个特定的数字。假定每个输入肯定会有一个唯一解，同一个元素不可以使用两次。 Solution 1可以使用两层循环去遍历数组，外层从下标0开始，内层从外层下标+1开始。若外层和内层之和等于目标值则返回外层和内层的下标。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return new int[]&#123;&#125;; &#125;&#125; 时间复杂度: O(n2)，两层循环的遍历。 空间复杂度: O(1)，没有使用额外的空间储存。 Solution 2遍历一遍数组，将数字放入以数字为Key以数组下标为Value的HashMap中，在放入前检查HashMap中是否已经存在另外一个数满足两数之和等于目标值。若存在则返回HashMap中数字的下标和当前数字的下标。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;&#125;; &#125;&#125; 时间复杂度: O(n)，只对数组遍历来一次，HashMap的操作耗时是O(1)。 空间复杂度: O(n)，使用HashMap储存数组中的数字。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown扩展语法]]></title>
    <url>%2Fposts%2F38514%2F</url>
    <content type="text"><![CDATA[Markdown扩展语法的由来是基本语法不太够用，一些个人和组织添加来额外的元素来扩展基本语法。主要包括表格、代码块、语法高亮、URL自动链接、脚注。 可用性扩展语法并不是在所有的Markdown应用中都能使用，你需要去检查自己的应用使用的轻量级Markdown语言是否支持。 轻量级Markdown语言这里列举集中轻量级Markdown语言，很多流行的Markdown应用都使用其中一种。 CommonMark GitHub Flavored Markdown (GFM) Markdown Extra MultiMarkdown Markdown处理器有很多可用的Markdown处理器，都能够允许你增加扩展去使用扩展语法。 表格使用3个或者更多的连字符---去创建每一列的表头，使用竖线|去分割每一列。 123456789| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text || Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text | Syntax Description Header Title Paragraph Text 对齐可以在表头连字符的左边、右边、两边添加:来达到列文字居左、居右、居中对齐的效果。 1234| Syntax | Description | Test Text || :--- | :----: | ---: || Header | Title | Here&apos;s this || Paragraph | Text | And more | Syntax Description Test Text Header Title Here’s this Paragraph Text And more 表格中文字的格式化在表格中，可以加入链接、代码、加粗、斜体。 表格中竖线的转义可以使用竖线对应的HTML字符编码&amp;#124;来表示|。 带栅栏的代码块Markdown基本语法允许使用缩进4个空格或者1个tab来创建代码块。另外你也可以使用3个反引号```或者3个波浪号~~~在代码块的前后来创建带栅栏的代码块，不需要缩进任何行。 1234567```&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;``` 12345&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125; 语法高亮很多Markdown处理器支持在带栅栏的代码块中语法高亮，这将使你用任何语言写的代码增加色彩高亮。只需要在反引号后紧接着指定语言，即可实现。 1234567```json&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;``` 12345&#123; "firstName": "John", "lastName": "Smith", "age": 25&#125; 脚注脚注允许你增加笔记和参考在不截断文章内容的前提下。当你创建一个脚注，一个带链接上标数字就会出现在你加脚注的地方。点击链接就可以跳转到页面底部脚注的内容。 在[]中添加异或符号^和标识即可创建脚注引用。标识即可是数字也可是字符，但不能包含空格或者制表符。 1234567891011Here&apos;s a simple footnote,[^1] and here&apos;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&apos;s one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `&#123; my code &#125;` Add as many paragraphs as you like. 标题IDs可以给标题加自定义ID，这样能链接到标题并且可以通过CSS样式进行修改。在标题后把自定义ID用{}包裹 1### My Great Heading &#123;#custom-id&#125; 指向标题到链接创建一个标准到链接，链接地址使用#再跟上标题ID。 1[Heading IDs](#heading-ids) 轻量级Markdown语言 定义列表创建术语到定义列表，把术语放在第一行，下一行用:接一个空格开头，后面写定义。 123456First Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term. 删除线删除线能够在文字到中间加一条水平线，以表示文字是错误的。使用两个波浪线在文字的前后即可创建删除线。 1~~The world is flat.~~ We now know that the world is round. The world is flat. We now know that the world is round. 任务列表任务列表可以创建一系列带复选框的事项，使用连字符-加空格，再加[ ]，而后跟事项。选中复选框，使用[x]. 123- [x] Write the press release- [ ] Update the website- [ ] Contact the media Write the press release Update the website Contact the media URL自动生成链接很多Markdown处理器能自动将URL转成链接，不用加&lt;&gt;。 1http://www.example.com http://www.example.com 禁止URL自动生成链接如果你不想将URL自动转成链接，你可以将URL当成代码。 1`http://www.example.com` http://www.example.com]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2Fposts%2F48840%2F</url>
    <content type="text"><![CDATA[Markdown基本语法，几乎所有Markdown应用程序都支持John Gruber原始设计文档中概述的基本语法。 标题在标题前插入1到6个#，表示6个不同级别的标题 123456# Heading level 1## Heading level 2### Heading level 3#### Heading level 4##### Heading level 5###### Heading level 6 段落段落之间用空行隔开，不能使用空格或者缩进 123I really like using Markdown.I think I&apos;ll use it to format all of my documents from now on. 换行符在文字中间插入&lt;br&gt;可以进行换行，或者两个空格再回车。 1This is the first line. &lt;br&gt; And this is the second line. This is the first line. And this is the second line. 强调加粗在文字的前后用两个*或者_可以加粗字体 123I just love **bold text**.I just love __bold text__.Love**is**bold I just love bold text.I just love bold text.Loveisbold 斜体在文字的前后用一个*或者_可以变成斜体 123Italicized text is the *cat&apos;s meow*.Italicized text is the _cat&apos;s meow_.A*cat*meow Italicized text is the cat’s meow.Italicized text is the cat’s meow.Acatmeow 同时加粗和斜体在文字的前后用三个*或者_可以同时加粗和变成斜体 12This text is ***really important***.This text is ___really important___. This text is really important.This text is really important. 引用在一段文字中的开头加上 &gt; 来表示一段引用文字 1&gt; Dorothy followed her through many of the beautiful rooms in her castle. Dorothy followed her through many of the beautiful rooms in her castle. 引用多个段落在每个段落及空行开头加上 &gt; 来表示引用多段文字 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor. 引用嵌套引用可以嵌套，在段落的开头加上&gt;&gt; 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor. 引用中使用其他元素引用中可以包含其他Markdown的元素，但并不是所有但元素都可以用 123456&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt; *Everything* is going according to **plan**. The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. 列表列表可以分为有序列表和无序列表 有序列表有序列表在文字开头加上数字和点，数字并不要求按照顺序，但是起始应该是1 123456789101112131415161. First item2. Second item3. Third item4. Fourth item1. First item8. Second item3. Third item5. Fourth item1. First item2. Second item3. Third item 1. Indented item 2. Indented item4. Fourth item First item Second item Third item Indented item Indented item Fourth item 无序列表无序列表在每一行开头加上-、+、*，缩进去创建嵌套列表 123456789101112131415161718192021- First item- Second item- Third item- Fourth item* First item* Second item* Third item* Fourth item+ First item* Second item- Third item+ Fourth item- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 在列表中添加其他元素在列表中添加其他元素，要缩进4个空格或者1个tab 123456* This is the first list item.* Here&apos;s the second list item. I need to add another paragraph below the second list item.* And here&apos;s the third list item. This is the first list item. Here’s the second list item. I need to add another paragraph below the second list item. And here’s the third list item. 代码要表示一行代码，使用`来包裹 1At the command prompt, type `nano`. At the command prompt, type nano. 反引号转义在一行代码中如果代码本身也含有反引号，可以把最外层用两个反引号包裹 1``Use `code` in your Markdown file.`` Use `code` in your Markdown file. 代码块代码块的每行代码必须最少缩进4个空格或者1个tab 12345#### &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; 分割线使用三个及以上的*、-、_表示分割线 12345***---_________________ 链接用[]包裹链接文字，随后用()包裹URL 1My favorite search engine is [Duck Duck Go](https://duckduckgo.com). My favorite search engine is Duck Duck Go. 链接添加提示1My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best one&quot;). My favorite search engine is Duck Duck Go. 网页和邮箱为了快速将网页和邮箱转为链接，可以用&lt;&gt;包裹起来 12&lt;https://www.markdownguide.org&gt;&lt;fake@example.com&gt; https://www.markdownguide.org&#102;&#x61;&#107;&#101;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d; 格式化链接为了强调链接，可以在链接的前后加星号 12I love supporting **[EFF](https://eff.org)**.This is the *[Markdown Guide](https://www.markdownguide.org)*. I love supporting EFF.This is the Markdown Guide. 图片图片的插入方式是在最开始插入!，然后用[]包裹图片无法加载的描述，再把图片的地址用()包裹 1![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;) 带链接的图片给图片加链接的方式是，把图片的Markdown用[]包裹，再在后面把链接地址用()包裹 1[![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;)](https://www.google.com) 转义字符如果有些符号是Markdown使用的，但是又想显示，可以在字符前加\ 1\* Without the backslash, this would be a bullet in an unordered list. 转义字符列表 Character Name \ backslash ` tick mark * asterisk _ underscore {} curly braces [] brackets () parentheses # pound sign + plus sign - minus sign (hyphen) . dot ! exclamation mark]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
