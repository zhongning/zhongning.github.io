<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 010 Regular Expression Matching]]></title>
    <url>%2Fposts%2F47345%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false Difficulty: Hard Code: 12345class Solution &#123; public boolean isMatch(String s, String p) &#123; &#125;&#125; 题意Solution 112 时间复杂度: O(max(m,n))，遍历到步长取决于两个链表的最大长度。 空间复杂度: O(max(m,n))，和的位数取决于最大数的位数。 Solution 212 时间复杂度: O(max(m,n))，遍历到步长取决于两个链表的最大长度。 空间复杂度: O(max(m,n))，和的位数取决于最大数的位数。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 009 Palindrome Number]]></title>
    <url>%2Fposts%2F5013%2F</url>
    <content type="text"><![CDATA[DescriptionDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Difficulty: Easy Code: 12345class Solution &#123; public boolean isPalindrome(int x) &#123; &#125;&#125; 题意判断一个int数是否是回文格式，即从前读取和从后开始读取都是一样的。 Solution 1首先负数排除，不是回文数字。而0是回文数字。针对正数，可以从后往前读取并累加来找出其反向数字，并和原始数字进行比较。 若反转时溢出，那么最终的结果肯定不会相等，可以不用判断是否溢出。 12345678910111213141516class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125;else if(x==0)&#123; return true; &#125; int reverseNum = 0; int curr = x; while(curr!=0)&#123; reverseNum = reverseNum*10 + curr%10; curr = curr/10; &#125; return reverseNum==x; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(1)，只使用int来保存结果。 Solution 2首先负数排除，不是回文数字。而0是回文数字。并且如果正数的末尾是0也不是回文。 其他正数只需要验证前后半段是否对称，和解法1相比快了一倍。具体做法是：每次对10取余取出数的末尾，把reverseNum乘以10并加上余数；同时把x除以10。这样当reverseNum大于等于x时停止循环，x即为前半段，reverseNum为后半段。由于回文数的位数可奇可偶，偶数时两者相等，奇数时中间数字在reverseNum最低位需除以10后再比较。 1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125;else if(x==0)&#123; return true; &#125;else if(x%10==0)&#123; return false; &#125; int reverseNum = 0; while(x&gt;reverseNum)&#123; reverseNum = reverseNum*10 + x%10; x = x/10; &#125; return x==reverseNum || x==reverseNum/10; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(1)，只使用int来保存结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 008 String to Integer (atoi)]]></title>
    <url>%2Fposts%2F64402%2F</url>
    <content type="text"><![CDATA[DescriptionImplement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. Difficulty: Medium Code: 12345class Solution &#123; public int myAtoi(String str) &#123; &#125;&#125; 题意实现atoi函数将字符串转换为整数。 函数首先尽可能多的丢弃空白字符，直到发现第一个非空字符位为止。 接着从这个字符开始，读入一个可选的正负号，然后尽可能多的读入数字，最后将它们解析成数值。 字符串中在合法数字后可以包含额外的非法字符，对于这些字符只需丢弃即可。 如果字符串的非空字符不是一个有效的整数，或者，当字符串为空或者只包含空白字符时，不需要执行转换。 如果不能够执行有效的转换则返回0。如果得到的数值超出了整数范围，返回INT_MAX (2147483647) 或者 INT_MIN (-2147483648)。 Solution 1使用StringBuilder保存取出的数字，布尔类型保存是否是正数。开始遍历字符串，有以下情况： 只有最前面的空格可以忽略 第一次遍历到’-‘或则’+’则更新是否是正数 若为数字 如果当前已保存的数字为空，且当前数字为0后一位也为0，则忽略 其他则保存进StringBuilder 其他情况则条件不符，退出遍历 而后判断长度是否超出Integer的限制，并转成Long判断其具体是否超出Integer区间范围。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int myAtoi(String str) &#123; nt len=str.length(); StringBuilder sb = new StringBuilder(); Boolean positive = null; for(int i=0;i&lt;len;i++)&#123; if(sb.length()==0&amp;&amp;positive==null&amp;&amp;str.charAt(i)==' ')&#123; continue; &#125; if(sb.length()==0&amp;&amp;positive==null&amp;&amp;(str.charAt(i)=='-'||str.charAt(i)=='+'))&#123; positive=str.charAt(i)=='-'?false:true; continue; &#125; if(str.charAt(i)&gt;='0'&amp;&amp;str.charAt(i)&lt;='9')&#123; if(sb.length()==0&amp;&amp;str.charAt(i)=='0'&amp;&amp;i&lt;len-1&amp;&amp;str.charAt(i+1)=='0')&#123; continue; &#125;else&#123; sb.append(str.charAt(i)); continue; &#125; &#125; break; &#125; int maxLen = String.valueOf(Integer.MAX_VALUE).length(); if(sb.length()==0)&#123; return 0; &#125; positive=positive==null?true:positive; if(sb.length()&gt;maxLen)&#123; return positive?Integer.MAX_VALUE:Integer.MIN_VALUE; &#125; Long longValue = positive?Long.valueOf(sb.toString()):0L-Long.valueOf(sb.toString()); if(longValue&gt;Integer.MAX_VALUE)&#123; return Integer.MAX_VALUE; &#125;else if(longValue&lt;Integer.MIN_VALUE)&#123; return Integer.MIN_VALUE; &#125;else&#123; return longValue.intValue(); &#125; &#125;&#125; 时间复杂度: O(n)，遍历一次字符串。 空间复杂度: O(n)，使用StringBuilder，取决于字符串长度。 Solution 2使用一个int保存结果，另外一个int保存1或者-1代表正负数。截去字符串前后空格后，开始遍历字符串，有以下情况： 首字符为’-‘或’+’则更新正负数 若为数字 判断当前已保存的结果如果乘以10倍的过程中超出int范围则返回 把当前已保存的结果乘以10并加上当前字符的数值 再次判断是否超出int范围 其他情况则条件不符，退出遍历 其中判断是否超出int范围，可以用保存的数和加上当前数值后的符号是否发生变化来判断，因为超出区间后其正负发生反转。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int myAtoi(String str) &#123; if(str==null||str.length()==0) return 0; str=str.trim(); int num=0; int sign=1; for(int i=0;i&lt;str.length();i++)&#123; char curr = str.charAt(i); if(i==0&amp;&amp;curr=='+')&#123; sign=1; &#125;else if(i==0&amp;&amp;curr=='-')&#123; sign=-1; &#125;else if(curr&gt;='0'&amp;&amp;curr&lt;='9')&#123; int prev = 0; for(int j=0;j&lt;10;j++)&#123; prev+=num; if(num&gt;0&amp;&amp;prev&lt;0)&#123; return Integer.MAX_VALUE; &#125;else if(num&lt;0&amp;&amp;prev&gt;0)&#123; return Integer.MIN_VALUE; &#125; &#125; prev = 10*num + sign*(curr-'0'); if(num&gt;0&amp;&amp;prev&lt;0)&#123; return Integer.MAX_VALUE; &#125;else if(num&lt;0&amp;&amp;prev&gt;0)&#123; return Integer.MIN_VALUE; &#125; num=prev; &#125;else&#123; break; &#125; &#125; return num; &#125;&#125; 时间复杂度: O(n)，遍历一次字符串。 空间复杂度: O(1)，使用int数字保存。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 007 Reverse Integer]]></title>
    <url>%2Fposts%2F8972%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Noted: Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1].For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Difficulty: Easy Code: 12345class Solution &#123; public int reverse(int x) &#123; &#125;&#125; 题意给定一个32位有符号的整数，找出其反转后的整数。反转后的数字如果溢出，则返回0。 Solution 1将数字转成字符串，然后保留符号反转，去除掉最前面多出的0。再将字符串转成Long，比较数字是否在Int的范围，如果不在返回0。 123456789101112131415161718192021222324class Solution &#123; public int reverse(int x) &#123; String s = String.valueOf(x); String result = null; if(s.charAt(0)=='-')&#123; result = new StringBuilder(s.substring(1)).reverse().toString(); if(result.charAt(0)=='0'&amp;&amp;result.length()&gt;1)&#123; result=result.substring(1); &#125; result = '-'+result; &#125;else&#123; result = new StringBuilder(s).reverse().toString(); if(result.charAt(0)=='0'&amp;&amp;result.length()&gt;1)&#123; result=result.substring(1); &#125; &#125; Long out = Long.valueOf(result); if(out&gt;Integer.MAX_VALUE||out&lt;Integer.MIN_VALUE)&#123; return 0; &#125;else&#123; return Integer.valueOf(result); &#125; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(n)，取决于数字的长度。 Solution 2不使用字符串，直接循环取出原始整数的尾数从后往前进行累加。中间注意判断当前结果数是否超出范围。 int的范围是在-2147483648到2147483647之间，边界条件下反转后的最后一位也只能是1或者2，即21474836471和21474836472。再次反转得输入数字1463847412和2463847412，后者超出界限，故输入数字只能是1463847412。所以当反转后数字除以10不需要比较214748364，因为满足条件的只有2147483641。 12345678910111213class Solution &#123; public int reverse(int x) &#123; int result = 0; while(x!=0)&#123; if(Math.abs(result)&gt;Integer.MAX_VALUE/10)&#123; return 0; &#125; result = result*10 + x%10; x=x/10; &#125; return result; &#125;&#125; 时间复杂度: O(log(n))，取决于数字的长度。 空间复杂度: O(1)，只使用一个数字保留结果。 Solution 3跟解法2类似，使用long来保存中间结果。 12345678910111213class Solution &#123; public int reverse(int x) &#123; Long result = 0L; while(x!=0)&#123; result = result*10 + x%10; x=x/10; &#125; if(result&gt;Integer.MAX_VALUE||result&lt;Integer.MIN_VALUE)&#123; return 0; &#125; return result.intValue(); &#125;&#125; 时间复杂度: O(log(n))，取决于数字的长度。 空间复杂度: O(1)，只使用一个数字保留结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建自定义页面的方法]]></title>
    <url>%2Fposts%2F56866%2F</url>
    <content type="text"><![CDATA[自定义页面的问题只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只默认渲染source目录下的文件，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用Hexo添加自定义的web页面呢？ 第一种解决方法第一种方法是使用Hexo提供的跳过渲染配置，针对某个文件或者目录进行排除。具体步骤，打开博客根目录_config.yml，找到其中skip_render项，这个项目用来配置/source/中需要跳过渲染的文件或目录。 假设source目录下的文件如以下目录树所示 123456789101112├─ demo| ├─ js-view-size| | ├─ 1.html| | └┈ 2.html| ├─ other| | ├─ 3.html| | ├─ 4.html| | └┈ 5.md| ├─ 6.html| └┈ 7.md├─ baidu.html└┈ google.html 排除单个文件排除baidu.html 12skip_render: - 'baidu.html' 排除多个文件排除baidu.html，google.html和3.html 1234skip_render: - 'baidu.html' - 'google.html' - 'demo/other/3.html' 或者 123skip_render: - '*.html' - 'demo/other/3.html' 排除source/demo/other目录中的所有文件 1skip_render: 'demo/other/**' 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外修改了配置后为了及时应用新配置，最好在生成之前执行一下hexo clean命令，清除掉旧的生成文件和缓存。 第二种解决方法第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 1layout: false 这样，这个文件就不会经过模板渲染，最终发布到/public/里的文件就是去掉标记后的文件的样子。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 006 ZigZag Conversion]]></title>
    <url>%2Fposts%2F16365%2F</url>
    <content type="text"><![CDATA[DescriptionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I Difficulty: Medium Code: 12345class Solution &#123; public String convert(String s, int numRows) &#123; &#125;&#125; 题意某字符串是基于给定的行数使用锯齿状格式书写，然后逐行读取成字符串。写一段代码完成该转换。 Solution 1可以使用nRows长的字符数组来保存格式转换后放置的所有字符。字符数组下标代表行数，该字符代表这一行的所有字符。遍历字符串并将当前字符放入对应的行，然后在遍历该数组，逐行读取所有字符。 123456789101112131415161718192021222324class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1)&#123; return s; &#125; String[] rows = new String[numRows]; Arrays.fill(rows,""); boolean goDown = false; int currRow =0; for(int i=0;i&lt;s.length();i++)&#123; rows[currRow]+=s.charAt(i); if(currRow==0||currRow==numRows-1)&#123; goDown=!goDown; &#125; currRow=goDown?currRow+1:currRow-1; &#125; String result = ""; for(String row:rows)&#123; result+=row; &#125; return result; &#125;&#125; 时间复杂度: O(n)，只从左到右遍历一次原始字符串。 空间复杂度: O(n)，使用来字符串数组来保存当前转换后到字符。 Solution 2按行直接读取转换后到字符。给定当前第几竖列k，有 第0行到字符在原始字符串的下标是k(2*numRows-2) 第numRows-1行在原始字符串的下标是k(2*numRows-2)+numRows-1 在这之间的第i行在原始字符串的下标是k(2numRows-2)+i和(k+1)(2numRows-2)-i 12345678910111213141516171819class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1)&#123; return s; &#125; StringBuilder result = new StringBuilder(); int cycleLen = 2*numRows -2; for(int i=0;i&lt;numRows;i++)&#123; for(int j=0;i+j&lt;s.length();j+=cycleLen)&#123; result.append(s.charAt(i+j)); if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;j+cycleLen-i&lt;s.length())&#123; result.append(s.charAt(j+cycleLen-i)); &#125; &#125; &#125; return result.toString(); &#125;&#125; 时间复杂度: O(n)，只遍历一次原始字符串。 空间复杂度: O(n)，使用StringBuilder来保存结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 005 Longest Palindromic Substring]]></title>
    <url>%2Fposts%2F26628%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; Difficulty: Medium Code: 12345class Solution &#123; public String longestPalindrome(String s) &#123; &#125;&#125; 题意给定一个字符串，找出最长的回文子串，假定字符串最大长度是1000。 Solution 1暴力遍历，外层作为子串的左侧，内层作为子串右侧，检查子串的左侧和右侧是否相等，若不等，则忽略，否则左侧和右侧往中间不断收缩继续检查。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int max=-1; String res=""; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; int left=i,right=j; boolean flag = true; while(left&lt;=right)&#123; if(s.charAt(left)!=s.charAt(right))&#123; flag=false; break; &#125; left++; right--; &#125; if(!flag)&#123; continue; &#125; if(j-i+1&gt;max)&#123; max=j-i+1; res=j==s.length()-1?s.substring(i):s.substring(i,j+1); &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n3)，双层遍历，内部循环检查是否回文。 空间复杂度: O(1)，没有使用额外空间。 Solution 2遍历字符串，以当前字符为中心去检查最大回文(奇数长度)，另外以当前字符及当前字符下一位检查最大回文长度(偶数长度)。 12345678910111213141516171819202122232425class Solution &#123; int start=0,maxLen=0; public String longestPalindrome(String s) &#123; if(s.length()&lt;2)&#123; return s; &#125; for(int i=0;i&lt;s.length()-1;i++)&#123; searchPalindrome(s,i,i); searchPalindrome(s,i,i+1); &#125; return s.substring(start,start+maxLen); &#125; public void searchPalindrome(String s, int left, int right)&#123; while(left&gt;=0&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; if(right-left-1&gt;maxLen)&#123; maxLen=right-left-1; start=left+1; &#125; &#125;&#125; 时间复杂度: O(n2)，一层遍历，内部循环检查是否回文。 空间复杂度: O(1)，没有使用额外空间。 Solution 3使用动态规划，维护一个二维数组dp，其中dp[i][j]表示字符串区间[i,j]是否为回文串。 当j=i时，因为只有一个字符肯定是回文串，结果为true。 当j=i+1时，说明是相邻字符，只需要比较s[j]==s[i]。 当j&gt;i+1时，则判断s[j]==s[i] &amp;&amp; dp[i+1][j-1]。 123456789101112131415161718192021class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()&lt;=1)&#123; return s; &#125; boolean[][] dp = new boolean[s.length()][s.length()]; int left=0, right=0, maxLen=0; for(int j=0;j&lt;s.length();j++)&#123; dp[j][j]=true; for(int i=0;i&lt;j;i++)&#123; dp[i][j]=s.charAt(i)==s.charAt(j)&amp;&amp;(j&lt;=i+1||dp[i+1][j-1]); if(dp[i][j]&amp;&amp;j-i+1&gt;maxLen)&#123; left=i; right=j; maxLen=j-i+1; &#125; &#125; &#125; return s.substring(left,right+1); &#125;&#125; 时间复杂度: O(n2)，两层遍历。 空间复杂度: O(n2)，使用二维数组存储结果。 Solution 4使用马拉车算法Manacher’s Algorithm，这个算法将时间复杂度提升到了O(n)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 004 Median of Two Sorted Arrays]]></title>
    <url>%2Fposts%2F40546%2F</url>
    <content type="text"><![CDATA[DescriptionThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Difficulty: Hard Code: 12345class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; &#125;&#125; 题意给定两个有序数组，长度分别是m和n。找出这两个数组到中位数，总体到时间复杂度要求O(log (m+n))，假定两个数组都不为空。 Solution 1中位数是把一组有序数分成两个相等长度的部分，一部分比另外一部分都要大。如果是偶数个，则取最中间两个数的平均数。 如果两个有序数组混合起来成为一个有序数组再去找中位数，肯定很简单，但是时间复杂度应该是O(m+n)，不符合要求。O(log (m+n))提示应该是用二分查找，但是两个数组又如何去做，着实很难。 首先将数组A在随机的位置i切成两部分： 12 left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 因为A有m个元素，所以有m+1种切法(i=0~m)。 12len(left_A)=i,len(right_A)=m−i.Note: when i = 0, left_A is empty, and when i = m, right_A is empty. 使用同样的方式，把数组B在随机位置j切成两部分。 12 left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 把left_A和left_B放到一起合并成left_part，把right_A和right_B放到一起合并成right_part。 123 left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们能保证 121. len(left_part)=len(right_part)2. max(left_part)≤min(right_part) 那么我们就成功将数组A和B中所有的元素分成了长度相同的两部分，并且一部分总是比另外一部分大。那么 1median= (max(left_part)+min(right_part))/2 为了达到上述两个条件，只需要保证 1231. i+j=m−i+n−j or i+j=m−i+n−j+1 如果n&gt;=m，只需要设：i=0~m,j=(m+n+1)/2-i;2. B[j−1] ≤ A[i] and A[i−1] ≤ B[j] ps.1 为了简化，假定A[i-1],B[j-1],A[i],B[j]都是有效的即使i=0,i=m,j=0,j=n。后面会介绍这些边界值如何处理。 ps.2 为什么要保证n&gt;=m，因为要保证j是非负数。 所以我们需要做的是 12在[0~m]中查找i，能够满足B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j], j=(m+n+1)/2-i 按照以下的步骤进行二分查找 初始化imin=0 and imax=m，然后在[imin,imax]进行查找 设置i=(imin+imax)/2 and j=(m+n+1)/2-i 已经达成len(left_part)=len(right_part)，只会碰到3种情况 B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j] 意味着我们找到了目标i，停止查找 B[j-1]&gt;A[i] 意味着A[i]太小，必须增大i以达到B[j-1]&lt;=A[i]。当i增大时，j减小，A[i]增大，B[j-1]减小。调整查找范围[i+1,imax]，imin=i+1，跳转到第2步。 A[i-1]&gt;B[j] 意味着A[i-1]太大，必须减小i以达到A[i-1]&lt;=B[j]。调整查找范围[imin,i-1]，imax=i-1，跳转到第2步 当目标i找到时，中位数是 12max(A[i-1],B[j-1])，当m+n是奇数(max(A[i-1],B[j-1)+min(A[i]+B[j])/2，当m+n是偶数 现在考虑边界值，i=0,i=m,j=0,j=m，此时A[i-1],B[j-1],A[i],B[j]可能不存在。 只需要保证max(left_part)&lt;=min(right_part)，但是当A[i-1],B[j-1],A[i],B[j]不存在时，不需要检查所有的那两个条件。 1(j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j])，当j=(m+n+1)/2-i 在循环搜索时，只会碰到以下三种情况 1234561. (j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j]) 意味着i已经找到，可以停止搜索2. j&gt;0 and i&lt;m and B[j-1]&gt;A[i] 意味着i太小，要增大i3. i&gt;0 and j&lt;n and A[j-1]&gt;B[j] 意味着i太大，要减小i 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m=nums1.length; int n=nums2.length; if(m&gt;n)&#123; return findMedianSortedArrays(nums2,nums1); &#125; int imin=0,imax=m,halfLen=(m+n+1)/2; while(imin&lt;=imax)&#123; int i = (imin+imax)/2; int j = halfLen-i; if(i&lt;imax&amp;&amp;nums2[j-1]&gt;nums1[i])&#123; imin=i+1; &#125;else if(i&gt;imin&amp;&amp;nums1[i-1]&gt;nums2[j])&#123; imax=i-1; &#125;else&#123; int maxLeft=0; if(i==0)&#123; maxLeft=nums2[j-1]; &#125;else if(j==0)&#123; maxLeft=nums1[i-1]; &#125;else&#123; maxLeft=Math.max(nums1[i-1],nums2[j-1]); &#125; if((m+n)%2==1)&#123; return maxLeft; &#125; int minRight=0; if(i==m)&#123; minRight=nums2[j]; &#125;else if(j==n)&#123; minRight=nums1[i]; &#125;else&#123; minRight=Math.min(nums1[i],nums2[j]); &#125; return (maxLeft+minRight)/2.0; &#125; &#125; return 0.0; &#125;&#125; 时间复杂度: O(log (m+n))，每次调整i都是将其范围减半。 空间复杂度: O(1)，只使用了固定几个变量保存状态。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-divide-and-conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 003 Longest Substring Without Repeating Characters]]></title>
    <url>%2Fposts%2F33885%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Difficulty: Medium Code: 12345class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; &#125;&#125; 题意给定一个字符串，找出不包含重复字符的最长子串的长度。 Solution 1使用两层遍历，外层是子串起始字符，内层则进行遍历时检查是否包含重复字符，若不包含则继续往后面移动，直到有重复字符或者到达末尾则结束。 将此子串到最大长度和已保存到最大长度进行对比，去其中大的进行更新。 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length() &lt;= 1)&#123; return s.length(); &#125; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for(int j=i;j&lt;s.length();j++)&#123; if(set.contains(s.charAt(j)))&#123; max = Math.max(max,j-i); break; &#125;else&#123; set.add(s.charAt(j)); max = Math.max(max,j-i+1); &#125; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n2)，两层循环遍历。 空间复杂度: O(n)，用来HashSet来存储每次已经遍历过的字符。 Solution 2使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashSet中，同时更新最大子串长度。 若检测到HashSet中已经存在该字符，则从HashSet删除窗口左侧元素并移动左侧位置，直到不包含重复字符为止。 123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()&lt;=1) return s.length(); Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int left=0, right=0, max = 0; while(right&lt;s.length())&#123; if(set.contains(s.charAt(right)))&#123; set.remove(s.charAt(left)); left++; &#125;else&#123; set.add(s.charAt(right)); max = Math.max(max,right-left+1); right++; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(2n)=O(n)，一层循环，主要是右侧窗口移动。 空间复杂度: O(n)，用来HashSet来存储已经遍历过的字符。 Solution 3同样使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashMap中，同时更新最大子串长度。 若检测到HashMap中已经存在该字符，则判断已存在字符到位置是否小于窗口左侧，若小于则忽略，否则直接移动窗口左侧到此位置到右侧。 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()&lt;=1) return s.length(); Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); int max = 0; for(int left=0,right=0;right&lt;s.length();right++)&#123; if(map.containsKey(s.charAt(right)) &amp;&amp; map.get(s.charAt(right))&gt;=left)&#123; left=map.get(s.charAt(right))+1; &#125; map.put(s.charAt(right),right); max = Math.max(max,right-left+1); &#125; return max; &#125;&#125; 时间复杂度: O(n)，一层循环遍历，HashMap操作耗时O(1)。 空间复杂度: O(n)，用来HashMap来存储已经遍历过的字符。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 002 Add Two Numbers]]></title>
    <url>%2Fposts%2F4084%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; &#125;&#125; 题意给定两个非空链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。假定两个数不包含任何前置0，除非这个数本身就是0。 这其实就是两个非负整数的加法运算，先从最后一位相加，有进位则保留在下一位中计算进去。 Solution 1就是建立一个新链表，然后把输入的两个链表从头往后撸，每两个相加，添加一个新节点到新链表后面。在新链表的头增加一个哨兵节点是非常重要的一个方法，这样就可以解放头结点的作用，方便进行处理。这样遍历时结果链表就可以从哨兵节点作为起始当前节点，返回结果时返回哨兵节点的下一个节点。 While循环条件是只要两个链表当前节点有一个不为空，当其中一个链表当前节点为空时，其值取0，后续节点取null。两个节点值相加，同时还要加上进位，以和对10求余作为新节点对值，添加到结果节点到下一位，并且更新进位。而后更新两个节点，若存在则指向其下一个节点。While退出后若进位不为0则新建节点添加到结果链表的末尾。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode curr = dummy; int carry = 0; while(l1 != null || l2 != null)&#123; int v1 = l1!=null ? l1.val : 0; int v2 = l2!=null ? l2.val : 0; int sum = v1 + v2 + carry; curr.next = new ListNode(sum%10); carry = sum/10; l1 = l1!=null ? l1.next : null; l2 = l2!=null ? l2.next : null; curr = curr.next; &#125; if(carry!=0)&#123; curr.next = new ListNode(carry); &#125; return dummy.next; &#125;&#125; 时间复杂度: O(max(m,n))，遍历到步长取决于两个链表的最大长度。 空间复杂度: O(max(m,n))，和的位数取决于最大数的位数。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 001 Two Sum]]></title>
    <url>%2Fposts%2F45823%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Difficulty: Easy Code: 12345class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; &#125;&#125; 题意给定一个整数数组，从中找出两个数的下标，使得它们的和等于一个特定的数字。假定每个输入肯定会有一个唯一解，同一个元素不可以使用两次。 Solution 1可以使用两层循环去遍历数组，外层从下标0开始，内层从外层下标+1开始。若外层和内层之和等于目标值则返回外层和内层的下标。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return new int[]&#123;&#125;; &#125;&#125; 时间复杂度: O(n2)，两层循环的遍历。 空间复杂度: O(1)，没有使用额外的空间储存。 Solution 2遍历一遍数组，将数字放入以数字为Key以数组下标为Value的HashMap中，在放入前检查HashMap中是否已经存在另外一个数满足两数之和等于目标值。若存在则返回HashMap中数字的下标和当前数字的下标。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;&#125;; &#125;&#125; 时间复杂度: O(n)，只对数组遍历来一次，HashMap的操作耗时是O(1)。 空间复杂度: O(n)，使用HashMap储存数组中的数字。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown扩展语法]]></title>
    <url>%2Fposts%2F38514%2F</url>
    <content type="text"><![CDATA[Markdown扩展语法的由来是基本语法不太够用，一些个人和组织添加来额外的元素来扩展基本语法。主要包括表格、代码块、语法高亮、URL自动链接、脚注。 可用性扩展语法并不是在所有的Markdown应用中都能使用，你需要去检查自己的应用使用的轻量级Markdown语言是否支持。 轻量级Markdown语言这里列举集中轻量级Markdown语言，很多流行的Markdown应用都使用其中一种。 CommonMark GitHub Flavored Markdown (GFM) Markdown Extra MultiMarkdown Markdown处理器有很多可用的Markdown处理器，都能够允许你增加扩展去使用扩展语法。 表格使用3个或者更多的连字符---去创建每一列的表头，使用竖线|去分割每一列。 123456789| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text || Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text | Syntax Description Header Title Paragraph Text 对齐可以在表头连字符的左边、右边、两边添加:来达到列文字居左、居右、居中对齐的效果。 1234| Syntax | Description | Test Text || :--- | :----: | ---: || Header | Title | Here&apos;s this || Paragraph | Text | And more | Syntax Description Test Text Header Title Here’s this Paragraph Text And more 表格中文字的格式化在表格中，可以加入链接、代码、加粗、斜体。 表格中竖线的转义可以使用竖线对应的HTML字符编码&amp;#124;来表示|。 带栅栏的代码块Markdown基本语法允许使用缩进4个空格或者1个tab来创建代码块。另外你也可以使用3个反引号```或者3个波浪号~~~在代码块的前后来创建带栅栏的代码块，不需要缩进任何行。 1234567```&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;``` 12345&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125; 语法高亮很多Markdown处理器支持在带栅栏的代码块中语法高亮，这将使你用任何语言写的代码增加色彩高亮。只需要在反引号后紧接着指定语言，即可实现。 1234567```json&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;``` 12345&#123; "firstName": "John", "lastName": "Smith", "age": 25&#125; 脚注脚注允许你增加笔记和参考在不截断文章内容的前提下。当你创建一个脚注，一个带链接上标数字就会出现在你加脚注的地方。点击链接就可以跳转到页面底部脚注的内容。 在[]中添加异或符号^和标识即可创建脚注引用。标识即可是数字也可是字符，但不能包含空格或者制表符。 1234567891011Here&apos;s a simple footnote,[^1] and here&apos;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&apos;s one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `&#123; my code &#125;` Add as many paragraphs as you like. 标题IDs可以给标题加自定义ID，这样能链接到标题并且可以通过CSS样式进行修改。在标题后把自定义ID用{}包裹 1### My Great Heading &#123;#custom-id&#125; 指向标题到链接创建一个标准到链接，链接地址使用#再跟上标题ID。 1[Heading IDs](#heading-ids) 轻量级Markdown语言 定义列表创建术语到定义列表，把术语放在第一行，下一行用:接一个空格开头，后面写定义。 123456First Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term. 删除线删除线能够在文字到中间加一条水平线，以表示文字是错误的。使用两个波浪线在文字的前后即可创建删除线。 1~~The world is flat.~~ We now know that the world is round. The world is flat. We now know that the world is round. 任务列表任务列表可以创建一系列带复选框的事项，使用连字符-加空格，再加[ ]，而后跟事项。选中复选框，使用[x]. 123- [x] Write the press release- [ ] Update the website- [ ] Contact the media Write the press release Update the website Contact the media URL自动生成链接很多Markdown处理器能自动将URL转成链接，不用加&lt;&gt;。 1http://www.example.com http://www.example.com 禁止URL自动生成链接如果你不想将URL自动转成链接，你可以将URL当成代码。 1`http://www.example.com` http://www.example.com]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2Fposts%2F48840%2F</url>
    <content type="text"><![CDATA[Markdown基本语法，几乎所有Markdown应用程序都支持John Gruber原始设计文档中概述的基本语法。 标题在标题前插入1到6个#，表示6个不同级别的标题 123456# Heading level 1## Heading level 2### Heading level 3#### Heading level 4##### Heading level 5###### Heading level 6 段落段落之间用空行隔开，不能使用空格或者缩进 123I really like using Markdown.I think I&apos;ll use it to format all of my documents from now on. 换行符在文字中间插入&lt;br&gt;可以进行换行，或者两个空格再回车。 1This is the first line. &lt;br&gt; And this is the second line. This is the first line. And this is the second line. 强调加粗在文字的前后用两个*或者_可以加粗字体 123I just love **bold text**.I just love __bold text__.Love**is**bold I just love bold text.I just love bold text.Loveisbold 斜体在文字的前后用一个*或者_可以变成斜体 123Italicized text is the *cat&apos;s meow*.Italicized text is the _cat&apos;s meow_.A*cat*meow Italicized text is the cat’s meow.Italicized text is the cat’s meow.Acatmeow 同时加粗和斜体在文字的前后用三个*或者_可以同时加粗和变成斜体 12This text is ***really important***.This text is ___really important___. This text is really important.This text is really important. 引用在一段文字中的开头加上 &gt; 来表示一段引用文字 1&gt; Dorothy followed her through many of the beautiful rooms in her castle. Dorothy followed her through many of the beautiful rooms in her castle. 引用多个段落在每个段落及空行开头加上 &gt; 来表示引用多段文字 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor. 引用嵌套引用可以嵌套，在段落的开头加上&gt;&gt; 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor. 引用中使用其他元素引用中可以包含其他Markdown的元素，但并不是所有但元素都可以用 123456&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt; *Everything* is going according to **plan**. The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. 列表列表可以分为有序列表和无序列表 有序列表有序列表在文字开头加上数字和点，数字并不要求按照顺序，但是起始应该是1 123456789101112131415161. First item2. Second item3. Third item4. Fourth item1. First item8. Second item3. Third item5. Fourth item1. First item2. Second item3. Third item 1. Indented item 2. Indented item4. Fourth item First item Second item Third item Indented item Indented item Fourth item 无序列表无序列表在每一行开头加上-、+、*，缩进去创建嵌套列表 123456789101112131415161718192021- First item- Second item- Third item- Fourth item* First item* Second item* Third item* Fourth item+ First item* Second item- Third item+ Fourth item- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 在列表中添加其他元素在列表中添加其他元素，要缩进4个空格或者1个tab 123456* This is the first list item.* Here&apos;s the second list item. I need to add another paragraph below the second list item.* And here&apos;s the third list item. This is the first list item. Here’s the second list item. I need to add another paragraph below the second list item. And here’s the third list item. 代码要表示一行代码，使用`来包裹 1At the command prompt, type `nano`. At the command prompt, type nano. 反引号转义在一行代码中如果代码本身也含有反引号，可以把最外层用两个反引号包裹 1``Use `code` in your Markdown file.`` Use `code` in your Markdown file. 代码块代码块的每行代码必须最少缩进4个空格或者1个tab 12345#### &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; 分割线使用三个及以上的*、-、_表示分割线 12345***---_________________ 链接用[]包裹链接文字，随后用()包裹URL 1My favorite search engine is [Duck Duck Go](https://duckduckgo.com). My favorite search engine is Duck Duck Go. 链接添加提示1My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best one&quot;). My favorite search engine is Duck Duck Go. 网页和邮箱为了快速将网页和邮箱转为链接，可以用&lt;&gt;包裹起来 12&lt;https://www.markdownguide.org&gt;&lt;fake@example.com&gt; https://www.markdownguide.org&#102;&#97;&#x6b;&#101;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109; 格式化链接为了强调链接，可以在链接的前后加星号 12I love supporting **[EFF](https://eff.org)**.This is the *[Markdown Guide](https://www.markdownguide.org)*. I love supporting EFF.This is the Markdown Guide. 图片图片的插入方式是在最开始插入!，然后用[]包裹图片无法加载的描述，再把图片的地址用()包裹 1![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;) 带链接的图片给图片加链接的方式是，把图片的Markdown用[]包裹，再在后面把链接地址用()包裹 1[![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;)](https://www.google.com) 转义字符如果有些符号是Markdown使用的，但是又想显示，可以在字符前加\ 1\* Without the backslash, this would be a bullet in an unordered list. 转义字符列表 Character Name \ backslash ` tick mark * asterisk _ underscore {} curly braces [] brackets () parentheses # pound sign + plus sign - minus sign (hyphen) . dot ! exclamation mark]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
