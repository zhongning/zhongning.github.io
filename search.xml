<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 032 Longest Valid Parentheses]]></title>
    <url>%2Fposts%2F65225%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example 1: 123Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: 123Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; Difficulty: Hard Code: 12345class Solution &#123; public int longestValidParentheses(String s) &#123; &#125;&#125; 题意 Solution 112 时间复杂度: O()。 空间复杂度: O()。 Solution 212 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 031 Next Permutation]]></title>
    <url>%2Fposts%2F12241%2F</url>
    <content type="text"><![CDATA[DescriptionImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Difficulty: Medium Code: 12345class Solution &#123; public void nextPermutation(int[] nums) &#123; &#125;&#125; 题意求全排列下一个排列顺序，参考如下。 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Solution 1若给定数组是降序，则说明是全排列到最后一组，下一个排列顺序就是最开始到一组。 例如又一个数组1 2 7 4 3 1，则下一个排列为1 3 1 2 4 7。 从末尾往前看，数字逐渐变大，到来2开始减小，在从后往前找到第一个比2大的数3，将3与2进行交换，再将3后面的数字反转。 1234567891011121314151617181920212223242526272829class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length, i=0, j=0; for(i=len-2;i&gt;=0;i--)&#123; if(nums[i]&lt;nums[i+1])&#123; break; &#125; &#125; if(i!=-1)&#123; for(j=len-1;j&gt;=0;j--)&#123; if(nums[j]&gt;nums[i])&#123; break; &#125; &#125; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; &#125; i=i+1; j=len-1; while(i&lt;j)&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; i++; j--; &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 030 Substring with Concatenation of All Words]]></title>
    <url>%2Fposts%2F6607%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: 123456Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too. Example 2: 1234Input: s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]Output: [] Difficulty: Hard Code: 12345class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; &#125;&#125; 题意给定字符串s和一系列单词words，单词的长度都相等。找出所有匹配的子串的起始位置，匹配的字符子串需是由所有这些单词串联一次而成。 Solution 1首先若字符串s的长度m小于所有单词长度之和n，则返回空。同时令单词长度为l。 然后对字符串s从第0位到m-n位进行遍历，若从当前i到i+l，若单词列表中含有，则开始进行判断。 判读是重新copy一份单词列表到wordCopy，对从i开始的每一长度为l的子串，若在wordCopy中，则将其从wordCopy删除，并移动l重新查找，直到wordCopy不包含或者为空。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s==null||words==null||s.length()==0||words.length==0||words[0]==null||words[0].length()==0) return res; int m = s.length(), n = words.length*words[0].length(), l=words[0].length(); if(n&gt;m) return res; List&lt;String&gt; wordList = Arrays.asList(words); for(int i=0;i&lt;=m-n;i++)&#123; if(wordList.contains(s.substring(i,i+l)))&#123; List&lt;String&gt; wordCopy = new ArrayList&lt;String&gt;(); wordCopy.addAll(wordList); int start = i; while(wordCopy.size()&gt;0)&#123; if(wordCopy.contains(s.substring(start,start+l)))&#123; wordCopy.remove(s.substring(start,start+l)); start+=l; &#125;else&#123; break; &#125; &#125; if(wordCopy.size()==0)&#123; res.add(i); &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上述解法1有个缺陷是单词不能重复，为了针对单词有重复到情况，要使用HashMap代替List。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s==null||words==null||s.length()==0||words.length==0||words[0]==null||words[0].length()==0) return res; int m = s.length(), n = words.length, l=words[0].length(); if(n*l&gt;m) return res; Map&lt;String,Integer&gt; wordMap = new HashMap&lt;String,Integer&gt;(); for(String word:words)&#123; if(wordMap.containsKey(word))&#123; wordMap.put(word,wordMap.get(word)+1); &#125;else&#123; wordMap.put(word,1); &#125; &#125; for(int i=0;i&lt;=m-n*l;i++)&#123; int j=0; Map&lt;String,Integer&gt; wordTmpMap = new HashMap&lt;String,Integer&gt;(); for(;j&lt;n;j++)&#123; String word = s.substring(i+j*l,i+j*l+l); if(wordMap.containsKey(word))&#123; if(wordTmpMap.containsKey(word))&#123; if(wordTmpMap.get(word)==wordMap.get(word)) break; wordTmpMap.put(word,wordTmpMap.get(word)+1); &#125;else&#123; wordTmpMap.put(word,1); &#125; &#125;else&#123; break; &#125; &#125; if(j==n&amp;&amp;wordTmpMap.size()==wordMap.size()) res.add(i); &#125; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3上述解法2到优化版，使用了Map.getOrDefault()来优化Map到操作。 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; final Map&lt;String, Integer&gt; counts = new HashMap&lt;&gt;(); for (final String word : words) &#123; counts.put(word, counts.getOrDefault(word, 0) + 1); &#125; final List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;(); final int n = s.length(), num = words.length, len = words[0].length(); for (int i = 0; i &lt; n - num * len + 1; i++) &#123; final Map&lt;String, Integer&gt; seen = new HashMap&lt;&gt;(); int j = 0; while (j &lt; num) &#123; final String word = s.substring(i + j * len, i + (j + 1) * len); if (counts.containsKey(word)) &#123; seen.put(word, seen.getOrDefault(word, 0) + 1); if (seen.get(word) &gt; counts.getOrDefault(word, 0)) &#123; break; &#125; &#125; else &#123; break; &#125; j++; &#125; if (j == num) &#123; indexes.add(i); &#125; &#125; return indexes; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 029 Divide Two Integers]]></title>
    <url>%2Fposts%2F4645%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: 12Input: dividend = 10, divisor = 3Output: 3 Example 2: 12Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. Difficulty: Medium Code: 12345class Solution &#123; public int divide(int dividend, int divisor) &#123; &#125;&#125; 题意实现整数的除法，禁止使用乘法、除法、取余。整数范围为有符号int，除数不会是0，结果溢出后返回231 − 1。 Solution 1思路是把数转成正数long，再按位移动的操作。若被除数m比除数n大，将n往左移一位成t再比较，这样可以快速定位到例如1、2、4、8倍的倍数p。 然后将m减去t，倍数结果res加上p，不断循环，最后根据符号返回结果。 1234567891011121314151617181920class Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend==0) return 0; if(divisor==1) return dividend; if(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-1) return Integer.MAX_VALUE; if(divisor==-1) return -dividend; long m = Math.abs(Long.valueOf(dividend)), n = Math.abs(Long.valueOf(divisor)); int res = 0, sign = (dividend&lt;0)^(divisor&lt;0)?-1:1; while(m&gt;=n)&#123; long t=n,p=1; while(m&gt;=(t&lt;&lt;1))&#123; t&lt;&lt;=1; p&lt;&lt;=1; &#125; res+=p; m-=t; &#125; return sign==1?res:-res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2在解法1的基础上使用递归。 123456789101112131415161718class Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend==0) return 0; if(divisor==1) return dividend; if(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-1) return Integer.MAX_VALUE; if(divisor==-1) return -dividend; long m = Math.abs(Long.valueOf(dividend)), n = Math.abs(Long.valueOf(divisor)); if(m&lt;n) return 0; int res = 0, sign = (dividend&lt;0)^(divisor&lt;0)?-1:1; long t=n,p=1; while(m&gt;=(t&lt;&lt;1))&#123; t&lt;&lt;=1; p&lt;&lt;=1; &#125; res+=p+divide(Long.valueOf(m-t).intValue(),Long.valueOf(n).intValue()); return sign==1?res:-res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 028 Implement strStr()]]></title>
    <url>%2Fposts%2F18258%2F</url>
    <content type="text"><![CDATA[DescriptionImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: 12Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Difficulty: Easy Code: 12345class Solution &#123; public int strStr(String haystack, String needle) &#123; &#125;&#125; 题意实现String.indexOf()的功能，返回needle在haystack第一次出现的下标，若不存在则返回-1。若needle是空字符串，则返回0。 Solution 1遍历haystack直到其当前字符等于needle的首字符，然后基于needle比较后续字符是否相等。 若有不想等或者到达haystack末尾，则说明不匹配，haystack往后移动一位。 12345678910111213141516171819class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle==null||needle.isEmpty()) return 0; if(haystack==null||haystack.isEmpty()) return -1; for(int i=0;i&lt;haystack.length();i++)&#123; if(haystack.charAt(i)==needle.charAt(0))&#123; boolean flag = true; for(int j=0;j&lt;needle.length();j++)&#123; if(i+j&gt;=haystack.length() || haystack.charAt(i+j)!=needle.charAt(j))&#123; flag = false; break; &#125; &#125; if(flag) return i; &#125; &#125; return -1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2解法1的优化版本，遍历haystack时，直接比较needle的所有字符。 1234567891011121314class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle==null||needle.isEmpty()) return 0; if(haystack==null||haystack.length()&lt;needle.length()) return -1; for(int i=0;i&lt;=haystack.length()-needle.length();i++)&#123; int j = 0; for(;j&lt;needle.length();j++)&#123; if(haystack.charAt(i+j)!=needle.charAt(j)) break; &#125; if(j==needle.length()) return i; &#125; return -1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 027 Remove Element]]></title>
    <url>%2Fposts%2F39064%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: 12345Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 1234567Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Difficulty: Easy Code: 12345class Solution &#123; public int removeElement(int[] nums, int val) &#123; &#125;&#125; 题意给定一个整数数组nums，将所有等于val的元素移除，并且返回新数组的长度。 不允许分配额外的空间同创建新数组，必须直接修改当前数组以达到空间复杂度为O(1)。 Solution 1使用双指针，left指向最终去掉目前元素数组掉最新位置，right指向当前遍历掉位置。 若right的值不等于目标值val，则nums在left的值更新为right的值，left及right加1。 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int left = 0, right = 0; while(right&lt;nums.length)&#123; if(nums[right]!=val)&#123; nums[left++]=nums[right]; &#125; right++; &#125; return left; &#125;&#125; 时间复杂度: O(n)。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 026 Remove Duplicates from Sorted Array]]></title>
    <url>%2Fposts%2F12484%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Difficulty: Easy Code: 12345class Solution &#123; public int removeDuplicates(int[] nums) &#123; &#125;&#125; 题意给定一个有序的数字数组，移除重复的元素，并且返回新的长度。不允许分配额外的空间给另外一个数组，要直接修改输入数组达到O(1)的空间复杂度。 Solution 1使用双指针，left指向该数字出现的第一个位置，right初始指向left的下一位，len表示最终的长度。 遍历数组，若right位置上的数字和left相同，则right往后移动一位，直到发现不同的数字或者达到末尾。 当发现不同数字时，更新len，并将数组len-1上的值更新为最新发现的数字，同时left移动到right位置，right后移一位。 1234567891011121314151617181920class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length&lt;=1) return nums.length; int left = 0, right = 1; int len = 1; while(right&lt;nums.length)&#123; while(nums[right]==nums[left])&#123; right++; if(right&gt;=nums.length)&#123; return len; &#125; &#125; len++; nums[len-1]=nums[right]; left=right; right++; &#125; return len; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2对解法1进行优化，left指向最终去重后对当前位置，right指向当前遍历对位置。 当right位置上到元素和left不相等时，left后移一位，同时给left位置赋right的值，然后继续right后移一位。 123456789101112class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length&lt;=1) return nums.length; int left = 0, right = 0; while(++right &lt; nums.length)&#123; if(nums[right]!=nums[left])&#123; nums[++left]=nums[right]; &#125; &#125; return left+1; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3也可以如解法2，只使用左侧指针，右侧依靠for循环来取出当前位置的值。 1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int n = 0; for(int num:nums)&#123; if(n==0 || num!=nums[n-1])&#123; nums[n++]=num; &#125; &#125; return n; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 025 Reverse Nodes in k-Group]]></title>
    <url>%2Fposts%2F34575%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. Difficulty: Hard Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; &#125;&#125; 题意给定一个链表，将其每k个节点反转，并返回修改后的链表。k是小于等于链表长度的正整数，不足k个时保持原样。不允许修改节点的值，只允许修改整个节点。 Solution 1把每k个节点为一组进行反转，那样需要两个函数，一个用来分段，一个用来反转。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), curr= head, start = curr , lastDone = dummy; int count = 0; while(curr!=null)&#123; count++; ListNode nextOne = curr.next; if(count==k)&#123; lastDone.next=reverse(start,k); lastDone=start; start=nextOne; count=0; &#125; curr=nextOne; &#125; lastDone.next=start; return dummy.next; &#125; public ListNode reverse(ListNode node, int k)&#123; ListNode dummy = new ListNode(0), curr = node; for(int i=0;i&lt;k;i++)&#123; ListNode tmp = dummy.next; dummy.next = curr; curr = curr.next; dummy.next.next=tmp; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上述解法，是以k为步进来生成最终的结果链表，保存了很多状态。也可以很平滑地进行反转，在反转是带上k个节点为一组的前置和后置节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), pre = dummy, curr = head; dummy.next = head; for(int i=1;curr!=null;i++)&#123; if(i%k==0)&#123; pre = reverse(pre,curr.next); curr = pre.next; &#125;else&#123; curr = curr.next; &#125; &#125; return dummy.next; &#125; public ListNode reverse(ListNode pre, ListNode next)&#123; ListNode last = pre.next, curr = last.next; while(curr!=next)&#123; last.next = curr.next; curr.next = pre.next; pre.next = curr; curr = last.next; &#125; return last; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3上述过程也可以在一个方法中完成，先遍历整个链表计算出链表长度，然后每次对k个节点进行反转。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), pre = dummy, curr = head; dummy.next = head; int num = 0; while(curr!=null)&#123; num++; curr = curr.next; &#125; while(num&gt;k)&#123; curr = pre.next; for(int i=1;i&lt;k;i++)&#123; ListNode tmp = curr.next; curr.next=tmp.next; tmp.next=pre.next; pre.next=tmp; &#125; pre = curr; num -= k; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 4递归调用，我们用pre记录每段的开始位置的前一个节点，cur记录结束位置的下一个节点，然后我们调用reverse函数来将这段翻转，然后得到一个new_head，原来的head就变成了末尾，这时候后面接上递归调用下一段得到的新节点，返回new_head即可。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), pre = dummy, curr = head; dummy.next = head; for(int i=0;i&lt;k;i++)&#123; if(curr==null) return head; curr = curr.next; &#125; ListNode newHead = reverse(pre,curr); head.next = reverseKGroup(curr,k); return newHead; &#125; public ListNode reverse(ListNode pre, ListNode next)&#123; ListNode last = pre.next, curr = last.next; while(curr!=next)&#123; last.next = curr.next; curr.next = pre.next; pre.next = curr; curr = last.next; &#125; return pre.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 024 Swap Nodes in Pairs]]></title>
    <url>%2Fposts%2F65154%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; &#125;&#125; 题意给定一个链表，按顺序将每两个节点交换，并返回链表头部。不能修改节点的值，只能改变整个节点。 Solution 1若链表为空或只有一个节点则返回头节点。循环遍历，条件是当前节点和当前节点的下一个节点都存在，在循环体中把这两个交换位置放入结果链表中。 当退出循环体后，只有一个节点没有遍历或者都遍历过，只需要在将其添加到结果链表中去。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode dummy = new ListNode(0), curr = dummy; while(head!=null&amp;&amp;head.next!=null)&#123; ListNode tmp = head.next.next; curr.next=head.next; curr.next.next=head; curr=curr.next.next; head=tmp; &#125; curr.next=head; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2递归调用，先把链表的前两个节点交换，再对除去这两个节点对链表进行递归调用，并将其赋给第二个节点的下一位，返回第一个节点。 1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode res = head.next; head.next=swapPairs(head.next.next); res.next=head; return res; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 023 Merge k Sorted Lists]]></title>
    <url>%2Fposts%2F44312%2F</url>
    <content type="text"><![CDATA[DescriptionMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Difficulty: Hard Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; &#125;&#125; 题意把K个有序链表合并成一个有序链表。 Solution 1和合并两个链表类似，建立哨兵节点，结果返回哨兵节点下一位。进循环，循环中每次遍历所有链表的首个节点，并比较各个节点，找出值最小的节点。 将结果链接的当前节点指向这个最小节点，并将链表数组中最小节点所在的链表移动到最小节点到下一节点。 若碰到某个链表当前节点为空则跳过，若所有链表当前节点都为空则退出循环。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode dummy=new ListNode(0), curr=dummy; while(true)&#123; int num = lists.length; int minVal = Integer.MAX_VALUE; int minIndex = -1; ListNode minNode = null; for(int i=0;i&lt;lists.length;i++)&#123; ListNode node = lists[i]; if(node==null)&#123; num--; continue; &#125; if(node.val&lt;minVal)&#123; minVal=node.val; minIndex = i; minNode=node; &#125; &#125; if(minNode!=null)&#123; curr.next=minNode; curr=curr.next; lists[minIndex]=minNode.next; &#125; if(num==0)&#123; break; &#125; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2使用PriorityQueue来维持一个最小堆，把k个链表到首节点放入优先队列中，它们会自动根据值val排序好。 每次取出最小的节点加入到结果链表中，并把该最小节点的下一位放入队列中。依此类推，直到队列中没有元素。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists==null||lists.length==0) return null; ListNode dummy=new ListNode(0), curr=dummy; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(lists.length, new Comparator&lt;ListNode&gt;()&#123; public int compare(ListNode o1, ListNode o2)&#123; if(o1.val&lt;o2.val)&#123; return -1; &#125;else if(o1.val==o2.val)&#123; return 0; &#125;else&#123; return 1; &#125; &#125; &#125;); for(ListNode node:lists)&#123; if(node!=null)&#123; queue.add(node); &#125; &#125; while(!queue.isEmpty())&#123; curr.next=queue.poll(); curr=curr.next; if(curr.next!=null)&#123; queue.add(curr.next); &#125; &#125; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3不管几个链表，都可以两两合并，最终合并成一个链表。利用分治思想，将链表数组从中划分为两部分，分别顺序合并两部分每一个链表并赋给前半部分。 不停地对半划分并合并更新，直到应该合并的链表数量为1，即已经合并完成所有链表。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists==null||lists.length==0) return null; int n = lists.length; while(n&gt;1)&#123; int steps = (n+1)/2; for(int i=0;i&lt;n/2;i++)&#123; lists[i]=mergeTwoLists(lists[i],lists[i+steps]); &#125; n=steps; &#125; return lists[0]; &#125; public ListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; ListNode dummy=new ListNode(0), curr=dummy; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; curr.next=l1; curr=curr.next; l1=l1.next; &#125;else&#123; curr.next=l2; curr=curr.next; l2=l2.next; &#125; &#125; if(l1==null) curr.next=l2; if(l2==null) curr.next=l1; return dummy.next; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-divide-and-conquer</tag>
        <tag>leetcode-heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 022 Generate Parentheses]]></title>
    <url>%2Fposts%2F28316%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; &#125;&#125; 题意给定n对括弧，生成所有正确形式组合的字符串。 Solution 1对于这种列出所有结果的题目优先考虑递归Recursion求解。对于n，则有n个左括号和n个右括号，定义两个变量open、close表示左右括号还剩下的个数。因为总是先出现左括号，所有open应该不大于close。 若出现open大于close则直接返回。若open和close都为0则将当前字符串放入结果中。若open或者close不为0，则递归调用并更新open或close的值。 12345678910111213141516171819class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(n&lt;=0) return res; generate(n,n,res,""); return res; &#125; public void generate(int open, int close, List&lt;String&gt; res, String out)&#123; if(close&lt;open) return; if(open==0&amp;&amp;close==0) res.add(out); if(open&gt;0)&#123; generate(open-1,close,res,out+"("); &#125; if(close&gt;0)&#123; generate(open,close-1,res,out+")"); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2没当N加1时，找现有N的所有结果，在结果字符串中如果遇见左括号，则直接在其后加入()或者在该字符串末尾加上()，然后返回。使用Set去重，变化如下所示。 12345n＝1: ()n=2: (()) ()()n=3: (()()) ((())) ()(()) (())() ()()() 1234567891011121314151617181920class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; if(n&lt;=0) return new ArrayList&lt;String&gt;(); Set&lt;String&gt; res = new HashSet&lt;String&gt;(); res.add("()"); for(int i=1;i&lt;n;i++)&#123; Set&lt;String&gt; tmp = new HashSet&lt;String&gt;(); for(String str:res)&#123; for(int j=0;j&lt;str.length();j++)&#123; if(str.charAt(j)=='(')&#123; tmp.add(str.substring(0,j+1)+"()"+str.substring(j+1)); tmp.add(str+"()"); &#125; &#125; &#125; res = tmp; &#125; return new ArrayList&lt;String&gt;(res); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 021 Merge Two Sorted Lists]]></title>
    <url>%2Fposts%2F13700%2F</url>
    <content type="text"><![CDATA[DescriptionMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Difficulty: Easy Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; &#125;&#125; 题意把K个有序链表合并成一个有序链表。 Solution 1建立哨兵节点，当前节点指向哨兵节点。开始While循环，条件是l1和l2都不为空。在循环体中，比较l1和l2到值找出较小的节点，到将其放在结果链表当前位置之后，并将该节点及结果链接都往后移一位，继续循环。 由于遍历到最后，肯定有一个链表先遍历到末尾退出循环，则结果链表的后面接上未完成的链表，最终返回哨兵节点的后一位。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy=new ListNode(0), curr=dummy; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; curr.next=l1; l1=l1.next; &#125;else&#123; curr.next=l2; l2=l2.next; &#125; curr=curr.next; &#125; curr.next=l1!=null?l1:l2; return dummy.next; &#125;&#125; 时间复杂度: O(M+N)，两个链表的长度。 空间复杂度: O(M+N)，两个链表的长度。 Solution 2使用递归，比较两个链表当前节点的大小找出较小的节点，则对剩余对节点进行递归调用，将返回对结果赋给此节点对下一位，同时返回该节点作为结果。 相当于每次递归只找出一个合适的节点，递归结束的条件是有个链表为空，则直接返回另一个链表未完成的部分。 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;=l2.val)&#123; l1.next=mergeTwoLists(l1.next,l2); return l1; &#125;else&#123; l2.next=mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125; 时间复杂度: O(M+N)，两个链表的长度。 空间复杂度: O(M+N)，两个链表的长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 020 Valid Parentheses]]></title>
    <url>%2Fposts%2F29601%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]‘, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;&#123;[]&#125;&quot;Output: true Difficulty: Easy Code: 12345class Solution &#123; public boolean isValid(String s) &#123; &#125;&#125; 题意给定一个字符串，只包含”(){}[]”，判断输入到字符串是否有效。开括号和必须以同样到类型到闭括号关闭，开括号必须以正确到顺序关闭。 Solution 1看到开括号必要要以相同到顺序关闭，自然想到栈，读取到开括号则压栈，读取到闭括号则出栈并判断是否配对。读取完栈需为空，否则无效。 12345678910111213141516171819class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); String left = "([&#123;"; String right = ")]&#125;"; for(char curr:s.toCharArray())&#123; if(left.indexOf(curr)!=-1)&#123; stack.push(curr); &#125;else if(right.indexOf(curr)!=-1)&#123; if(stack.isEmpty()) return false; char open = stack.pop(); if(right.charAt(left.indexOf(open))!=curr)&#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 时间复杂度: O(N)，字符串长度。 空间复杂度: O(N)，字符串长度。 Solution 2把所有括号符号依次拼接成字符串，Stack里面存括号在字符串中位置，以简化计算。 12345678910111213public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Integer&gt; p = new Stack&lt;&gt;(); String brackets = "()&#123;&#125;[]"; for(char curr:s.toCharArray()) &#123; int q = brackets.indexOf(curr); if(q % 2 == 1) &#123; if(p.isEmpty() || p.pop() != q - 1) return false; &#125; else p.push(q); &#125; return p.isEmpty(); &#125;&#125; 时间复杂度: O(N)，字符串长度。 空间复杂度: O(N)，字符串长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 019 Remove Nth Node From End of List]]></title>
    <url>%2Fposts%2F58507%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; &#125;&#125; 题意给定一个链表，移除链表的倒数第N个节点，并返回链表的头节点。限定N总是有效的不会超出链表长度，最好遍历一次。 Solution 1在第一个节点的前面建立一个哨兵节点，使用双指针left和right，最初都指向哨兵节点。 然后先把right往后移N位，若right的next为空则表明N和链表的长度相同，要删除第一个节点。 否则开始同时移动left和right，保持right和left间距为N，直至right的next为空即移动到末尾。此时，left到下一个节点即为要删除到节点。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head.next==null) return null; ListNode dummy = new ListNode(0); dummy.next=head; ListNode left = dummy, right = dummy; for(int i=0;i&lt;n;i++)&#123; right=right.next; &#125; if(right.next==null) return dummy.next.next; while(right.next!=null)&#123; right=right.next; left=left.next; &#125; left.next=left.next.next; return dummy.next; &#125;&#125; 时间复杂度: O(N)，遍历一次。 空间复杂度: O(1)，使用恒定到额外空间。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 018 4Sum]]></title>
    <url>%2Fposts%2F52863%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; &#125;&#125; 题意给定n个整数和一个目标整数，从n个整数中找出所有不重复的4个数字组合，使得它们之和等于目标整数。 Solution 1和三数之和一样，把数组从小到大排序，循环固定前两个数字，后两个数组采用双指针，一个从前往后，一个从后往前。 若四数之和等于目标值则加入结果集，若大于，则右侧数字往左移，否则左侧数字往右移。通过Set过滤重复元素。 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Set&lt;List&lt;Integer&gt;&gt; result = new HashSet&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-3;i++)&#123; for(int j=i+1;j&lt;nums.length-2;j++)&#123; int left=j+1,right=nums.length-1; while(left&lt;right)&#123; int sum = nums[i]+nums[j]+nums[left]+nums[right]; if(sum==target)&#123; result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); left++; right--; &#125;else if(sum&gt;target)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(result); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2下面解法不使用Set去重，对于四个数的每一位取值上，若当前数字和前一位一样则跳过。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-3;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; for(int j=i+1;j&lt;nums.length-2;j++)&#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; int left=j+1,right=nums.length-1; while(left&lt;right)&#123; int sum = nums[i]+nums[j]+nums[left]+nums[right]; if(sum==target)&#123; result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left&lt;right&amp;&amp;nums[left+1]==nums[left]) left++; while(left&lt;right&amp;&amp;nums[right-1]==nums[right]) right--; left++; right--; &#125;else if(sum&gt;target)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; &#125; return result; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 017 Letter Combinations of a Phone Number]]></title>
    <url>%2Fposts%2F35100%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Difficulty: Medium Code: 12345class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; &#125;&#125; 题意给定一个包含数字2-9的字符串，返回数字代表的所有可能的字符组合。数字和字母的映射和电话按钮一样。 Solution 1使用递归进行，递归方法没有返回值，只有当递归到输入字符串为空时，才将当前字符组合添加进结果集并返回。 否则，找到当前字符串第一位对应到所有字符，循环调用递归，更新参数。 1234567891011121314151617181920class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if(digits.isEmpty()) return result; String[] mapping = new String[]&#123;"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;; generateAll(digits,result,"",mapping); return result; &#125; public void generateAll(String digits, List&lt;String&gt; result, String out, String[] mapping)&#123; if(digits.isEmpty())&#123; result.add(out); return; &#125;; int index = (digits.charAt(0)-'0')-2; for(char curr:mapping[index].toCharArray())&#123; generateAll(digits.substring(1),result,out+curr,mapping); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2使用迭代，结果集初始化进去一个空字符串。在遍历digits中的所有数字时，先建立一个临时字符串结果列表，通过数字取出其对应字符数组，遍历字符数组并取出结果集中所有字符串，将字符拼接在后面并放入临时列表。 每遍历一个数字，将结果集重新指向临时列表。 12345678910111213141516171819class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if(digits.isEmpty()) return result; String[] mapping = new String[]&#123;"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;; result.add(""); for(int i=0;i&lt;digits.length();i++)&#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); int index = (digits.charAt(i)-'0')-2; for(String s:result)&#123; for(char c:mapping[index].toCharArray())&#123; tmp.add(s+c); &#125; &#125; result=tmp; &#125; return result; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 016 3Sum Closest]]></title>
    <url>%2Fposts%2F38928%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Difficulty: Medium Code: 12345class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; &#125;&#125; 题意给定n个整数和一个目标整数，找出三个整数，其和和目标整数最接近。 Solution 1和求三数之和为0类似，循环固定第一个数，第二个数从第一个数下一位往右取，第三个从末尾往左取。 定义一个变量记录三数之和与给定值差的绝对值，比较差值，若小则更新最小差值并记录和。 123456789101112131415161718192021222324class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int closest = Integer.MAX_VALUE, res = Integer.MAX_VALUE; Arrays.sort(nums); for(int i=0;i&lt;nums.length-2;i++)&#123; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; int sum = nums[i]+nums[j]+nums[k]; if(closest&gt;Math.abs(sum-target))&#123; closest = Math.abs(sum-target); res = sum; &#125; if(sum==target)&#123; return target; &#125;else if(sum&gt;target)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n2)，每个数字最多遍历两遍。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 015 3Sum]]></title>
    <url>%2Fposts%2F42879%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Difficulty: Medium Code: 12345class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; &#125;&#125; 题意给定n个整数，求所有三个数字组合使得它们之和为0，数字组合不能重复。 Solution 1可以将数字排序，顺序取三个满足条件的数字。循环固定第一个数字，肯定不大于0，否则之和会大于0。第二个数字从第一个数的右边开始往右，第三个从末尾开始往左。 若之和为0，则添加进结果集。若小于0，则第二个数字太小，需要往右侧移动。若大于0，则表明第三个数字过大，需要往左侧移动。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-2&amp;&amp;nums[i]&lt;=0;i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123; continue; &#125; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; if(nums[i]+nums[j]+nums[k]==0)&#123; List&lt;Integer&gt; match = new ArrayList&lt;&gt;(); match.add(nums[i]); match.add(nums[j]); match.add(nums[k]); res.add(match); while(j&lt;k&amp;&amp;nums[j+1]==nums[j])&#123; j++; &#125; while(j&lt;k&amp;&amp;nums[k-1]==nums[k])&#123; k--; &#125; j++; k--; &#125;else if(nums[i]+nums[j]+nums[k]&gt;0)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n2)，每个数字最多遍历两遍。 空间复杂度: O(1)，需要保存结果集。 Solution 2可以使用Set来保存结果，这样可以去掉去重部分的代码。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length-2&amp;&amp;nums[i]&lt;=0;i++)&#123; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; if(nums[i]+nums[j]+nums[k]==0)&#123; res.add(Arrays.asList(nums[i],nums[j],nums[k])); j++; k--; &#125;else if(nums[i]+nums[j]+nums[k]&gt;0)&#123; k--; &#125;else&#123; j++; &#125; &#125; &#125; return new ArrayList(res); &#125;&#125; 时间复杂度: O(n2)，每个数字最多遍历两遍。 空间复杂度: O(1)，需要保存结果集。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 014 Longest Common Prefix]]></title>
    <url>%2Fposts%2F48879%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Difficulty: Easy Code: 12345class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; &#125;&#125; 题意在字符串数组中找出最长的公共前缀字符串，若没有则返回空字符串。 Solution 1已字符串数组到第一个元素为基础，遍历该字符串取得当前字符，然后遍历其他字符串到当前位置，若其他字符串已经到达末尾或者字符不一致，则返回已经匹配过的。 1234567891011121314class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs==null||strs.length==0||strs[0]==null||strs[0].length()==0) return ""; for(int i=0;i&lt;strs[0].length();i++)&#123; char curr = strs[0].charAt(i); for(int j=1;j&lt;strs.length;j++)&#123; if(strs[j].length()&lt;=i||strs[j].charAt(i)!=curr)&#123; return strs[0].substring(0,i); &#125; &#125; &#125; return strs[0]; &#125;&#125; 时间复杂度: O(S)，S是所有字符串字符的长度，因为所有字符都只遍历一次。 空间复杂度: O(1)。 Solution 2可以将所以字符串排序，那么最前和最后的字符串肯定是差距最大的，此时只需要比较这两个字符串即可。 123456789101112131415class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs==null||strs.length==0) return ""; Arrays.sort(strs); int len = Math.min(strs[0].length(),strs[strs.length-1].length()); int i=0; while(i&lt;len)&#123; if(strs[0].charAt(i)!=strs[strs.length-1].charAt(i))&#123; return strs[0].substring(0,i); &#125; i++; &#125; return strs[0].substring(0,i); &#125;&#125; 时间复杂度: O(S)，S是所有字符串字符的长度，因为所有字符都只遍历一次。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 013 Roman to Integer]]></title>
    <url>%2Fposts%2F19839%2F</url>
    <content type="text"><![CDATA[DescriptionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Difficulty: Easy Code: 12345class Solution &#123; public int romanToInt(String s) &#123; &#125;&#125; 题意将罗马数字转成整数，假定此整数范围在1到3999。 Solution 1将罗马字符和其整数值相对应，遍历罗马数字字符串，若后一位字符所代表到位数比当前位数高，则用后一位到整数值减去当前位到整数值再累加，否则直接累加。 12345678910111213141516class Solution &#123; public int romanToInt(String s) &#123; int result = 0; int[] values = new int[]&#123;1000,500,100,50,10,5,1&#125;; String roman = "MDCLXVI"; for(int i=0;i&lt;s.length();i++)&#123; if(i&lt;s.length()-1&amp;&amp;roman.indexOf(s.charAt(i))&gt;roman.indexOf(s.charAt(i+1)))&#123; result += values[roman.indexOf(s.charAt(i+1))] - values[roman.indexOf(s.charAt(i))]; i++; &#125;else&#123; result += values[roman.indexOf(s.charAt(i))]; &#125; &#125; return result; &#125;&#125; 时间复杂度: O(n)，数字到长度。 空间复杂度: O()。 Solution 2我们需要用到HashMap数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可：第一，如果当前数字不是最后一个数字且之后的数字比它大的话，则减去当前数字。第二，其他情况则加上这个数字。 12345678910111213141516171819202122class Solution &#123; public int romanToInt(String s) &#123; int result = 0; Map&lt;Character,Integer&gt; romans = new HashMap&lt;Character,Integer&gt;(); romans.put('M',1000); romans.put('D',500); romans.put('C',100); romans.put('L',50); romans.put('X',10); romans.put('V',5); romans.put('I',1); for(int i=0;i&lt;s.length();i++)&#123; char curr = s.charAt(i); if(i&lt;s.length()-1&amp;&amp;romans.get(curr)&lt;romans.get(s.charAt(i+1)))&#123; result -= romans.get(curr); &#125;else&#123; result += romans.get(curr); &#125; &#125; return result; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 012 Integer to Roman]]></title>
    <url>%2Fposts%2F56606%2F</url>
    <content type="text"><![CDATA[DescriptionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: 3Output: &quot;III&quot; Example 2: 12Input: 4Output: &quot;IV&quot; Example 3: 12Input: 9Output: &quot;IX&quot; Example 4: 123Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. Example 5: 123Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Difficulty: Medium Code: 12345class Solution &#123; public String intToRoman(int num) &#123; &#125;&#125; 题意给定一个整数，将其转成罗马数字，整数的范围在1到3999。 Solution 1给定的整数范围在1到3999，那么只有千位、百位、十位、个位。例如计算出百位的数字，那么这个百位数字涉及到到罗马字符只有’M’,’D’,’C’，同理其他位。写一个工具方法，可以根据当前位的值及涉及的三个罗马字符得到此位最后的罗马字符。对数不断对位的权重取商，并更新为对位的权重求余结果。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); char[] symbols = new char[]&#123;' ',' ','M','D','C','L','X','V','I'&#125;; int weight = 1000; int index = 0; while(num!=0)&#123; int n = num/weight; appendRoman(sb,n,symbols[index],symbols[index+1],symbols[index+2]); num = num%weight; weight=weight/10; index+=2; &#125; return sb.toString(); &#125; public void appendRoman(StringBuilder sb, int n, char prev, char five, char one)&#123; if(n==4)&#123; sb.append(one).append(five); &#125;else if(n==9)&#123; sb.append(one).append(prev); &#125;else if(n&lt;4)&#123; for(int i=0;i&lt;n;i++)&#123; sb.append(one); &#125; &#125;else&#123; sb.append(five); for(int i=0;i&lt;n-5;i++)&#123; sb.append(one); &#125; &#125; &#125;&#125; 时间复杂度: O(n)，数字的长度。 空间复杂度: O()。 Solution 2上述解法还有另外一种写法，在一个函数即可完成。 12345678910111213141516171819202122class Solution &#123; public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); char[] romans = new char[]&#123;'M','D','C','L','X','V','I'&#125;; int[] values = new int[]&#123;1000,500,100,50,10,5,1&#125;; for(int i=0;i&lt;7;i+=2)&#123; int x = num/values[i]; num=num%values[i]; if(x&lt;4)&#123; for(int j=0;j&lt;x;j++) sb.append(romans[i]); &#125;else if(x==4)&#123; sb.append(romans[i]).append(romans[i-1]); &#125;else if(x&gt;4&amp;&amp;x&lt;9)&#123; sb.append(romans[i-1]); for(int j=0;j&lt;x-5;j++) sb.append(romans[i]); &#125;else if(x==9)&#123; sb.append(romans[i]).append(romans[i-2]); &#125; &#125; return sb.toString(); &#125;&#125; 时间复杂度: O(n)，数字的长度。 空间复杂度: O()。 Solution 3将十进制进一步细分到每次罗马字符变动到数表，如十位划分成90、50、40、10。每次找到当前最大的数，返回结果加上对应的罗马字符并减去。 1234567891011121314class Solution &#123; public String intToRoman(int num) &#123; StringBuilder sb = new StringBuilder(); String[] romans = new String[]&#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; int[] values = new int[]&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; for(int i=0;i&lt;romans.length;i++)&#123; while(num&gt;=values[i])&#123; sb.append(romans[i]); num-=values[i]; &#125; &#125; return sb.toString(); &#125;&#125; 时间复杂度: O(n)，数字的长度。 空间复杂度: O()。 Solution 4建立更加详细的数表，把位上的1-9都给列出来，直接查表。 123456789class Solution &#123; public String intToRoman(int num) &#123; String[] m = new String[]&#123;"", "M", "MM", "MMM"&#125;; String[] c = new String[]&#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String[] x = new String[]&#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String[] i = new String[]&#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return m[num / 1000] + c[(num % 1000) / 100] + x[(num % 100) / 10] + i[num % 10]; &#125;&#125; 时间复杂度: O(1)，直接查表。 空间复杂度: O()。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 011 Container With Most Water]]></title>
    <url>%2Fposts%2F12616%2F</url>
    <content type="text"><![CDATA[DescriptionGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 Difficulty: Medium Code: 12345class Solution &#123; public int maxArea(int[] height) &#123; &#125;&#125; 题意给定正整数1, a2, …, an，代表坐标轴横轴上1到n到地方，各有一条垂直到线段，其另一端到高度为正整数到值。两根线及横轴组成了容器，求使容器装最多水到两条线段，并返回装水到面积。 Solution 1使用双指针，定义i和j分别指向数组到左右两端，然后两个指针向中间搜索。搜索到策略是如果左右两端某端的高度要小一些，则将这一端向中间移动，并更新最大面积。因为如果往中间移动高度较高的一端，则面积只会减小，因为最终的面积的高度是由较低的那端决定的，这样高度不变，长度缺减少，面积只能也减小。 123456789101112131415class Solution &#123; public int maxArea(int[] height) &#123; int i=0,j=height.length-1,max=0; while(i&lt;j)&#123; int h = Math.min(height[i],height[j]); max = Math.max(h*(j-i),max); if(height[i]&lt;height[j])&#123; i++; &#125;else&#123; j--; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n)，遍历一遍数组。 空间复杂度: O(1)。 Solution 2也可以在上述解法上小优化，不用每步都计算面积。当确定左侧还是右侧向中间移动后，跳过高度小于上次计算时那侧高度的点。 1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int i=0,j=height.length-1,max=0; while(i&lt;j)&#123; int h = Math.min(height[i],height[j]); max = Math.max(h*(j-i),max); boolean moveRight = height[i]&lt;height[j]?true:false; while(i&lt;j&amp;&amp;moveRight&amp;&amp;h&gt;=height[i])&#123; i++; &#125;; while(i&lt;j&amp;&amp;!moveRight&amp;&amp;h&gt;=height[j])&#123; j--; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n)，遍历一遍数组。 空间复杂度: O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 010 Regular Expression Matching]]></title>
    <url>%2Fposts%2F47345%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false Difficulty: Hard Code: 12345class Solution &#123; public boolean isMatch(String s, String p) &#123; &#125;&#125; 题意这道题关于正则表达式，’.’表示任意字符，’*’表示其之前的字符可以出现0次或者多次。要求返回字符串是否完全匹配正则表达式。 Solution 1使用递归来解，大致思路如下： 当p为空时，若s为空则返回true，否则返回false 当p的长度为1时，若s当长度也为1并且s[0]==p[0]或者p[0]==’.’则返回true，否则返回false 当p的第二个字符不为’*’时，若s为空则返回false，否则判断首字符是否匹配，并且从各自的第二个字符递归调用去匹配 当p的第二个字符为’*’时，进行下列循环，条件时s不为空并且首字符匹配，在循环中递归调用去匹配s和去掉前两个字符的p（假设此时p星号的作用是让前面的字符出现0次） 若匹配则返回true，否则去掉s首字符继续循环（因为首字符已经匹配所以可以去掉s首字符往后面去匹配） 返回递归调用去匹配s和去掉前两个字符的p，因为要处理以下两种情况 若s为空，则表明p的星号表示出现0次 若s不为空，首字符不匹配，也表明p的星号表示出现0次 1234567891011121314151617181920212223242526class Solution &#123; public boolean isMatch(String s, String p) &#123; if(p.length()==0)&#123; return s.length()==0; &#125; if(p.length()==1)&#123; return s.length()==1&amp;&amp;(s.charAt(0)==p.charAt(0)||p.charAt(0)=='.'); &#125; if(p.charAt(1)!='*')&#123; if(s.length()==0)&#123; return false; &#125;else if(s.length()==1)&#123; return (s.charAt(0)==p.charAt(0)||p.charAt(0)=='.')&amp;&amp;isMatch("",p.substring(1)); &#125;else&#123; return (s.charAt(0)==p.charAt(0)||p.charAt(0)=='.')&amp;&amp;isMatch(s.substring(1),p.substring(1)); &#125; &#125; while(s.length()!=0&amp;&amp;(s.charAt(0)==p.charAt(0)||p.charAt(0)=='.'))&#123; if(isMatch(s,p.substring(2)))&#123; return true; &#125; s=s.substring(1); &#125; return isMatch(s,p.substring(2)); &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 2上面的解法可以换一种写法，让代码更简洁 1234567891011121314class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) return s.isEmpty(); boolean first_match = (!s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')); if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '*')&#123; return (isMatch(s, p.substring(2)) || (first_match &amp;&amp; isMatch(s.substring(1), p))); &#125; else &#123; return first_match &amp;&amp; isMatch(s.substring(1), p.substring(1)); &#125; &#125;&#125; 时间复杂度: O()。 空间复杂度: O()。 Solution 3动态规划解法，dp[i][j]表示s[0:i)和p[0:j)是否匹配，从前往进行匹配。 条件判断： 1231. P[i][j] = P[i - 1][j - 1], if p[j - 1] != &apos;*&apos; &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;);2. P[i][j] = P[i][j - 2], if p[j - 1] == &apos;*&apos; and the pattern repeats for 0 times;3. P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;), if p[j - 1] == &apos;*&apos; and the pattern repeats for at least 1 times. 12345678910111213141516171819class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0 ; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; if(j&gt;1 &amp;&amp; p.charAt(j-1)=='*')&#123; dp[i][j]=dp[i][j-2]||(i&gt;0&amp;&amp;(s.charAt(i-1)==p.charAt(j-2)||p.charAt(j-2)=='.')&amp;&amp;dp[i-1][j]); &#125;else&#123; dp[i][j]=i&gt;0&amp;&amp;(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.')&amp;&amp;dp[i-1][j-1]; &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125;&#125; 时间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。 空间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。 Solution 4使用动态规划，dp[i][j]表示s[i:]和p[j:]是否匹配，从后往前进行匹配。 1234567891011121314151617181920class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[s.length()][p.length()] = true; for (int i = s.length(); i &gt;= 0; i--)&#123; for (int j = p.length() - 1; j &gt;= 0; j--)&#123; boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')); if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*')&#123; dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j]; &#125; else &#123; dp[i][j] = first_match &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125; 时间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。 空间复杂度: O(SP)，S代表字符串长度，P代表正则表达式长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
        <tag>leetcode-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 009 Palindrome Number]]></title>
    <url>%2Fposts%2F5013%2F</url>
    <content type="text"><![CDATA[DescriptionDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Difficulty: Easy Code: 12345class Solution &#123; public boolean isPalindrome(int x) &#123; &#125;&#125; 题意判断一个int数是否是回文格式，即从前读取和从后开始读取都是一样的。 Solution 1首先负数排除，不是回文数字。而0是回文数字。针对正数，可以从后往前读取并累加来找出其反向数字，并和原始数字进行比较。 若反转时溢出，那么最终的结果肯定不会相等，可以不用判断是否溢出。 12345678910111213141516class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125;else if(x==0)&#123; return true; &#125; int reverseNum = 0; int curr = x; while(curr!=0)&#123; reverseNum = reverseNum*10 + curr%10; curr = curr/10; &#125; return reverseNum==x; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(1)，只使用int来保存结果。 Solution 2首先负数排除，不是回文数字。而0是回文数字。并且如果正数的末尾是0也不是回文。 其他正数只需要验证前后半段是否对称，和解法1相比快了一倍。具体做法是：每次对10取余取出数的末尾，把reverseNum乘以10并加上余数；同时把x除以10。这样当reverseNum大于等于x时停止循环，x即为前半段，reverseNum为后半段。由于回文数的位数可奇可偶，偶数时两者相等，奇数时中间数字在reverseNum最低位需除以10后再比较。 1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0)&#123; return false; &#125;else if(x==0)&#123; return true; &#125;else if(x%10==0)&#123; return false; &#125; int reverseNum = 0; while(x&gt;reverseNum)&#123; reverseNum = reverseNum*10 + x%10; x = x/10; &#125; return x==reverseNum || x==reverseNum/10; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(1)，只使用int来保存结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 008 String to Integer (atoi)]]></title>
    <url>%2Fposts%2F64402%2F</url>
    <content type="text"><![CDATA[DescriptionImplement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. Difficulty: Medium Code: 12345class Solution &#123; public int myAtoi(String str) &#123; &#125;&#125; 题意实现atoi函数将字符串转换为整数。 函数首先尽可能多的丢弃空白字符，直到发现第一个非空字符位为止。 接着从这个字符开始，读入一个可选的正负号，然后尽可能多的读入数字，最后将它们解析成数值。 字符串中在合法数字后可以包含额外的非法字符，对于这些字符只需丢弃即可。 如果字符串的非空字符不是一个有效的整数，或者，当字符串为空或者只包含空白字符时，不需要执行转换。 如果不能够执行有效的转换则返回0。如果得到的数值超出了整数范围，返回INT_MAX (2147483647) 或者 INT_MIN (-2147483648)。 Solution 1使用StringBuilder保存取出的数字，布尔类型保存是否是正数。开始遍历字符串，有以下情况： 只有最前面的空格可以忽略 第一次遍历到’-‘或则’+’则更新是否是正数 若为数字 如果当前已保存的数字为空，且当前数字为0后一位也为0，则忽略 其他则保存进StringBuilder 其他情况则条件不符，退出遍历 而后判断长度是否超出Integer的限制，并转成Long判断其具体是否超出Integer区间范围。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int myAtoi(String str) &#123; nt len=str.length(); StringBuilder sb = new StringBuilder(); Boolean positive = null; for(int i=0;i&lt;len;i++)&#123; if(sb.length()==0&amp;&amp;positive==null&amp;&amp;str.charAt(i)==' ')&#123; continue; &#125; if(sb.length()==0&amp;&amp;positive==null&amp;&amp;(str.charAt(i)=='-'||str.charAt(i)=='+'))&#123; positive=str.charAt(i)=='-'?false:true; continue; &#125; if(str.charAt(i)&gt;='0'&amp;&amp;str.charAt(i)&lt;='9')&#123; if(sb.length()==0&amp;&amp;str.charAt(i)=='0'&amp;&amp;i&lt;len-1&amp;&amp;str.charAt(i+1)=='0')&#123; continue; &#125;else&#123; sb.append(str.charAt(i)); continue; &#125; &#125; break; &#125; int maxLen = String.valueOf(Integer.MAX_VALUE).length(); if(sb.length()==0)&#123; return 0; &#125; positive=positive==null?true:positive; if(sb.length()&gt;maxLen)&#123; return positive?Integer.MAX_VALUE:Integer.MIN_VALUE; &#125; Long longValue = positive?Long.valueOf(sb.toString()):0L-Long.valueOf(sb.toString()); if(longValue&gt;Integer.MAX_VALUE)&#123; return Integer.MAX_VALUE; &#125;else if(longValue&lt;Integer.MIN_VALUE)&#123; return Integer.MIN_VALUE; &#125;else&#123; return longValue.intValue(); &#125; &#125;&#125; 时间复杂度: O(n)，遍历一次字符串。 空间复杂度: O(n)，使用StringBuilder，取决于字符串长度。 Solution 2使用一个int保存结果，另外一个int保存1或者-1代表正负数。截去字符串前后空格后，开始遍历字符串，有以下情况： 首字符为’-‘或’+’则更新正负数 若为数字 判断当前已保存的结果如果乘以10倍的过程中超出int范围则返回 把当前已保存的结果乘以10并加上当前字符的数值 再次判断是否超出int范围 其他情况则条件不符，退出遍历 其中判断是否超出int范围，可以用保存的数和加上当前数值后的符号是否发生变化来判断，因为超出区间后其正负发生反转。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int myAtoi(String str) &#123; if(str==null||str.length()==0) return 0; str=str.trim(); int num=0; int sign=1; for(int i=0;i&lt;str.length();i++)&#123; char curr = str.charAt(i); if(i==0&amp;&amp;curr=='+')&#123; sign=1; &#125;else if(i==0&amp;&amp;curr=='-')&#123; sign=-1; &#125;else if(curr&gt;='0'&amp;&amp;curr&lt;='9')&#123; int prev = 0; for(int j=0;j&lt;10;j++)&#123; prev+=num; if(num&gt;0&amp;&amp;prev&lt;0)&#123; return Integer.MAX_VALUE; &#125;else if(num&lt;0&amp;&amp;prev&gt;0)&#123; return Integer.MIN_VALUE; &#125; &#125; prev = 10*num + sign*(curr-'0'); if(num&gt;0&amp;&amp;prev&lt;0)&#123; return Integer.MAX_VALUE; &#125;else if(num&lt;0&amp;&amp;prev&gt;0)&#123; return Integer.MIN_VALUE; &#125; num=prev; &#125;else&#123; break; &#125; &#125; return num; &#125;&#125; 时间复杂度: O(n)，遍历一次字符串。 空间复杂度: O(1)，使用int数字保存。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 007 Reverse Integer]]></title>
    <url>%2Fposts%2F8972%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Noted: Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1].For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Difficulty: Easy Code: 12345class Solution &#123; public int reverse(int x) &#123; &#125;&#125; 题意给定一个32位有符号的整数，找出其反转后的整数。反转后的数字如果溢出，则返回0。 Solution 1将数字转成字符串，然后保留符号反转，去除掉最前面多出的0。再将字符串转成Long，比较数字是否在Int的范围，如果不在返回0。 123456789101112131415161718192021222324class Solution &#123; public int reverse(int x) &#123; String s = String.valueOf(x); String result = null; if(s.charAt(0)=='-')&#123; result = new StringBuilder(s.substring(1)).reverse().toString(); if(result.charAt(0)=='0'&amp;&amp;result.length()&gt;1)&#123; result=result.substring(1); &#125; result = '-'+result; &#125;else&#123; result = new StringBuilder(s).reverse().toString(); if(result.charAt(0)=='0'&amp;&amp;result.length()&gt;1)&#123; result=result.substring(1); &#125; &#125; Long out = Long.valueOf(result); if(out&gt;Integer.MAX_VALUE||out&lt;Integer.MIN_VALUE)&#123; return 0; &#125;else&#123; return Integer.valueOf(result); &#125; &#125;&#125; 时间复杂度: O(n)，取决于数字的长度。 空间复杂度: O(n)，取决于数字的长度。 Solution 2不使用字符串，直接循环取出原始整数的尾数从后往前进行累加。中间注意判断当前结果数是否超出范围。 int的范围是在-2147483648到2147483647之间，边界条件下反转后的最后一位也只能是1或者2，即21474836471和21474836472。再次反转得输入数字1463847412和2463847412，后者超出界限，故输入数字只能是1463847412。所以当反转后数字除以10不需要比较214748364，因为满足条件的只有2147483641。 12345678910111213class Solution &#123; public int reverse(int x) &#123; int result = 0; while(x!=0)&#123; if(Math.abs(result)&gt;Integer.MAX_VALUE/10)&#123; return 0; &#125; result = result*10 + x%10; x=x/10; &#125; return result; &#125;&#125; 时间复杂度: O(log(n))，取决于数字的长度。 空间复杂度: O(1)，只使用一个数字保留结果。 Solution 3跟解法2类似，使用long来保存中间结果。 12345678910111213class Solution &#123; public int reverse(int x) &#123; Long result = 0L; while(x!=0)&#123; result = result*10 + x%10; x=x/10; &#125; if(result&gt;Integer.MAX_VALUE||result&lt;Integer.MIN_VALUE)&#123; return 0; &#125; return result.intValue(); &#125;&#125; 时间复杂度: O(log(n))，取决于数字的长度。 空间复杂度: O(1)，只使用一个数字保留结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-math</tag>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建自定义页面的方法]]></title>
    <url>%2Fposts%2F56866%2F</url>
    <content type="text"><![CDATA[自定义页面的问题只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只默认渲染source目录下的文件，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用Hexo添加自定义的web页面呢？ 第一种解决方法第一种方法是使用Hexo提供的跳过渲染配置，针对某个文件或者目录进行排除。具体步骤，打开博客根目录_config.yml，找到其中skip_render项，这个项目用来配置/source/中需要跳过渲染的文件或目录。 假设source目录下的文件如以下目录树所示 123456789101112├─ demo| ├─ js-view-size| | ├─ 1.html| | └┈ 2.html| ├─ other| | ├─ 3.html| | ├─ 4.html| | └┈ 5.md| ├─ 6.html| └┈ 7.md├─ baidu.html└┈ google.html 排除单个文件排除baidu.html 12skip_render: - 'baidu.html' 排除多个文件排除baidu.html，google.html和3.html 1234skip_render: - 'baidu.html' - 'google.html' - 'demo/other/3.html' 或者 123skip_render: - '*.html' - 'demo/other/3.html' 排除source/demo/other目录中的所有文件 1skip_render: 'demo/other/**' 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外修改了配置后为了及时应用新配置，最好在生成之前执行一下hexo clean命令，清除掉旧的生成文件和缓存。 第二种解决方法第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 1layout: false 这样，这个文件就不会经过模板渲染，最终发布到/public/里的文件就是去掉标记后的文件的样子。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 006 ZigZag Conversion]]></title>
    <url>%2Fposts%2F16365%2F</url>
    <content type="text"><![CDATA[DescriptionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I Difficulty: Medium Code: 12345class Solution &#123; public String convert(String s, int numRows) &#123; &#125;&#125; 题意某字符串是基于给定的行数使用锯齿状格式书写，然后逐行读取成字符串。写一段代码完成该转换。 Solution 1可以使用nRows长的字符数组来保存格式转换后放置的所有字符。字符数组下标代表行数，该字符代表这一行的所有字符。遍历字符串并将当前字符放入对应的行，然后在遍历该数组，逐行读取所有字符。 123456789101112131415161718192021222324class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1)&#123; return s; &#125; String[] rows = new String[numRows]; Arrays.fill(rows,""); boolean goDown = false; int currRow =0; for(int i=0;i&lt;s.length();i++)&#123; rows[currRow]+=s.charAt(i); if(currRow==0||currRow==numRows-1)&#123; goDown=!goDown; &#125; currRow=goDown?currRow+1:currRow-1; &#125; String result = ""; for(String row:rows)&#123; result+=row; &#125; return result; &#125;&#125; 时间复杂度: O(n)，只从左到右遍历一次原始字符串。 空间复杂度: O(n)，使用来字符串数组来保存当前转换后到字符。 Solution 2按行直接读取转换后到字符。给定当前第几竖列k，有 第0行到字符在原始字符串的下标是k(2*numRows-2) 第numRows-1行在原始字符串的下标是k(2*numRows-2)+numRows-1 在这之间的第i行在原始字符串的下标是k(2numRows-2)+i和(k+1)(2numRows-2)-i 12345678910111213141516171819class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows==1)&#123; return s; &#125; StringBuilder result = new StringBuilder(); int cycleLen = 2*numRows -2; for(int i=0;i&lt;numRows;i++)&#123; for(int j=0;i+j&lt;s.length();j+=cycleLen)&#123; result.append(s.charAt(i+j)); if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;j+cycleLen-i&lt;s.length())&#123; result.append(s.charAt(j+cycleLen-i)); &#125; &#125; &#125; return result.toString(); &#125;&#125; 时间复杂度: O(n)，只遍历一次原始字符串。 空间复杂度: O(n)，使用StringBuilder来保存结果。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 005 Longest Palindromic Substring]]></title>
    <url>%2Fposts%2F26628%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; Difficulty: Medium Code: 12345class Solution &#123; public String longestPalindrome(String s) &#123; &#125;&#125; 题意给定一个字符串，找出最长的回文子串，假定字符串最大长度是1000。 Solution 1暴力遍历，外层作为子串的左侧，内层作为子串右侧，检查子串的左侧和右侧是否相等，若不等，则忽略，否则左侧和右侧往中间不断收缩继续检查。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int max=-1; String res=""; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; int left=i,right=j; boolean flag = true; while(left&lt;=right)&#123; if(s.charAt(left)!=s.charAt(right))&#123; flag=false; break; &#125; left++; right--; &#125; if(!flag)&#123; continue; &#125; if(j-i+1&gt;max)&#123; max=j-i+1; res=j==s.length()-1?s.substring(i):s.substring(i,j+1); &#125; &#125; &#125; return res; &#125;&#125; 时间复杂度: O(n3)，双层遍历，内部循环检查是否回文。 空间复杂度: O(1)，没有使用额外空间。 Solution 2遍历字符串，以当前字符为中心去检查最大回文(奇数长度)，另外以当前字符及当前字符下一位检查最大回文长度(偶数长度)。 12345678910111213141516171819202122232425class Solution &#123; int start=0,maxLen=0; public String longestPalindrome(String s) &#123; if(s.length()&lt;2)&#123; return s; &#125; for(int i=0;i&lt;s.length()-1;i++)&#123; searchPalindrome(s,i,i); searchPalindrome(s,i,i+1); &#125; return s.substring(start,start+maxLen); &#125; public void searchPalindrome(String s, int left, int right)&#123; while(left&gt;=0&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; if(right-left-1&gt;maxLen)&#123; maxLen=right-left-1; start=left+1; &#125; &#125;&#125; 时间复杂度: O(n2)，一层遍历，内部循环检查是否回文。 空间复杂度: O(1)，没有使用额外空间。 Solution 3使用动态规划，维护一个二维数组dp，其中dp[i][j]表示字符串区间[i,j]是否为回文串。 当j=i时，因为只有一个字符肯定是回文串，结果为true。 当j=i+1时，说明是相邻字符，只需要比较s[j]==s[i]。 当j&gt;i+1时，则判断s[j]==s[i] &amp;&amp; dp[i+1][j-1]。 123456789101112131415161718192021class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()&lt;=1)&#123; return s; &#125; boolean[][] dp = new boolean[s.length()][s.length()]; int left=0, right=0, maxLen=0; for(int j=0;j&lt;s.length();j++)&#123; dp[j][j]=true; for(int i=0;i&lt;j;i++)&#123; dp[i][j]=s.charAt(i)==s.charAt(j)&amp;&amp;(j&lt;=i+1||dp[i+1][j-1]); if(dp[i][j]&amp;&amp;j-i+1&gt;maxLen)&#123; left=i; right=j; maxLen=j-i+1; &#125; &#125; &#125; return s.substring(left,right+1); &#125;&#125; 时间复杂度: O(n2)，两层遍历。 空间复杂度: O(n2)，使用二维数组存储结果。 Solution 4使用马拉车算法Manacher’s Algorithm，这个算法将时间复杂度提升到了O(n)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 004 Median of Two Sorted Arrays]]></title>
    <url>%2Fposts%2F40546%2F</url>
    <content type="text"><![CDATA[DescriptionThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Difficulty: Hard Code: 12345class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; &#125;&#125; 题意给定两个有序数组，长度分别是m和n。找出这两个数组到中位数，总体到时间复杂度要求O(log (m+n))，假定两个数组都不为空。 Solution 1中位数是把一组有序数分成两个相等长度的部分，一部分比另外一部分都要大。如果是偶数个，则取最中间两个数的平均数。 如果两个有序数组混合起来成为一个有序数组再去找中位数，肯定很简单，但是时间复杂度应该是O(m+n)，不符合要求。O(log (m+n))提示应该是用二分查找，但是两个数组又如何去做，着实很难。 首先将数组A在随机的位置i切成两部分： 12 left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 因为A有m个元素，所以有m+1种切法(i=0~m)。 12len(left_A)=i,len(right_A)=m−i.Note: when i = 0, left_A is empty, and when i = m, right_A is empty. 使用同样的方式，把数组B在随机位置j切成两部分。 12 left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 把left_A和left_B放到一起合并成left_part，把right_A和right_B放到一起合并成right_part。 123 left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们能保证 121. len(left_part)=len(right_part)2. max(left_part)≤min(right_part) 那么我们就成功将数组A和B中所有的元素分成了长度相同的两部分，并且一部分总是比另外一部分大。那么 1median= (max(left_part)+min(right_part))/2 为了达到上述两个条件，只需要保证 1231. i+j=m−i+n−j or i+j=m−i+n−j+1 如果n&gt;=m，只需要设：i=0~m,j=(m+n+1)/2-i;2. B[j−1] ≤ A[i] and A[i−1] ≤ B[j] ps.1 为了简化，假定A[i-1],B[j-1],A[i],B[j]都是有效的即使i=0,i=m,j=0,j=n。后面会介绍这些边界值如何处理。 ps.2 为什么要保证n&gt;=m，因为要保证j是非负数。 所以我们需要做的是 12在[0~m]中查找i，能够满足B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j], j=(m+n+1)/2-i 按照以下的步骤进行二分查找 初始化imin=0 and imax=m，然后在[imin,imax]进行查找 设置i=(imin+imax)/2 and j=(m+n+1)/2-i 已经达成len(left_part)=len(right_part)，只会碰到3种情况 B[j-1]&lt;=A[i] and A[i-1]&lt;=B[j] 意味着我们找到了目标i，停止查找 B[j-1]&gt;A[i] 意味着A[i]太小，必须增大i以达到B[j-1]&lt;=A[i]。当i增大时，j减小，A[i]增大，B[j-1]减小。调整查找范围[i+1,imax]，imin=i+1，跳转到第2步。 A[i-1]&gt;B[j] 意味着A[i-1]太大，必须减小i以达到A[i-1]&lt;=B[j]。调整查找范围[imin,i-1]，imax=i-1，跳转到第2步 当目标i找到时，中位数是 12max(A[i-1],B[j-1])，当m+n是奇数(max(A[i-1],B[j-1)+min(A[i]+B[j])/2，当m+n是偶数 现在考虑边界值，i=0,i=m,j=0,j=m，此时A[i-1],B[j-1],A[i],B[j]可能不存在。 只需要保证max(left_part)&lt;=min(right_part)，但是当A[i-1],B[j-1],A[i],B[j]不存在时，不需要检查所有的那两个条件。 1(j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j])，当j=(m+n+1)/2-i 在循环搜索时，只会碰到以下三种情况 1234561. (j=0 or i=m or B[j−1]≤A[i]) and ( i=0 or j=n or A[i-1]&lt;=B[j]) 意味着i已经找到，可以停止搜索2. j&gt;0 and i&lt;m and B[j-1]&gt;A[i] 意味着i太小，要增大i3. i&gt;0 and j&lt;n and A[j-1]&gt;B[j] 意味着i太大，要减小i 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m=nums1.length; int n=nums2.length; if(m&gt;n)&#123; return findMedianSortedArrays(nums2,nums1); &#125; int imin=0,imax=m,halfLen=(m+n+1)/2; while(imin&lt;=imax)&#123; int i = (imin+imax)/2; int j = halfLen-i; if(i&lt;imax&amp;&amp;nums2[j-1]&gt;nums1[i])&#123; imin=i+1; &#125;else if(i&gt;imin&amp;&amp;nums1[i-1]&gt;nums2[j])&#123; imax=i-1; &#125;else&#123; int maxLeft=0; if(i==0)&#123; maxLeft=nums2[j-1]; &#125;else if(j==0)&#123; maxLeft=nums1[i-1]; &#125;else&#123; maxLeft=Math.max(nums1[i-1],nums2[j-1]); &#125; if((m+n)%2==1)&#123; return maxLeft; &#125; int minRight=0; if(i==m)&#123; minRight=nums2[j]; &#125;else if(j==n)&#123; minRight=nums1[i]; &#125;else&#123; minRight=Math.min(nums1[i],nums2[j]); &#125; return (maxLeft+minRight)/2.0; &#125; &#125; return 0.0; &#125;&#125; 时间复杂度: O(log (m+n))，每次调整i都是将其范围减半。 空间复杂度: O(1)，只使用了固定几个变量保存状态。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hard</tag>
        <tag>leetcode-binary-search</tag>
        <tag>leetcode-divide-and-conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 003 Longest Substring Without Repeating Characters]]></title>
    <url>%2Fposts%2F33885%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Difficulty: Medium Code: 12345class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; &#125;&#125; 题意给定一个字符串，找出不包含重复字符的最长子串的长度。 Solution 1使用两层遍历，外层是子串起始字符，内层则进行遍历时检查是否包含重复字符，若不包含则继续往后面移动，直到有重复字符或者到达末尾则结束。 将此子串到最大长度和已保存到最大长度进行对比，去其中大的进行更新。 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length() &lt;= 1)&#123; return s.length(); &#125; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for(int j=i;j&lt;s.length();j++)&#123; if(set.contains(s.charAt(j)))&#123; max = Math.max(max,j-i); break; &#125;else&#123; set.add(s.charAt(j)); max = Math.max(max,j-i+1); &#125; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(n2)，两层循环遍历。 空间复杂度: O(n)，用来HashSet来存储每次已经遍历过的字符。 Solution 2使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashSet中，同时更新最大子串长度。 若检测到HashSet中已经存在该字符，则从HashSet删除窗口左侧元素并移动左侧位置，直到不包含重复字符为止。 123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()&lt;=1) return s.length(); Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int left=0, right=0, max = 0; while(right&lt;s.length())&#123; if(set.contains(s.charAt(right)))&#123; set.remove(s.charAt(left)); left++; &#125;else&#123; set.add(s.charAt(right)); max = Math.max(max,right-left+1); right++; &#125; &#125; return max; &#125;&#125; 时间复杂度: O(2n)=O(n)，一层循环，主要是右侧窗口移动。 空间复杂度: O(n)，用来HashSet来存储已经遍历过的字符。 Solution 3同样使用滑动窗口，窗口的左右两侧起始都是字符串第一个字符，然后向前移动窗口的右侧，同时将当前字符和其所在位置放入HashMap中，同时更新最大子串长度。 若检测到HashMap中已经存在该字符，则判断已存在字符到位置是否小于窗口左侧，若小于则忽略，否则直接移动窗口左侧到此位置到右侧。 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()&lt;=1) return s.length(); Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); int max = 0; for(int left=0,right=0;right&lt;s.length();right++)&#123; if(map.containsKey(s.charAt(right)) &amp;&amp; map.get(s.charAt(right))&gt;=left)&#123; left=map.get(s.charAt(right))+1; &#125; map.put(s.charAt(right),right); max = Math.max(max,right-left+1); &#125; return max; &#125;&#125; 时间复杂度: O(n)，一层循环遍历，HashMap操作耗时O(1)。 空间复杂度: O(n)，用来HashMap来存储已经遍历过的字符。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-hash-table</tag>
        <tag>leetcode-two-pointers</tag>
        <tag>leetcode-string</tag>
        <tag>leetcode-sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 002 Add Two Numbers]]></title>
    <url>%2Fposts%2F4084%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Difficulty: Medium Code: 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; &#125;&#125; 题意给定两个非空链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。假定两个数不包含任何前置0，除非这个数本身就是0。 这其实就是两个非负整数的加法运算，先从最后一位相加，有进位则保留在下一位中计算进去。 Solution 1就是建立一个新链表，然后把输入的两个链表从头往后撸，每两个相加，添加一个新节点到新链表后面。在新链表的头增加一个哨兵节点是非常重要的一个方法，这样就可以解放头结点的作用，方便进行处理。这样遍历时结果链表就可以从哨兵节点作为起始当前节点，返回结果时返回哨兵节点的下一个节点。 While循环条件是只要两个链表当前节点有一个不为空，当其中一个链表当前节点为空时，其值取0，后续节点取null。两个节点值相加，同时还要加上进位，以和对10求余作为新节点对值，添加到结果节点到下一位，并且更新进位。而后更新两个节点，若存在则指向其下一个节点。While退出后若进位不为0则新建节点添加到结果链表的末尾。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode curr = dummy; int carry = 0; while(l1 != null || l2 != null)&#123; int v1 = l1!=null ? l1.val : 0; int v2 = l2!=null ? l2.val : 0; int sum = v1 + v2 + carry; curr.next = new ListNode(sum%10); carry = sum/10; l1 = l1!=null ? l1.next : null; l2 = l2!=null ? l2.next : null; curr = curr.next; &#125; if(carry!=0)&#123; curr.next = new ListNode(carry); &#125; return dummy.next; &#125;&#125; 时间复杂度: O(max(m,n))，遍历到步长取决于两个链表的最大长度。 空间复杂度: O(max(m,n))，和的位数取决于最大数的位数。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-medium</tag>
        <tag>leetcode-linked-list</tag>
        <tag>leetcode-math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 001 Two Sum]]></title>
    <url>%2Fposts%2F45823%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Difficulty: Easy Code: 12345class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; &#125;&#125; 题意给定一个整数数组，从中找出两个数的下标，使得它们的和等于一个特定的数字。假定每个输入肯定会有一个唯一解，同一个元素不可以使用两次。 Solution 1可以使用两层循环去遍历数组，外层从下标0开始，内层从外层下标+1开始。若外层和内层之和等于目标值则返回外层和内层的下标。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return new int[]&#123;&#125;; &#125;&#125; 时间复杂度: O(n2)，两层循环的遍历。 空间复杂度: O(1)，没有使用额外的空间储存。 Solution 2遍历一遍数组，将数字放入以数字为Key以数组下标为Value的HashMap中，在放入前检查HashMap中是否已经存在另外一个数满足两数之和等于目标值。若存在则返回HashMap中数字的下标和当前数字的下标。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;&#125;; &#125;&#125; 时间复杂度: O(n)，只对数组遍历来一次，HashMap的操作耗时是O(1)。 空间复杂度: O(n)，使用HashMap储存数组中的数字。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>leetcode-easy</tag>
        <tag>leetcode-array</tag>
        <tag>leetcode-hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown扩展语法]]></title>
    <url>%2Fposts%2F38514%2F</url>
    <content type="text"><![CDATA[Markdown扩展语法的由来是基本语法不太够用，一些个人和组织添加来额外的元素来扩展基本语法。主要包括表格、代码块、语法高亮、URL自动链接、脚注。 可用性扩展语法并不是在所有的Markdown应用中都能使用，你需要去检查自己的应用使用的轻量级Markdown语言是否支持。 轻量级Markdown语言这里列举集中轻量级Markdown语言，很多流行的Markdown应用都使用其中一种。 CommonMark GitHub Flavored Markdown (GFM) Markdown Extra MultiMarkdown Markdown处理器有很多可用的Markdown处理器，都能够允许你增加扩展去使用扩展语法。 表格使用3个或者更多的连字符---去创建每一列的表头，使用竖线|去分割每一列。 123456789| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text || Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text | Syntax Description Header Title Paragraph Text 对齐可以在表头连字符的左边、右边、两边添加:来达到列文字居左、居右、居中对齐的效果。 1234| Syntax | Description | Test Text || :--- | :----: | ---: || Header | Title | Here&apos;s this || Paragraph | Text | And more | Syntax Description Test Text Header Title Here’s this Paragraph Text And more 表格中文字的格式化在表格中，可以加入链接、代码、加粗、斜体。 表格中竖线的转义可以使用竖线对应的HTML字符编码&amp;#124;来表示|。 带栅栏的代码块Markdown基本语法允许使用缩进4个空格或者1个tab来创建代码块。另外你也可以使用3个反引号```或者3个波浪号~~~在代码块的前后来创建带栅栏的代码块，不需要缩进任何行。 1234567```&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;``` 12345&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125; 语法高亮很多Markdown处理器支持在带栅栏的代码块中语法高亮，这将使你用任何语言写的代码增加色彩高亮。只需要在反引号后紧接着指定语言，即可实现。 1234567```json&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;``` 12345&#123; "firstName": "John", "lastName": "Smith", "age": 25&#125; 脚注脚注允许你增加笔记和参考在不截断文章内容的前提下。当你创建一个脚注，一个带链接上标数字就会出现在你加脚注的地方。点击链接就可以跳转到页面底部脚注的内容。 在[]中添加异或符号^和标识即可创建脚注引用。标识即可是数字也可是字符，但不能包含空格或者制表符。 1234567891011Here&apos;s a simple footnote,[^1] and here&apos;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&apos;s one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `&#123; my code &#125;` Add as many paragraphs as you like. 标题IDs可以给标题加自定义ID，这样能链接到标题并且可以通过CSS样式进行修改。在标题后把自定义ID用{}包裹 1### My Great Heading &#123;#custom-id&#125; 指向标题到链接创建一个标准到链接，链接地址使用#再跟上标题ID。 1[Heading IDs](#heading-ids) 轻量级Markdown语言 定义列表创建术语到定义列表，把术语放在第一行，下一行用:接一个空格开头，后面写定义。 123456First Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term. 删除线删除线能够在文字到中间加一条水平线，以表示文字是错误的。使用两个波浪线在文字的前后即可创建删除线。 1~~The world is flat.~~ We now know that the world is round. The world is flat. We now know that the world is round. 任务列表任务列表可以创建一系列带复选框的事项，使用连字符-加空格，再加[ ]，而后跟事项。选中复选框，使用[x]. 123- [x] Write the press release- [ ] Update the website- [ ] Contact the media Write the press release Update the website Contact the media URL自动生成链接很多Markdown处理器能自动将URL转成链接，不用加&lt;&gt;。 1http://www.example.com http://www.example.com 禁止URL自动生成链接如果你不想将URL自动转成链接，你可以将URL当成代码。 1`http://www.example.com` http://www.example.com]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2Fposts%2F48840%2F</url>
    <content type="text"><![CDATA[Markdown基本语法，几乎所有Markdown应用程序都支持John Gruber原始设计文档中概述的基本语法。 标题在标题前插入1到6个#，表示6个不同级别的标题 123456# Heading level 1## Heading level 2### Heading level 3#### Heading level 4##### Heading level 5###### Heading level 6 段落段落之间用空行隔开，不能使用空格或者缩进 123I really like using Markdown.I think I&apos;ll use it to format all of my documents from now on. 换行符在文字中间插入&lt;br&gt;可以进行换行，或者两个空格再回车。 1This is the first line. &lt;br&gt; And this is the second line. This is the first line. And this is the second line. 强调加粗在文字的前后用两个*或者_可以加粗字体 123I just love **bold text**.I just love __bold text__.Love**is**bold I just love bold text.I just love bold text.Loveisbold 斜体在文字的前后用一个*或者_可以变成斜体 123Italicized text is the *cat&apos;s meow*.Italicized text is the _cat&apos;s meow_.A*cat*meow Italicized text is the cat’s meow.Italicized text is the cat’s meow.Acatmeow 同时加粗和斜体在文字的前后用三个*或者_可以同时加粗和变成斜体 12This text is ***really important***.This text is ___really important___. This text is really important.This text is really important. 引用在一段文字中的开头加上 &gt; 来表示一段引用文字 1&gt; Dorothy followed her through many of the beautiful rooms in her castle. Dorothy followed her through many of the beautiful rooms in her castle. 引用多个段落在每个段落及空行开头加上 &gt; 来表示引用多段文字 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor. 引用嵌套引用可以嵌套，在段落的开头加上&gt;&gt; 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor. 引用中使用其他元素引用中可以包含其他Markdown的元素，但并不是所有但元素都可以用 123456&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt; *Everything* is going according to **plan**. The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. 列表列表可以分为有序列表和无序列表 有序列表有序列表在文字开头加上数字和点，数字并不要求按照顺序，但是起始应该是1 123456789101112131415161. First item2. Second item3. Third item4. Fourth item1. First item8. Second item3. Third item5. Fourth item1. First item2. Second item3. Third item 1. Indented item 2. Indented item4. Fourth item First item Second item Third item Indented item Indented item Fourth item 无序列表无序列表在每一行开头加上-、+、*，缩进去创建嵌套列表 123456789101112131415161718192021- First item- Second item- Third item- Fourth item* First item* Second item* Third item* Fourth item+ First item* Second item- Third item+ Fourth item- First item- Second item- Third item - Indented item - Indented item- Fourth item First item Second item Third item Indented item Indented item Fourth item 在列表中添加其他元素在列表中添加其他元素，要缩进4个空格或者1个tab 123456* This is the first list item.* Here&apos;s the second list item. I need to add another paragraph below the second list item.* And here&apos;s the third list item. This is the first list item. Here’s the second list item. I need to add another paragraph below the second list item. And here’s the third list item. 代码要表示一行代码，使用`来包裹 1At the command prompt, type `nano`. At the command prompt, type nano. 反引号转义在一行代码中如果代码本身也含有反引号，可以把最外层用两个反引号包裹 1``Use `code` in your Markdown file.`` Use `code` in your Markdown file. 代码块代码块的每行代码必须最少缩进4个空格或者1个tab 12345#### &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; 分割线使用三个及以上的*、-、_表示分割线 12345***---_________________ 链接用[]包裹链接文字，随后用()包裹URL 1My favorite search engine is [Duck Duck Go](https://duckduckgo.com). My favorite search engine is Duck Duck Go. 链接添加提示1My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best one&quot;). My favorite search engine is Duck Duck Go. 网页和邮箱为了快速将网页和邮箱转为链接，可以用&lt;&gt;包裹起来 12&lt;https://www.markdownguide.org&gt;&lt;fake@example.com&gt; https://www.markdownguide.org&#102;&#x61;&#x6b;&#x65;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d; 格式化链接为了强调链接，可以在链接的前后加星号 12I love supporting **[EFF](https://eff.org)**.This is the *[Markdown Guide](https://www.markdownguide.org)*. I love supporting EFF.This is the Markdown Guide. 图片图片的插入方式是在最开始插入!，然后用[]包裹图片无法加载的描述，再把图片的地址用()包裹 1![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;) 带链接的图片给图片加链接的方式是，把图片的Markdown用[]包裹，再在后面把链接地址用()包裹 1[![Google](http://pngimg.com/uploads/google/google_PNG19631.png &quot;Google Search&quot;)](https://www.google.com) 转义字符如果有些符号是Markdown使用的，但是又想显示，可以在字符前加\ 1\* Without the backslash, this would be a bullet in an unordered list. 转义字符列表 Character Name \ backslash ` tick mark * asterisk _ underscore {} curly braces [] brackets () parentheses # pound sign + plus sign - minus sign (hyphen) . dot ! exclamation mark]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
